diff -r -U4 ./cdm/src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java
--- ./cdm/src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java	2011-07-27 11:12:24.000000000 -0700
+++ ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java	2011-11-03 21:28:04.374437811 -0700
@@ -99,8 +99,18 @@
     return IospHelper.readSection(cer);  //  IOSPs can optimize by overriding
   }
 
   @Override
+  public boolean supportsLocalityInformation() throws IOException {
+    throw new IOException("This IOSP does not support getLocalityInformation()");
+  }
+
+  @Override
+  public ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section) throws IOException, InvalidRangeException {
+    throw new IOException("This IOSP does not support getLocalityInformation()");
+  }
+
+  @Override
   public StructureDataIterator getStructureIterator(Structure s, int bufferSize) throws java.io.IOException {
     return null;
   }
 
diff -r -U4 ./cdm/src/main/java/ucar/nc2/iosp/IOServiceProvider.java ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/IOServiceProvider.java
--- ./cdm/src/main/java/ucar/nc2/iosp/IOServiceProvider.java	2011-07-27 11:12:32.000000000 -0700
+++ ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/IOServiceProvider.java	2011-11-03 22:01:10.594436696 -0700
@@ -1,195 +1,221 @@
-/*
- * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
- *
- * Portions of this software were developed by the Unidata Program at the
- * University Corporation for Atmospheric Research.
- *
- * Access and use of this software shall impose the following obligations
- * and understandings on the user. The user is granted the right, without
- * any fee or cost, to use, copy, modify, alter, enhance and distribute
- * this software, and any derivative works thereof, and its supporting
- * documentation for any purpose whatsoever, provided that this entire
- * notice appears in all copies of the software, derivative works and
- * supporting documentation.  Further, UCAR requests that the user credit
- * UCAR/Unidata in any publications that result from the use of this
- * software or in any product that includes this software. The names UCAR
- * and/or Unidata, however, may not be used in any advertising or publicity
- * to endorse or promote any products or commercial entity unless specific
- * written permission is obtained from UCAR/Unidata. The user also
- * understands that UCAR/Unidata is not obligated to provide the user with
- * any support, consulting, training or assistance of any kind with regard
- * to the use, operation and performance of this software nor to provide
- * the user with any updates, revisions, new versions or "bug fixes."
- *
- * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
- * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
- * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
- * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-package ucar.nc2.iosp;
-
-import ucar.ma2.Section;
-import ucar.ma2.InvalidRangeException;
-import ucar.ma2.StructureDataIterator;
-import ucar.nc2.ParsedSectionSpec;
-import ucar.nc2.Structure;
-
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
-
-/**
- * This is the service provider interface for the low-level I/O access classes (read only).
- * This is only used by service implementors.
- *
- * The NetcdfFile class manages all registered IOServiceProvider classes.
- * When NetcdfFile.open() is called:
- * <ol>
- * <li> the file is opened as a ucar.unidata.io.RandomAccessFile;</li>
- * <li> the file is handed to the isValidFile() method of each registered
- * IOServiceProvider class (until one returns true, which means it can read the file).</li>
- * <li> the open() method on the resulting IOServiceProvider class is handed the file.</li>
- *
- * @see ucar.nc2.NetcdfFile#registerIOProvider(Class) ;
- *
- * @author caron
- */
-public interface IOServiceProvider {
-
-   /**
-    * Check if this is a valid file for this IOServiceProvider.
-    * You must make this method thread safe, ie dont keep any state.
-    * 
-    * @param raf RandomAccessFile
-    * @return true if valid.
-    * @throws java.io.IOException if read error
-    */
-  public boolean isValidFile( ucar.unidata.io.RandomAccessFile raf) throws IOException;
-
-  /**
-   * Open existing file, and populate ncfile with it. This method is only called by the
-   * NetcdfFile constructor on itself. The provided NetcdfFile object will be empty
-   * except for the location String and the IOServiceProvider associated with this
-   * NetcdfFile object.
-   *
-   * @param raf the file to work on, it has already passed the isValidFile() test.
-   * @param ncfile add objects to this empty NetcdfFile 
-   * @param cancelTask used to monitor user cancellation; may be null.
-   * @throws IOException if read error
-   */
-  public void open(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile,
-                   ucar.nc2.util.CancelTask cancelTask) throws IOException;
-
-  /**
-   * Read data from a top level Variable and return a memory resident Array.
-   * This Array has the same element type as the Variable, and the requested shape.
-   *
-   * @param v2 a top-level Variable
-   * @param section the section of data to read.
-   *   There must be a Range for each Dimension in the variable, in order.
-   *   Note: no nulls allowed. IOSP may not modify.
-   * @return the requested data in a memory-resident Array
-   * @throws java.io.IOException if read error
-   * @throws ucar.ma2.InvalidRangeException if invalid section
-   * @see ucar.ma2.Range
-   */
-  public ucar.ma2.Array readData(ucar.nc2.Variable v2, Section section)
-         throws java.io.IOException, ucar.ma2.InvalidRangeException;
-
-  /**
-   * Read data from a top level Variable and send data to a WritableByteChannel.
-   * Must be in big-endian order.
-   *
-   * @param v2 a top-level Variable
-   * @param section the section of data to read.
-   *   There must be a Range for each Dimension in the variable, in order.
-   *   Note: no nulls allowed. IOSP may not modify.
-   * @param channel write data to this WritableByteChannel
-   * @return the number of bytes written to the channel
-   * @throws java.io.IOException if read error
-   * @throws ucar.ma2.InvalidRangeException if invalid section
-   */
-  public long readToByteChannel(ucar.nc2.Variable v2, Section section, WritableByteChannel channel)
-         throws java.io.IOException, ucar.ma2.InvalidRangeException;
-
-  /**
-   * Allows reading sections of nested variables
-   * @param cer section specification : what data is wanted
-   * @return requested data array
-   * @throws IOException on read error
-   * @throws InvalidRangeException if section spec is invalid
-   */
-  public ucar.ma2.Array readSection(ParsedSectionSpec cer) throws IOException, InvalidRangeException;
-
-  // iosps with top level sequences must override
-  public StructureDataIterator getStructureIterator(Structure s, int bufferSize) throws java.io.IOException;
-
-  /**
-   * Close the file.
-   * It is the IOServiceProvider's job to close the file (even though it didnt open it),
-   * and to free any other resources it has used.
-   * @throws IOException if read error
-   */
-  public void close() throws IOException;
-
-  /**
-   * Extend the NetcdfFile if the underlying dataset has changed
-   * in a way that is compatible with the current metadata.
-   * For example, if the unlimited dimension has grown.
-   *
-   * @return true if the NetcdfFile was extended.
-   * @throws IOException if a read error occured when accessing the underlying dataset.
-   */
-  public boolean syncExtend() throws IOException;
-
-  /**
-   * Update the metadata in the NetcdfFile if the underlying dataset has changed.
-   *
-   * @return true if the NetcdfFile was changed.
-   * @throws IOException if a read error occured when accessing the underlying dataset.
-   */
-  public boolean sync() throws IOException;
-
-  /**
-   * A way to communicate arbitrary information to an iosp.
-   * @param message opaque message.
-   * @return opaque return, may be null.
-   */
-  public Object sendIospMessage( Object message);
-
-  /** Debug info for this object.
-   * @param o which object
-   * @return debug info for this object
-   */
-  public String toStringDebug(Object o);
-
-  /** Show debug / underlying implementation details
-   * @return debug info
-   */
-  public String getDetailInfo();
-
-  /**
-   * Get a unique id for this file type.
-   * @return registered id of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeId();
-
-  /**
-   * Get the version of this file type.
-   * @return version of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeVersion();
-
-  /**
-   * Get a human-readable description for this file type.
-   * @return description of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeDescription();
-
-}
\ No newline at end of file
+/*
+ * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
+ *
+ * Portions of this software were developed by the Unidata Program at the
+ * University Corporation for Atmospheric Research.
+ *
+ * Access and use of this software shall impose the following obligations
+ * and understandings on the user. The user is granted the right, without
+ * any fee or cost, to use, copy, modify, alter, enhance and distribute
+ * this software, and any derivative works thereof, and its supporting
+ * documentation for any purpose whatsoever, provided that this entire
+ * notice appears in all copies of the software, derivative works and
+ * supporting documentation.  Further, UCAR requests that the user credit
+ * UCAR/Unidata in any publications that result from the use of this
+ * software or in any product that includes this software. The names UCAR
+ * and/or Unidata, however, may not be used in any advertising or publicity
+ * to endorse or promote any products or commercial entity unless specific
+ * written permission is obtained from UCAR/Unidata. The user also
+ * understands that UCAR/Unidata is not obligated to provide the user with
+ * any support, consulting, training or assistance of any kind with regard
+ * to the use, operation and performance of this software nor to provide
+ * the user with any updates, revisions, new versions or "bug fixes."
+ *
+ * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+package ucar.nc2.iosp;
+
+import ucar.ma2.Section;
+import ucar.ma2.InvalidRangeException;
+import ucar.ma2.StructureDataIterator;
+import ucar.nc2.ParsedSectionSpec;
+import ucar.nc2.Structure;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+/**
+ * This is the service provider interface for the low-level I/O access classes (read only).
+ * This is only used by service implementors.
+ *
+ * The NetcdfFile class manages all registered IOServiceProvider classes.
+ * When NetcdfFile.open() is called:
+ * <ol>
+ * <li> the file is opened as a ucar.unidata.io.RandomAccessFile;</li>
+ * <li> the file is handed to the isValidFile() method of each registered
+ * IOServiceProvider class (until one returns true, which means it can read the file).</li>
+ * <li> the open() method on the resulting IOServiceProvider class is handed the file.</li>
+ *
+ * @see ucar.nc2.NetcdfFile#registerIOProvider(Class) ;
+ *
+ * @author caron
+ */
+public interface IOServiceProvider {
+
+   /**
+    * Check if this is a valid file for this IOServiceProvider.
+    * You must make this method thread safe, ie dont keep any state.
+    * 
+    * @param raf RandomAccessFile
+    * @return true if valid.
+    * @throws java.io.IOException if read error
+    */
+  public boolean isValidFile( ucar.unidata.io.RandomAccessFile raf) throws IOException;
+
+  /**
+   * Open existing file, and populate ncfile with it. This method is only called by the
+   * NetcdfFile constructor on itself. The provided NetcdfFile object will be empty
+   * except for the location String and the IOServiceProvider associated with this
+   * NetcdfFile object.
+   *
+   * @param raf the file to work on, it has already passed the isValidFile() test.
+   * @param ncfile add objects to this empty NetcdfFile 
+   * @param cancelTask used to monitor user cancellation; may be null.
+   * @throws IOException if read error
+   */
+  public void open(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile,
+                   ucar.nc2.util.CancelTask cancelTask) throws IOException;
+
+  /**
+   * Read data from a top level Variable and return a memory resident Array.
+   * This Array has the same element type as the Variable, and the requested shape.
+   *
+   * @param v2 a top-level Variable
+   * @param section the section of data to read.
+   *   There must be a Range for each Dimension in the variable, in order.
+   *   Note: no nulls allowed. IOSP may not modify.
+   * @return the requested data in a memory-resident Array
+   * @throws java.io.IOException if read error
+   * @throws ucar.ma2.InvalidRangeException if invalid section
+   * @see ucar.ma2.Range
+   */
+  public ucar.ma2.Array readData(ucar.nc2.Variable v2, Section section)
+         throws java.io.IOException, ucar.ma2.InvalidRangeException;
+
+  /**
+   * Read data from a top level Variable and send data to a WritableByteChannel.
+   * Must be in big-endian order.
+   *
+   * @param v2 a top-level Variable
+   * @param section the section of data to read.
+   *   There must be a Range for each Dimension in the variable, in order.
+   *   Note: no nulls allowed. IOSP may not modify.
+   * @param channel write data to this WritableByteChannel
+   * @return the number of bytes written to the channel
+   * @throws java.io.IOException if read error
+   * @throws ucar.ma2.InvalidRangeException if invalid section
+   */
+  public long readToByteChannel(ucar.nc2.Variable v2, Section section, WritableByteChannel channel)
+         throws java.io.IOException, ucar.ma2.InvalidRangeException;
+
+  /**
+   * Allows reading sections of nested variables
+   * @param cer section specification : what data is wanted
+   * @return requested data array
+   * @throws IOException on read error
+   * @throws InvalidRangeException if section spec is invalid
+   */
+  public ucar.ma2.Array readSection(ParsedSectionSpec cer) throws IOException, InvalidRangeException;
+
+  /**
+   * Calculate the offset in the underlying byte-stream for each value
+   * indicated by the section and variable objects
+   *
+   * @param v2 a top-level Variable
+   * @param section the section of data to read.
+   *   There must be a Range for each Dimension in the variable, in order.
+   *   Note: no nulls allowed. IOSP may not modify.
+   * @return an ArrayLong the same shape as section where each entry is the 
+   *         offset of the corresponding data element
+   * @throws java.io.IOException if read error or if this IOSP doesn't 
+   *                             support getLocalityInformation()
+   * @throws ucar.ma2.InvalidRangeException if invalid section
+   */
+  public ucar.ma2.ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section) 
+         throws IOException, InvalidRangeException;
+
+  /**
+   * Determine if this IOServiceProvider supports the getLocalityInformation() function
+   *
+   * @return a boolean indicating if getLocalityInformation is supported by
+   *         this IOServiceProvider
+   */
+  public boolean supportsLocalityInformation() throws IOException;
+
+
+  // iosps with top level sequences must override
+  public StructureDataIterator getStructureIterator(Structure s, int bufferSize) throws java.io.IOException;
+
+  /**
+   * Close the file.
+   * It is the IOServiceProvider's job to close the file (even though it didnt open it),
+   * and to free any other resources it has used.
+   * @throws IOException if read error
+   */
+  public void close() throws IOException;
+
+  /**
+   * Extend the NetcdfFile if the underlying dataset has changed
+   * in a way that is compatible with the current metadata.
+   * For example, if the unlimited dimension has grown.
+   *
+   * @return true if the NetcdfFile was extended.
+   * @throws IOException if a read error occured when accessing the underlying dataset.
+   */
+  public boolean syncExtend() throws IOException;
+
+  /**
+   * Update the metadata in the NetcdfFile if the underlying dataset has changed.
+   *
+   * @return true if the NetcdfFile was changed.
+   * @throws IOException if a read error occured when accessing the underlying dataset.
+   */
+  public boolean sync() throws IOException;
+
+  /**
+   * A way to communicate arbitrary information to an iosp.
+   * @param message opaque message.
+   * @return opaque return, may be null.
+   */
+  public Object sendIospMessage( Object message);
+
+  /** Debug info for this object.
+   * @param o which object
+   * @return debug info for this object
+   */
+  public String toStringDebug(Object o);
+
+  /** Show debug / underlying implementation details
+   * @return debug info
+   */
+  public String getDetailInfo();
+
+  /**
+   * Get a unique id for this file type.
+   * @return registered id of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeId();
+
+  /**
+   * Get the version of this file type.
+   * @return version of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeVersion();
+
+  /**
+   * Get a human-readable description for this file type.
+   * @return description of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeDescription();
+
+}
diff -r -U4 ./cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
--- ./cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java	2011-07-27 11:12:30.000000000 -0700
+++ ../fake_netcdf/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java	2011-11-03 21:56:38.564436849 -0700
@@ -1,938 +1,1000 @@
-/*
- * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
- *
- * Portions of this software were developed by the Unidata Program at the
- * University Corporation for Atmospheric Research.
- *
- * Access and use of this software shall impose the following obligations
- * and understandings on the user. The user is granted the right, without
- * any fee or cost, to use, copy, modify, alter, enhance and distribute
- * this software, and any derivative works thereof, and its supporting
- * documentation for any purpose whatsoever, provided that this entire
- * notice appears in all copies of the software, derivative works and
- * supporting documentation.  Further, UCAR requests that the user credit
- * UCAR/Unidata in any publications that result from the use of this
- * software or in any product that includes this software. The names UCAR
- * and/or Unidata, however, may not be used in any advertising or publicity
- * to endorse or promote any products or commercial entity unless specific
- * written permission is obtained from UCAR/Unidata. The user also
- * understands that UCAR/Unidata is not obligated to provide the user with
- * any support, consulting, training or assistance of any kind with regard
- * to the use, operation and performance of this software nor to provide
- * the user with any updates, revisions, new versions or "bug fixes."
- *
- * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
- * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
- * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
- * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-package ucar.nc2.iosp.netcdf3;
-
-import ucar.ma2.*;
-import ucar.unidata.io.RandomAccessFile;
-import ucar.nc2.*;
-import ucar.nc2.iosp.*;
-import ucar.unidata.util.Format;
-
-import java.util.*;
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
-import java.io.*;
-import java.nio.charset.Charset;
-import java.nio.CharBuffer;
-import java.nio.ByteBuffer;
-import java.nio.channels.WritableByteChannel;
-
-/**
- * IOServiceProvider implementation abstract base class to read/write "version 3" netcdf files.
- * AKA "file format version 1" files.
- *
- * @author caron
- * @see N3raf concrete class
- */
-
-public abstract class N3iosp extends AbstractIOServiceProvider implements IOServiceProviderWriter {
-  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(N3iosp.class);
-
-  // Default fill values, used unless _FillValue variable attribute is set.
-  static public final byte NC_FILL_BYTE = -127;
-  static public final char NC_FILL_CHAR = (char) 0;
-  static public final short NC_FILL_SHORT = (short) -32767;
-  static public final int NC_FILL_INT = -2147483647;
-  static public final long NC_FILL_LONG = -9223372036854775806L;
-  static public final float NC_FILL_FLOAT = 9.9692099683868690e+36f; /* near 15 * 2^119 */
-  static public final double NC_FILL_DOUBLE = 9.9692099683868690e+36;
-  static public final String FillValue = "_FillValue";
-
-  /* CLASSIC
-     The maximum size of a record in the classic format in versions 3.5.1 and earlier is 2^32 - 4 bytes.
-     In versions 3.6.0 and later, there is no such restriction on total record size for the classic format
-     or 64-bit offset format.
-
-     If you don't use the unlimited dimension, only one variable can exceed 2 GiB in size, but it can be as
-       large as the underlying file system permits. It must be the last variable in the dataset, and the offset
-       to the beginning of this variable must be less than about 2 GiB.
-
-     The limit is really 2^31 - 4. If you were to specify a variable size of 2^31 -3, for example, it would be
-       rounded up to the nearest multiple of 4 bytes, which would be 2^31, which is larger than the largest
-       signed integer, 2^31 - 1.
-
-     If you use the unlimited dimension, record variables may exceed 2 GiB in size, as long as the offset of the
-       start of each record variable within a record is less than 2 GiB - 4.
-   */
-
-  /* LARGE FILE
-     Assuming an operating system with Large File Support, the following restrictions apply to the netCDF 64-bit offset format.
-
-     No fixed-size variable can require more than 2^32 - 4 bytes of storage for its data, unless it is the last
-     fixed-size variable and there are no record variables. When there are no record variables, the last
-     fixed-size variable can be any size supported by the file system, e.g. terabytes.
-
-     A 64-bit offset format netCDF file can have up to 2^32 - 1 fixed sized variables, each under 4GiB in size.
-     If there are no record variables in the file the last fixed variable can be any size.
-
-     No record variable can require more than 2^32 - 4 bytes of storage for each record's worth of data,
-     unless it is the last record variable. A 64-bit offset format netCDF file can have up to 2^32 - 1 records,
-     of up to 2^32 - 1 variables, as long as the size of one record's data for each record variable except the
-     last is less than 4 GiB - 4.
-
-     Note also that all netCDF variables and records are padded to 4 byte boundaries.
-   */
-
-  /**
-   * Each fixed-size variable and the data for one record's worth of a single record variable are limited
-   *    to a little less than 4 GiB.
-   */
-  static public final long MAX_VARSIZE = (long) 2 * Integer.MAX_VALUE - 2; // 4,294,967,292
-
-  /**
-   * The maximum number of records is 2^32-1.
-   */
-  static public final int MAX_NUMRECS = Integer.MAX_VALUE;
-
-  static private boolean syncExtendOnly = false;
-
-  /**
-   * Set a static property.
-   * Supported static properties: <ul>
-   * <li> syncExtendOnly = "true" : assume all file changes are syncExtend only.
-   * </ul>
-   *
-   * @param name  property name
-   * @param value property value
-   */
-  static public void setProperty(String name, String value) {
-    if (name.equalsIgnoreCase("syncExtendOnly"))
-      syncExtendOnly = value.equalsIgnoreCase("true");
-  }
-
-/*
- * LOOK do we need to implement this ??
- *
- * Verify that a name string is valid syntax.  The allowed name
- * syntax (in RE form) is:
- *
- * ([a-zA-Z0-9_]|{UTF8})([^\x00-\x1F\x7F/]|{UTF8})*
- *
- * where UTF8 represents a multibyte UTF-8 encoding.  Also, no
- * trailing spaces are permitted in names.  This definition
- * must be consistent with the one in ncgen.l.  We do not allow '/'
- * because HDF5 does not permit slashes in names as slash is used as a
- * group separator.  If UTF-8 is supported, then a multi-byte UTF-8
- * character can occur anywhere within an identifier.  We later
- * normalize UTF-8 strings to NFC to facilitate matching and queries.
- *
-public String NC_check_name(String name) {
-	int skip;
-	int ch;
-	const char *cp = name;
-	ssize_t utf8_stat;
-
-	assert(name != NULL);
-
-	if(*name == 0		// empty names disallowed
-	   || strchr(cp, '/'))	// '/' can't be in a name
-		return NC_EBADNAME;
-
-	/* check validity of any UTF-8
-	utf8_stat = utf8proc_check((const unsigned char *)name);
-	if (utf8_stat < 0)
-	    return NC_EBADNAME;
-
-	/* First char must be [a-z][A-Z][0-9]_ | UTF8
-	ch = (uchar)*cp;
-	if(ch <= 0x7f) {
-	    if(   !('A' <= ch && ch <= 'Z')
-	       && !('a' <= ch && ch <= 'z')
-	       && !('0' <= ch && ch <= '9')
-	       && ch != '_' )
-		return NC_EBADNAME;
-	    cp++;
-	} else {
-	    if((skip = nextUTF8(cp)) < 0)
-		return NC_EBADNAME;
-	    cp += skip;
-	}
-
-	while(*cp != 0) {
-	    ch = (uchar)*cp;
-	    /* handle simple 0x00-0x7f characters here
-	    if(ch <= 0x7f) {
-                if( ch < ' ' || ch > 0x7E) /* control char or DEL
-		  return NC_EBADNAME;
-		cp++;
-	    } else {
-		if((skip = nextUTF8(cp)) < 0) return NC_EBADNAME;
-		cp += skip;
-	    }
-	    if(cp - name > NC_MAX_NAME)
-		return NC_EMAXNAME;
-	}
-	if(ch <= 0x7f && isspace(ch)) // trailing spaces disallowed
-	    return NC_EBADNAME;
-	return NC_NOERR;
-} */
-
-  /**
-   * Convert a name to a legal netcdf-3 name.
-   * ([a-zA-Z0-9_]|{UTF8})([^\x00-\x1F\x7F/]|{UTF8})*
-   * @param name convert this name
-   * @return converted name
-   */
-  static public String makeValidNetcdfObjectName(String name) {
-    StringBuilder sb = new StringBuilder(name.trim()); // remove starting and trailing blanks
-
-    while (sb.length() > 0) {
-      char c = sb.charAt(0);
-      if (Character.isLetter(c) || Character.isDigit(c) || (c == '_')) break;
-      sb.deleteCharAt(0);
-    }
-
-    int pos = 1;
-    while (pos < sb.length()) {
-      int c = sb.codePointAt(pos);
-      if (((c >= 0) && (c < 0x20)) || (c == 0x7f)) {
-        sb.delete(pos, pos + 1);
-        pos--;
-      }
-      pos++;
-    }
-
-    if (sb.length() == 0)
-      throw new IllegalArgumentException("Illegal name");
-    return sb.toString();
-  }
-
-  static public String makeValidNetcdfObjectNameOld(String name) {
-    StringBuilder sb = new StringBuilder(name);
-
-    while (sb.length() > 0) {
-      char c = sb.charAt(0);
-      if (Character.isLetter(c) || (c == '_')) break;
-      if (Character.isDigit(c)) {
-        sb.insert(0, 'N');
-        break;
-      }
-      sb.deleteCharAt(0);
-    }
-
-    int i = 1;
-    while (i < sb.length()) {
-      char c = sb.charAt(i);
-      if (c == ' ')
-        sb.setCharAt(i, '_');
-      else {
-        boolean ok = Character.isLetterOrDigit(c) || (c == '-') || (c == '_');
-        //        || (c == '@') || (c == ':') || (c == '(') || (c == ')') || (c == '+') || (c == '.');
-        if (!ok) {
-          sb.delete(i, i + 1);
-          i--;
-          // sb.setCharAt(i, '-');
-        }
-      }
-      i++;
-    }
-
-    return sb.toString();
-  }
-
-  /////////////////////////////////////////////////
-  // name pattern matching
-  //static private final String special1 = "_\\.@\\+\\-";
-  //static private final String special2 = " ";
-  //static private final Pattern objectNamePattern = Pattern.compile("[a-zA-Z0-9_][a-zA-Z0-9_@\\.\\-\\+]*");
-  static private final Pattern objectNamePattern = Pattern.compile("[a-zA-Z0-9_][a-zA-Z0-9_@\\:\\(\\)\\.\\-\\+]*");
-
-  /**
-   * Determine if the given name can be used for a Dimension, Attribute, or Variable name.
-   * @param name test this.
-   * @return  true if valid name.
-   */
-  static public boolean isValidNetcdf3ObjectName(String name) {
-    Matcher m = objectNamePattern.matcher(name);
-    return m.matches();
-  }
-
-  /**
-   * Valid Netcdf Object name as a regular expression.
-   * @return regular expression pattern describing valid Netcdf Object names.
-   */
-  static public Pattern getValidNetcdf3ObjectNamePattern() {
-    return objectNamePattern;
-  }
-
-  /**
-   * Convert a name to a legal netcdf name.
-   * From the user manual:
-   * "The names of dimensions, variables and attributes consist of arbitrary sequences of
-   * alphanumeric characters (as well as underscore '_' and hyphen '-'), beginning with a letter
-   * or underscore. (However names commencing with underscore are reserved for system use.)
-   * Case is significant in netCDF names."
-   * <p/>
-   * Algorithm:
-   * <ol>
-   * <li>leading character: if alpha or underscore, ok; if digit, prepend "N"; otherwise discard
-   * <li>other characters: if space, change to underscore; other delete.
-   * </ol>
-   * @param name convert this name
-   * @return converted name
-   */
-  static public String createValidNetcdf3ObjectName(String name) {
-    StringBuilder sb = new StringBuilder(name);
-
-    //LOOK: could escape characters, as in DODS (%xx) ??
-
-    while (sb.length() > 0) {
-      char c = sb.charAt(0);
-      if (Character.isLetter(c) || (c == '_')) break;
-      if (Character.isDigit(c)) {
-        sb.insert(0, 'N');
-        break;
-      }
-      sb.deleteCharAt(0);
-    }
-
-    int i = 1;
-    while (i < sb.length()) {
-      char c = sb.charAt(i);
-      if (c == ' ')
-        sb.setCharAt(i, '_');
-      else {
-        boolean ok = Character.isLetterOrDigit(c) || (c == '-') || (c == '_') ||
-                (c == '@') || (c == ':') || (c == '(') || (c == ')') || (c == '+') || (c == '.');
-        if (!ok) {
-          sb.delete(i, i + 1);
-          i--;
-          // sb.setCharAt(i, '-');
-        }
-      }
-      i++;
-    }
-
-    return sb.toString();
-  }
-
-
-  /////////////////////////////////////////////////////////////////////////////////////////////////
-
-  public boolean isValidFile(ucar.unidata.io.RandomAccessFile raf) throws IOException {
-    return N3header.isValidFile(raf);
-  }
-
-  protected ucar.nc2.NetcdfFile ncfile;
-  protected boolean readonly;
-
-  protected N3header header;
-  //protected int numrecs;
-  //protected long recsize;
-  protected long lastModified; // used by sync
-
-  // used for writing only
-  // protected long fileUsed = 0; // how much of the file is written to ?
-  // protected long recStart = 0; // where the record data starts
-
-  protected boolean debug = false, debugSize = false, debugSPIO = false, debugRecord = false, debugSync = false;
-  protected boolean showHeaderBytes = false;
-
-  @Override
-  public String getDetailInfo() {
-    try {
-      Formatter fout = new Formatter();
-      double size = raf.length() / (1000.0 * 1000.0);
-      fout.format(" raf = %s%n", raf.getLocation());
-      fout.format(" size= %d (%s Mb)%n%n", raf.length(), Format.dfrac(size, 3));
-      header.showDetail(fout);
-      return fout.toString();
-      
-    } catch (IOException e) {
-      return e.getMessage();
-    }
-  }
-
-  // properties
-  protected boolean useRecordStructure;
-
-  //////////////////////////////////////////////////////////////////////////////////////
-  // read existing file
-
-  public void open(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile,
-                   ucar.nc2.util.CancelTask cancelTask) throws IOException {
-    this.raf = raf;
-    this.ncfile = ncfile;
-
-    String location = raf.getLocation();
-    if (!location.startsWith("http:")) {
-      File file = new File(location);
-      if (file.exists())
-        lastModified = file.lastModified();
-    }
-
-    // its a netcdf-3 file
-    raf.order(RandomAccessFile.BIG_ENDIAN);
-    header = new N3header();
-
-    header.read(raf, ncfile, null); // read header here
-    //numrecs = header.numrecs;
-    //recsize = header.recsize;
-    //recStart = header.recStart;
-
-    _open(raf);
-
-    ncfile.finish();
-  }
-
-
-  public void setFill(boolean fill) {
-    this.fill = fill;
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-  // data reading
-
-  public Array readData(ucar.nc2.Variable v2, Section section) throws IOException, InvalidRangeException {
-    if (v2 instanceof Structure)
-      return readRecordData((Structure) v2, section);
-
-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-    DataType dataType = v2.getDataType();
-
-    Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
-      new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
-
-    if (layout.getTotalNelems() == 0) {
-      return Array.factory(dataType.getPrimitiveClassType(), section.getShape());
-    }
-
-    Object data = readData(layout, dataType);
-    return Array.factory(dataType.getPrimitiveClassType(), section.getShape(), data);
-  }
-
-  /**
-   * Read data from record structure. For N3, this is the only possible structure, and there can be no nesting.
-   * Read all variables for each record, put in ByteBuffer.
-   *
-   * @param s the record structure
-   * @param section the record range to read
-   * @return an ArrayStructure, with all the data read in.
-   * @throws IOException on error
-   */
-  private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {
-    //if (s.isSubset())
-    //  return readRecordDataSubset(s, section);
-
-    // has to be 1D
-    Range recordRange = section.getRange(0);
-
-    // create the ArrayStructure
-    StructureMembers members = s.makeStructureMembers();
-    for (StructureMembers.Member m : members.getMembers()) {
-      Variable v2 = s.findVariable(m.getName());
-      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-      m.setDataParam((int) (vinfo.begin - header.recStart));
-    }
-
-    // protect agains too large of reads
-    if (header.recsize > Integer.MAX_VALUE)
-      throw new IllegalArgumentException("Cant read records when recsize > "+Integer.MAX_VALUE);
-    long nrecs = section.computeSize();
-    if (nrecs * header.recsize > Integer.MAX_VALUE)
-      throw new IllegalArgumentException("Too large read: nrecs * recsize= "+(nrecs * header.recsize) +"bytes exceeds "+Integer.MAX_VALUE);
-
-    members.setStructureSize((int) header.recsize);
-    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});
-
-    // note dependency on raf; should probably defer to subclass
-    // loop over records
-    byte[] result = structureArray.getByteBuffer().array();
-    int count = 0;
-    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
-      if (debugRecord) System.out.println(" read record " + recnum);
-      raf.seek(header.recStart + recnum * header.recsize); // where the record starts
-
-      if (recnum != header.numrecs - 1)
-        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);
-      else
-        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // "wart" allows file to be one byte short. since its always padding, we allow
-      count++;
-    }
-
-    return structureArray;
-  }
-
-  /**
-   * Read data from record structure, that has been subsetted.
-   * Read one record at at time, put requested variable into ArrayStructureMA.
-   *
-   * @param s the record structure
-   * @param section the record range to read
-   * @return an ArrayStructure, with all the data read in.
-   * @throws IOException on error
-   */
-  private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {
-    Range recordRange = section.getRange(0);
-    int nrecords = recordRange.length();
-
-    // create the ArrayStructureMA
-    StructureMembers members = s.makeStructureMembers();
-    for (StructureMembers.Member m : members.getMembers()) {
-      Variable v2 = s.findVariable(m.getName());
-      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record
-
-      // construct the full shape
-      int rank = m.getShape().length;
-      int[] fullShape = new int[rank + 1];
-      fullShape[0] = nrecords;  // the first dimension
-      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions
-
-      Array data = Array.factory(m.getDataType(), fullShape);
-      m.setDataArray( data);
-      m.setDataObject( data.getIndexIterator());
-    }
-
-    //LOOK this is all wrong - why using recsize ???
-    return null;
-    /* members.setStructureSize(recsize);
-    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});
-
-    // note dependency on raf; should probably defer to subclass
-    // loop over records
-    byte[] record = new byte[ recsize];
-    ByteBuffer bb = ByteBuffer.wrap(record);
-    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
-      if (debugRecord) System.out.println(" readRecordDataSubset recno= " + recnum);
-
-      // read one record
-      raf.seek(recStart + recnum * recsize); // where the record starts
-      if (recnum != numrecs - 1)
-        raf.readFully(record, 0, recsize);
-      else
-        raf.read(record, 0, recsize); // "wart" allows file to be one byte short. since its always padding, we allow
-
-      // transfer desired variable(s) to result array(s)
-      for (StructureMembers.Member m : members.getMembers()) {
-        IndexIterator dataIter = (IndexIterator) m.getDataObject();
-        IospHelper.copyFromByteBuffer(bb, m, dataIter);
-      }
-    }
-
-    return structureArray;  */
-  }
-
-  public ucar.ma2.Array readNestedData(ucar.nc2.Variable v2, Section section) throws java.io.IOException, ucar.ma2.InvalidRangeException {
-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-    DataType dataType = v2.getDataType();
-
-    // construct the full shape for use by RegularIndexer
-    int[] fullShape = new int[v2.getRank() + 1];
-    fullShape[0] = header.numrecs;  // the first dimension
-    System.arraycopy(v2.getShape(), 0, fullShape, 1, v2.getRank()); // the remaining dimensions
-
-    Layout layout = new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, fullShape, section);
-    Object dataObject = readData(layout, dataType);
-    return Array.factory(dataType.getPrimitiveClassType(), section.getShape(), dataObject);
-  }
-
-  public long readToByteChannel(ucar.nc2.Variable v2, Section section, WritableByteChannel channel)
-      throws java.io.IOException, ucar.ma2.InvalidRangeException {
-
-    if (v2 instanceof Structure)
-      return readRecordData((Structure) v2, section, channel);
-
-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-    DataType dataType = v2.getDataType();
-
-    Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
-      new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
-
-    return readData(layout, dataType, channel);
-  }
-
-  private long readRecordData(ucar.nc2.Structure s, Section section, WritableByteChannel out) throws java.io.IOException, InvalidRangeException {
-    long count = 0;
-
-    /* RegularIndexer index = new RegularIndexer( s.getShape(), recsize, recStart, section, recsize);
-    while (index.hasNext()) {
-       Indexer.Chunk chunk = index.next();
-       count += raf.readBytes( out, chunk.getFilePos(), chunk.getNelems() * s.getElementSize());
-     }  */
-
-    // LOOK this is the OTW layout based on netcdf-3
-    // not sure this works but should give an idea of timing
-    Range recordRange = section.getRange(0);
-    int stride = recordRange.stride();
-    if (stride == 1) {
-      int first = recordRange.first();
-      int n = recordRange.length();
-      if (false) System.out.println(" read record " + first+" "+ n * header.recsize+" bytes ");
-      return raf.readToByteChannel(out, header.recStart + first * header.recsize, n * header.recsize);
-
-    }  else {
-      for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
-        if (debugRecord) System.out.println(" read record " + recnum);
-        raf.seek(header.recStart + recnum * header.recsize); // where the record starts
-        count += raf.readToByteChannel(out, header.recStart + recnum * header.recsize, header.recsize);
-      }
-    }
-
-    return count;
-  }
-
-  // convert byte array to char array, assuming UTF-8 encoding
-
-  static protected char[] convertByteToCharUTF(byte[] byteArray) {
-    Charset c = Charset.forName("UTF-8");
-    CharBuffer output = c.decode(ByteBuffer.wrap(byteArray));
-    return output.array();
-  }
-
-  // convert char array to byte array, assuming UTF-8 encoding
-  static protected byte[] convertCharToByteUTF(char[] from) {
-    Charset c = Charset.forName("UTF-8");
-    ByteBuffer output = c.encode(CharBuffer.wrap(from));
-    return output.array();
-  }
-
-  //////////////////////////////////////////////////////////////////////////////////////
-  // create new file
-
-  protected boolean fill = true;
-  protected HashMap dimHash = new HashMap(50);
-
-  public void create(String filename, ucar.nc2.NetcdfFile ncfile, int extra, long preallocateSize, boolean largeFile) throws IOException {
-    this.ncfile = ncfile;
-    this.readonly = false;
-
-    // finish any structures
-    ncfile.finish();
-
-    raf = new ucar.unidata.io.RandomAccessFile(filename, "rw");
-    raf.order(RandomAccessFile.BIG_ENDIAN);
-
-    if (preallocateSize > 0) {
-      java.io.RandomAccessFile myRaf = raf.getRandomAccessFile();
-      myRaf.setLength(preallocateSize);
-    }
-
-    header = new N3header();
-    header.create(raf, ncfile, extra, largeFile, null);
-
-    //recsize = header.recsize;   // record size
-    //recStart = header.recStart; // record variables start here
-    //fileUsed = headerParser.getMinLength(); // track what is actually used
-
-    _create(raf);
-
-    if (fill)
-      fillNonRecordVariables();
-    //else
-    //  raf.setMinLength(recStart); // make sure file length is long enough, even if not written to.
-  }
-
-  public boolean rewriteHeader(boolean largeFile) throws IOException {
-    return header.rewriteHeader(largeFile, null);
-  }
-
-
-  //////////////////////////////////////////////////////////////////////////////////////
-  // write
-
-  public void writeData(Variable v2, Section section, Array values) throws java.io.IOException, InvalidRangeException {
-
-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-    DataType dataType = v2.getDataType();
-
-    if (v2.isUnlimited()) {
-      Range firstRange = section.getRange(0);
-      setNumrecs(firstRange.last() + 1);
-    }
-
-    if (v2 instanceof Structure) {
-      writeRecordData((Structure) v2, section, values);
-
-    } else {
-      Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
-        new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
-      writeData(values, layout, dataType);
-    }
-  }
-
-  private void writeRecordData(ucar.nc2.Structure s, Section section, Array values) throws java.io.IOException, ucar.ma2.InvalidRangeException {
-    if (!(values instanceof ArrayStructure))
-      throw new IllegalArgumentException("writeRecordData: data must be ArrayStructure");
-    ArrayStructure structureData = (ArrayStructure) values;
-
-    List<Variable> vars = s.getVariables();
-    StructureMembers members = structureData.getStructureMembers();
-
-    Range recordRange = section.getRange(0);
-    int count = 0;
-    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
-      // System.out.println("  wrote "+recnum+" begin at "+begin);
-
-      // loop over members
-      for (Variable v2 : vars) {
-        StructureMembers.Member m = members.findMember(v2.getShortName());
-        if (null == m)
-          continue; // this means that the data is missing from the ArrayStructure
-
-        N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
-        long begin = vinfo.begin + recnum * header.recsize;
-        Layout layout = new LayoutRegular(begin, v2.getElementSize(), v2.getShape(), v2.getShapeAsSection());
-
-        // Indexer index =  RegularLayout.factory(begin, v2.getElementSize(), -1, v2.getShape(), v2.getShapeAsSection());
-
-        Array data = structureData.getArray(count, m);
-        writeData(data, layout, v2.getDataType());
-      }
-
-      count++;
-    }
-  }
-
-
-  protected void setNumrecs(int n) throws IOException, InvalidRangeException {
-    if (n <= header.numrecs) return;
-    int startRec = header.numrecs;
-
-    if (debugSize) System.out.println("extend records to = " + n);
-    //fileUsed = recStart + recsize * n;
-    header.setNumrecs(n);
-    //this.numrecs = n;
-
-    // need to let unlimited dimension know of new shape
-    for (Dimension dim : ncfile.getDimensions()) {
-      if (dim.isUnlimited())
-        dim.setLength(n);
-    }
-
-    // need to let all unlimited variables know of new shape
-    for (Variable v : ncfile.getVariables()) {
-      if (v.isUnlimited()) {
-        v.resetShape();
-        v.setCachedData(null, false);
-      }
-    }
-
-    // extend file, handle filling
-    if (fill)
-      fillRecordVariables(startRec, n);
-    else
-      raf.setMinLength( header.calcFileSize());
-  }
-
-  /**
-   * Update the value of an existing attribute. Attribute is found by name, which must match exactly.
-   * You cannot make an attribute longer, or change the number of values.
-   * For strings: truncate if longer, zero fill if shorter.  Strings are padded to 4 byte boundaries, ok to use padding if it exists.
-   * For numerics: must have same number of values.
-   *
-   * @param v2  variable, or null for fglobal attribute
-   * @param att replace with this value
-   * @throws IOException
-   */
-  public void updateAttribute(ucar.nc2.Variable v2, Attribute att) throws IOException {
-    header.updateAttribute(v2, att);
-  }
-
-  /////////////////////////////////////////////////////////////
-
-  // fill buffer with fill value
-
-  protected void fillNonRecordVariables() throws IOException {
-    // run through each variable
-    for (Variable v : ncfile.getVariables()) {
-      if (v.isUnlimited()) continue;
-      try {
-        writeData(v, v.getShapeAsSection(), makeConstantArray(v));
-      } catch (InvalidRangeException e) {
-        e.printStackTrace();  // shouldnt happen
-      }
-    }
-  }
-
-  protected void fillRecordVariables(int recStart, int recEnd) throws IOException, InvalidRangeException {
-    // do each record completely, should be a bit more efficient
-
-    for (int i = recStart; i < recEnd; i++) { // do one record at a time
-      Range r = new Range(i, i);
-
-      // run through each variable
-      for (Variable v : ncfile.getVariables()) {
-        if (!v.isUnlimited() || (v instanceof Structure)) continue;
-        Section recordSection = new Section( v.getRanges());
-        recordSection.setRange(0, r);
-        writeData(v, recordSection, makeConstantArray(v));
-      }
-    }
-  }
-
-  private Array makeConstantArray(Variable v) {
-    Class classType = v.getDataType().getPrimitiveClassType();
-    //int [] shape = v.getShape();
-    Attribute att = v.findAttribute("_FillValue");
-
-    Object storage = null;
-    if (classType == double.class) {
-      double[] storageP = new double[1];
-      storageP[0] = (att == null) ? NC_FILL_DOUBLE : att.getNumericValue().doubleValue();
-      storage = storageP;
-
-    } else if (classType == float.class) {
-      float[] storageP = new float[1];
-      storageP[0] = (att == null) ? NC_FILL_FLOAT : att.getNumericValue().floatValue();
-      storage = storageP;
-
-    } else if (classType == int.class) {
-      int[] storageP = new int[1];
-      storageP[0] = (att == null) ? NC_FILL_INT : att.getNumericValue().intValue();
-      storage = storageP;
-
-    } else if (classType == short.class) {
-      short[] storageP = new short[1];
-      storageP[0] = (att == null) ? NC_FILL_SHORT : att.getNumericValue().shortValue();
-      storage = storageP;
-
-    } else if (classType == byte.class) {
-      byte[] storageP = new byte[1];
-      storageP[0] = (att == null) ? NC_FILL_BYTE : att.getNumericValue().byteValue();
-      storage = storageP;
-
-    } else if (classType == char.class) {
-      char[] storageP = new char[1];
-      storageP[0] = (att != null) && (att.getStringValue().length() > 0) ? att.getStringValue().charAt(0) : NC_FILL_CHAR;
-      storage = storageP;
-    }
-
-    return Array.factoryConstant(classType, v.getShape(), storage);
-  }
-
-  //////////////////////////////////////////////////////////////////////////////////////////////
-  @Override
-  public boolean syncExtend() throws IOException {
-    boolean result = header.synchNumrecs();
-    if (result && log.isDebugEnabled())
-      log.debug(" N3iosp syncExtend " + raf.getLocation() + " numrecs =" + header.numrecs);
-    return result;
-  }
-
-  @Override
-  public boolean sync() throws IOException {
-    if (syncExtendOnly)
-      return syncExtend();
-
-    if (lastModified == 0) // ?? HttpRandomAccessFile
-      return false;
-
-    File file = new File(raf.getLocation());
-    if (file.exists()) {
-      long currentModified = file.lastModified();
-      if (currentModified == lastModified)
-        return false;
-
-      // so things have been modified, heres where we need to reread the header !!
-      ncfile.empty();
-      open(raf, ncfile, null);
-      if (log.isDebugEnabled())
-        log.debug(" N3iosp resynced " + raf.getLocation() + " currentModified=" + currentModified + " lastModified= " + lastModified);
-      return true;
-    }
-
-    // can this happen ?
-    throw new IOException("File does not exist");
-  }
-
-  public void flush() throws java.io.IOException {
-    raf.flush();
-    header.writeNumrecs();
-    raf.flush();
-  }
-
-  public void close() throws java.io.IOException {
-    if (raf != null) {
-      long size = header.calcFileSize();
-      raf.setMinLength( size);
-      raf.close();
-    }
-    raf = null;
-  }
-
-  /**
-   * Debug info for this object.
-   */
-  @Override
-  public String toStringDebug(Object o) {
-    return null;
-  }
-
-  @Override
-  public Object sendIospMessage(Object message) {
-    if (null == header)
-      return null;
-    if (message == NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE)
-      return header.makeRecordStructure();
-    else if (message == NetcdfFile.IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE)
-      return header.removeRecordStructure();
-
-    return super.sendIospMessage(message);
-  }
-
-  public String getFileTypeId() { return "netCDF"; }
-
-  public String getFileTypeDescription()  { return "NetCDF classic format"; }
-
-  ////////////////////////////////////////////////////////////////////////////////////////////////////
-  // stuff we need the subclass to implement
-
-  /**
-   * Read data subset from file for a variable, create primitive array.
-   *
-   * @param index    handles skipping around in the file.
-   * @param dataType dataType of the variable
-   * @return primitive array with data read in
-   * @throws java.io.IOException on error
-   */
-  abstract protected Object readData(Layout index, DataType dataType) throws IOException;
-
-  abstract protected long readData(Layout index, DataType dataType, WritableByteChannel out) throws IOException;
-
-
-  /**
-   * Write data subset to file for a variable, create primitive array.
-   *
-   * @param aa       write data in this Array.
-   * @param index    handles skipping around in the file.
-   * @param dataType dataType of the variable
-   * @throws java.io.IOException on error
-   */
-  abstract protected void writeData(Array aa, Layout index, DataType dataType) throws IOException;
-
-  abstract protected void _open(ucar.unidata.io.RandomAccessFile raf) throws java.io.IOException;
-
-  abstract protected void _create(ucar.unidata.io.RandomAccessFile raf) throws java.io.IOException;
-
-}
+/*
+ * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
+ *
+ * Portions of this software were developed by the Unidata Program at the
+ * University Corporation for Atmospheric Research.
+ *
+ * Access and use of this software shall impose the following obligations
+ * and understandings on the user. The user is granted the right, without
+ * any fee or cost, to use, copy, modify, alter, enhance and distribute
+ * this software, and any derivative works thereof, and its supporting
+ * documentation for any purpose whatsoever, provided that this entire
+ * notice appears in all copies of the software, derivative works and
+ * supporting documentation.  Further, UCAR requests that the user credit
+ * UCAR/Unidata in any publications that result from the use of this
+ * software or in any product that includes this software. The names UCAR
+ * and/or Unidata, however, may not be used in any advertising or publicity
+ * to endorse or promote any products or commercial entity unless specific
+ * written permission is obtained from UCAR/Unidata. The user also
+ * understands that UCAR/Unidata is not obligated to provide the user with
+ * any support, consulting, training or assistance of any kind with regard
+ * to the use, operation and performance of this software nor to provide
+ * the user with any updates, revisions, new versions or "bug fixes."
+ *
+ * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+package ucar.nc2.iosp.netcdf3;
+
+import ucar.ma2.*;
+import ucar.unidata.io.RandomAccessFile;
+import ucar.nc2.*;
+import ucar.nc2.iosp.*;
+import ucar.unidata.util.Format;
+
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+import java.io.*;
+import java.nio.charset.Charset;
+import java.nio.CharBuffer;
+import java.nio.ByteBuffer;
+import java.nio.channels.WritableByteChannel;
+
+/**
+ * IOServiceProvider implementation abstract base class to read/write "version 3" netcdf files.
+ * AKA "file format version 1" files.
+ *
+ * @author caron
+ * @see N3raf concrete class
+ */
+
+public abstract class N3iosp extends AbstractIOServiceProvider implements IOServiceProviderWriter {
+  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(N3iosp.class);
+
+  // Default fill values, used unless _FillValue variable attribute is set.
+  static public final byte NC_FILL_BYTE = -127;
+  static public final char NC_FILL_CHAR = (char) 0;
+  static public final short NC_FILL_SHORT = (short) -32767;
+  static public final int NC_FILL_INT = -2147483647;
+  static public final long NC_FILL_LONG = -9223372036854775806L;
+  static public final float NC_FILL_FLOAT = 9.9692099683868690e+36f; /* near 15 * 2^119 */
+  static public final double NC_FILL_DOUBLE = 9.9692099683868690e+36;
+  static public final String FillValue = "_FillValue";
+
+  /* CLASSIC
+     The maximum size of a record in the classic format in versions 3.5.1 and earlier is 2^32 - 4 bytes.
+     In versions 3.6.0 and later, there is no such restriction on total record size for the classic format
+     or 64-bit offset format.
+
+     If you don't use the unlimited dimension, only one variable can exceed 2 GiB in size, but it can be as
+       large as the underlying file system permits. It must be the last variable in the dataset, and the offset
+       to the beginning of this variable must be less than about 2 GiB.
+
+     The limit is really 2^31 - 4. If you were to specify a variable size of 2^31 -3, for example, it would be
+       rounded up to the nearest multiple of 4 bytes, which would be 2^31, which is larger than the largest
+       signed integer, 2^31 - 1.
+
+     If you use the unlimited dimension, record variables may exceed 2 GiB in size, as long as the offset of the
+       start of each record variable within a record is less than 2 GiB - 4.
+   */
+
+  /* LARGE FILE
+     Assuming an operating system with Large File Support, the following restrictions apply to the netCDF 64-bit offset format.
+
+     No fixed-size variable can require more than 2^32 - 4 bytes of storage for its data, unless it is the last
+     fixed-size variable and there are no record variables. When there are no record variables, the last
+     fixed-size variable can be any size supported by the file system, e.g. terabytes.
+
+     A 64-bit offset format netCDF file can have up to 2^32 - 1 fixed sized variables, each under 4GiB in size.
+     If there are no record variables in the file the last fixed variable can be any size.
+
+     No record variable can require more than 2^32 - 4 bytes of storage for each record's worth of data,
+     unless it is the last record variable. A 64-bit offset format netCDF file can have up to 2^32 - 1 records,
+     of up to 2^32 - 1 variables, as long as the size of one record's data for each record variable except the
+     last is less than 4 GiB - 4.
+
+     Note also that all netCDF variables and records are padded to 4 byte boundaries.
+   */
+
+  /**
+   * Each fixed-size variable and the data for one record's worth of a single record variable are limited
+   *    to a little less than 4 GiB.
+   */
+  static public final long MAX_VARSIZE = (long) 2 * Integer.MAX_VALUE - 2; // 4,294,967,292
+
+  /**
+   * The maximum number of records is 2^32-1.
+   */
+  static public final int MAX_NUMRECS = Integer.MAX_VALUE;
+
+  static private boolean syncExtendOnly = false;
+
+  /**
+   * Set a static property.
+   * Supported static properties: <ul>
+   * <li> syncExtendOnly = "true" : assume all file changes are syncExtend only.
+   * </ul>
+   *
+   * @param name  property name
+   * @param value property value
+   */
+  static public void setProperty(String name, String value) {
+    if (name.equalsIgnoreCase("syncExtendOnly"))
+      syncExtendOnly = value.equalsIgnoreCase("true");
+  }
+
+/*
+ * LOOK do we need to implement this ??
+ *
+ * Verify that a name string is valid syntax.  The allowed name
+ * syntax (in RE form) is:
+ *
+ * ([a-zA-Z0-9_]|{UTF8})([^\x00-\x1F\x7F/]|{UTF8})*
+ *
+ * where UTF8 represents a multibyte UTF-8 encoding.  Also, no
+ * trailing spaces are permitted in names.  This definition
+ * must be consistent with the one in ncgen.l.  We do not allow '/'
+ * because HDF5 does not permit slashes in names as slash is used as a
+ * group separator.  If UTF-8 is supported, then a multi-byte UTF-8
+ * character can occur anywhere within an identifier.  We later
+ * normalize UTF-8 strings to NFC to facilitate matching and queries.
+ *
+public String NC_check_name(String name) {
+	int skip;
+	int ch;
+	const char *cp = name;
+	ssize_t utf8_stat;
+
+	assert(name != NULL);
+
+	if(*name == 0		// empty names disallowed
+	   || strchr(cp, '/'))	// '/' can't be in a name
+		return NC_EBADNAME;
+
+	/* check validity of any UTF-8
+	utf8_stat = utf8proc_check((const unsigned char *)name);
+	if (utf8_stat < 0)
+	    return NC_EBADNAME;
+
+	/* First char must be [a-z][A-Z][0-9]_ | UTF8
+	ch = (uchar)*cp;
+	if(ch <= 0x7f) {
+	    if(   !('A' <= ch && ch <= 'Z')
+	       && !('a' <= ch && ch <= 'z')
+	       && !('0' <= ch && ch <= '9')
+	       && ch != '_' )
+		return NC_EBADNAME;
+	    cp++;
+	} else {
+	    if((skip = nextUTF8(cp)) < 0)
+		return NC_EBADNAME;
+	    cp += skip;
+	}
+
+	while(*cp != 0) {
+	    ch = (uchar)*cp;
+	    /* handle simple 0x00-0x7f characters here
+	    if(ch <= 0x7f) {
+                if( ch < ' ' || ch > 0x7E) /* control char or DEL
+		  return NC_EBADNAME;
+		cp++;
+	    } else {
+		if((skip = nextUTF8(cp)) < 0) return NC_EBADNAME;
+		cp += skip;
+	    }
+	    if(cp - name > NC_MAX_NAME)
+		return NC_EMAXNAME;
+	}
+	if(ch <= 0x7f && isspace(ch)) // trailing spaces disallowed
+	    return NC_EBADNAME;
+	return NC_NOERR;
+} */
+
+  /**
+   * Convert a name to a legal netcdf-3 name.
+   * ([a-zA-Z0-9_]|{UTF8})([^\x00-\x1F\x7F/]|{UTF8})*
+   * @param name convert this name
+   * @return converted name
+   */
+  static public String makeValidNetcdfObjectName(String name) {
+    StringBuilder sb = new StringBuilder(name.trim()); // remove starting and trailing blanks
+
+    while (sb.length() > 0) {
+      char c = sb.charAt(0);
+      if (Character.isLetter(c) || Character.isDigit(c) || (c == '_')) break;
+      sb.deleteCharAt(0);
+    }
+
+    int pos = 1;
+    while (pos < sb.length()) {
+      int c = sb.codePointAt(pos);
+      if (((c >= 0) && (c < 0x20)) || (c == 0x7f)) {
+        sb.delete(pos, pos + 1);
+        pos--;
+      }
+      pos++;
+    }
+
+    if (sb.length() == 0)
+      throw new IllegalArgumentException("Illegal name");
+    return sb.toString();
+  }
+
+  static public String makeValidNetcdfObjectNameOld(String name) {
+    StringBuilder sb = new StringBuilder(name);
+
+    while (sb.length() > 0) {
+      char c = sb.charAt(0);
+      if (Character.isLetter(c) || (c == '_')) break;
+      if (Character.isDigit(c)) {
+        sb.insert(0, 'N');
+        break;
+      }
+      sb.deleteCharAt(0);
+    }
+
+    int i = 1;
+    while (i < sb.length()) {
+      char c = sb.charAt(i);
+      if (c == ' ')
+        sb.setCharAt(i, '_');
+      else {
+        boolean ok = Character.isLetterOrDigit(c) || (c == '-') || (c == '_');
+        //        || (c == '@') || (c == ':') || (c == '(') || (c == ')') || (c == '+') || (c == '.');
+        if (!ok) {
+          sb.delete(i, i + 1);
+          i--;
+          // sb.setCharAt(i, '-');
+        }
+      }
+      i++;
+    }
+
+    return sb.toString();
+  }
+
+  /////////////////////////////////////////////////
+  // name pattern matching
+  //static private final String special1 = "_\\.@\\+\\-";
+  //static private final String special2 = " ";
+  //static private final Pattern objectNamePattern = Pattern.compile("[a-zA-Z0-9_][a-zA-Z0-9_@\\.\\-\\+]*");
+  static private final Pattern objectNamePattern = Pattern.compile("[a-zA-Z0-9_][a-zA-Z0-9_@\\:\\(\\)\\.\\-\\+]*");
+
+  /**
+   * Determine if the given name can be used for a Dimension, Attribute, or Variable name.
+   * @param name test this.
+   * @return  true if valid name.
+   */
+  static public boolean isValidNetcdf3ObjectName(String name) {
+    Matcher m = objectNamePattern.matcher(name);
+    return m.matches();
+  }
+
+  /**
+   * Valid Netcdf Object name as a regular expression.
+   * @return regular expression pattern describing valid Netcdf Object names.
+   */
+  static public Pattern getValidNetcdf3ObjectNamePattern() {
+    return objectNamePattern;
+  }
+
+  /**
+   * Convert a name to a legal netcdf name.
+   * From the user manual:
+   * "The names of dimensions, variables and attributes consist of arbitrary sequences of
+   * alphanumeric characters (as well as underscore '_' and hyphen '-'), beginning with a letter
+   * or underscore. (However names commencing with underscore are reserved for system use.)
+   * Case is significant in netCDF names."
+   * <p/>
+   * Algorithm:
+   * <ol>
+   * <li>leading character: if alpha or underscore, ok; if digit, prepend "N"; otherwise discard
+   * <li>other characters: if space, change to underscore; other delete.
+   * </ol>
+   * @param name convert this name
+   * @return converted name
+   */
+  static public String createValidNetcdf3ObjectName(String name) {
+    StringBuilder sb = new StringBuilder(name);
+
+    //LOOK: could escape characters, as in DODS (%xx) ??
+
+    while (sb.length() > 0) {
+      char c = sb.charAt(0);
+      if (Character.isLetter(c) || (c == '_')) break;
+      if (Character.isDigit(c)) {
+        sb.insert(0, 'N');
+        break;
+      }
+      sb.deleteCharAt(0);
+    }
+
+    int i = 1;
+    while (i < sb.length()) {
+      char c = sb.charAt(i);
+      if (c == ' ')
+        sb.setCharAt(i, '_');
+      else {
+        boolean ok = Character.isLetterOrDigit(c) || (c == '-') || (c == '_') ||
+                (c == '@') || (c == ':') || (c == '(') || (c == ')') || (c == '+') || (c == '.');
+        if (!ok) {
+          sb.delete(i, i + 1);
+          i--;
+          // sb.setCharAt(i, '-');
+        }
+      }
+      i++;
+    }
+
+    return sb.toString();
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////////////////////////////
+
+  public boolean isValidFile(ucar.unidata.io.RandomAccessFile raf) throws IOException {
+    return N3header.isValidFile(raf);
+  }
+
+  protected ucar.nc2.NetcdfFile ncfile;
+  protected boolean readonly;
+
+  protected N3header header;
+  //protected int numrecs;
+  //protected long recsize;
+  protected long lastModified; // used by sync
+
+  // used for writing only
+  // protected long fileUsed = 0; // how much of the file is written to ?
+  // protected long recStart = 0; // where the record data starts
+
+  protected boolean debug = false, debugSize = false, debugSPIO = false, debugRecord = false, debugSync = false;
+  protected boolean showHeaderBytes = false;
+
+  @Override
+  public String getDetailInfo() {
+    try {
+      Formatter fout = new Formatter();
+      double size = raf.length() / (1000.0 * 1000.0);
+      fout.format(" raf = %s%n", raf.getLocation());
+      fout.format(" size= %d (%s Mb)%n%n", raf.length(), Format.dfrac(size, 3));
+      header.showDetail(fout);
+      return fout.toString();
+      
+    } catch (IOException e) {
+      return e.getMessage();
+    }
+  }
+
+  // properties
+  protected boolean useRecordStructure;
+
+  //////////////////////////////////////////////////////////////////////////////////////
+  // read existing file
+
+  public void open(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile,
+                   ucar.nc2.util.CancelTask cancelTask) throws IOException {
+    this.raf = raf;
+    this.ncfile = ncfile;
+
+    String location = raf.getLocation();
+    if (!location.startsWith("http:")) {
+      File file = new File(location);
+      if (file.exists())
+        lastModified = file.lastModified();
+    }
+
+    // its a netcdf-3 file
+    raf.order(RandomAccessFile.BIG_ENDIAN);
+    header = new N3header();
+
+    header.read(raf, ncfile, null); // read header here
+    //numrecs = header.numrecs;
+    //recsize = header.recsize;
+    //recStart = header.recStart;
+
+    _open(raf);
+
+    ncfile.finish();
+  }
+
+
+  public void setFill(boolean fill) {
+    this.fill = fill;
+  }
+
+  /**
+   * query to see if this IOSP supports the getLocalityInformation() function
+   *
+   * @return a boolean indicating that this IOSP supports the getLocalityInformation() call
+   */
+  public boolean supportsLocalityInformation() { 
+    return true;
+  }
+
+  /**
+   * Returns an ArrayLong with each entry corresponding to the offset in the filestream
+   * of the same data cell in the section arguement to the function
+   *
+   * @param v2 the variable to get the data from
+   * @param section the record range to read
+   * @return an ArrayLong object that's the shape as the section arguement
+   * @throws InvalidRangeException on error
+   * @throws IOException on error
+   */
+  public ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section)
+         throws InvalidRangeException, IOException {
+
+    // An array to hold the offsets that will be returned
+    ArrayLong array = new ArrayLong(section.getShape());
+
+    // Index into the results array
+    Index aIndex = array.getIndex();
+
+    // dataSize is used to increment the offsets within a given
+    // chunk appropriately
+    DataType type = v2.getDataType();
+    int dataSize = type.getSize();
+
+    Layout layout = getLayout(v2, section);
+
+    // iterate over all the chunks in the calculated Layout
+    while( layout.hasNext() ){
+      Layout.Chunk chunk = layout.next();
+
+      // iterate over the elements in this chunk
+      for( int i = 0; i < chunk.getNelems(); i++){
+        // write the offset into the results array, then iterate the index
+        array.setLong(aIndex, chunk.getSrcPos() + (i * dataSize));
+        aIndex.incr();
+      }
+    }
+
+    return array;
+  }
+
+  /**
+   * Returns a Layout object for use by an N3iosp object
+   *
+   * @param v2 the variable to get the layout information for
+   * @param section the record range to read
+   * @return a Layout corresponding to the Section requested
+   * @throws IOException on error
+   */
+  private Layout getLayout(Variable v2, Section section) throws InvalidRangeException {
+    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+
+    Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) 
+      : new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
+
+    return layout;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+  /////////////////////////////////////////////////////////////////////////////
+  // data reading
+
+  public Array readData(ucar.nc2.Variable v2, Section section) throws IOException, InvalidRangeException {
+    if (v2 instanceof Structure)
+      return readRecordData((Structure) v2, section);
+
+    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+    DataType dataType = v2.getDataType();
+    Layout layout = getLayout(v2, section);
+
+    if (layout.getTotalNelems() == 0) {
+      return Array.factory(dataType.getPrimitiveClassType(), section.getShape());
+    }
+
+    Object data = readData(layout, dataType);
+    return Array.factory(dataType.getPrimitiveClassType(), section.getShape(), data);
+  }
+
+  /**
+   * Read data from record structure. For N3, this is the only possible structure, and there can be no nesting.
+   * Read all variables for each record, put in ByteBuffer.
+   *
+   * @param s the record structure
+   * @param section the record range to read
+   * @return an ArrayStructure, with all the data read in.
+   * @throws IOException on error
+   */
+  private ucar.ma2.Array readRecordData(ucar.nc2.Structure s, Section section) throws java.io.IOException {
+    //if (s.isSubset())
+    //  return readRecordDataSubset(s, section);
+
+    // has to be 1D
+    Range recordRange = section.getRange(0);
+
+    // create the ArrayStructure
+    StructureMembers members = s.makeStructureMembers();
+    for (StructureMembers.Member m : members.getMembers()) {
+      Variable v2 = s.findVariable(m.getName());
+      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+      m.setDataParam((int) (vinfo.begin - header.recStart));
+    }
+
+    // protect agains too large of reads
+    if (header.recsize > Integer.MAX_VALUE)
+      throw new IllegalArgumentException("Cant read records when recsize > "+Integer.MAX_VALUE);
+    long nrecs = section.computeSize();
+    if (nrecs * header.recsize > Integer.MAX_VALUE)
+      throw new IllegalArgumentException("Too large read: nrecs * recsize= "+(nrecs * header.recsize) +"bytes exceeds "+Integer.MAX_VALUE);
+
+    members.setStructureSize((int) header.recsize);
+    ArrayStructureBB structureArray = new ArrayStructureBB(members, new int[]{recordRange.length()});
+
+    // note dependency on raf; should probably defer to subclass
+    // loop over records
+    byte[] result = structureArray.getByteBuffer().array();
+    int count = 0;
+    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
+      if (debugRecord) System.out.println(" read record " + recnum);
+      raf.seek(header.recStart + recnum * header.recsize); // where the record starts
+
+      if (recnum != header.numrecs - 1)
+        raf.readFully(result, (int) (count * header.recsize), (int) header.recsize);
+      else
+        raf.read(result, (int) (count * header.recsize), (int) header.recsize); // "wart" allows file to be one byte short. since its always padding, we allow
+      count++;
+    }
+
+    return structureArray;
+  }
+
+  /**
+   * Read data from record structure, that has been subsetted.
+   * Read one record at at time, put requested variable into ArrayStructureMA.
+   *
+   * @param s the record structure
+   * @param section the record range to read
+   * @return an ArrayStructure, with all the data read in.
+   * @throws IOException on error
+   */
+  private ucar.ma2.Array readRecordDataSubset(ucar.nc2.Structure s, Section section) throws java.io.IOException {
+    Range recordRange = section.getRange(0);
+    int nrecords = recordRange.length();
+
+    // create the ArrayStructureMA
+    StructureMembers members = s.makeStructureMembers();
+    for (StructureMembers.Member m : members.getMembers()) {
+      Variable v2 = s.findVariable(m.getName());
+      N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+      m.setDataParam((int) (vinfo.begin - header.recStart)); // offset from start of record
+
+      // construct the full shape
+      int rank = m.getShape().length;
+      int[] fullShape = new int[rank + 1];
+      fullShape[0] = nrecords;  // the first dimension
+      System.arraycopy(m.getShape(), 0, fullShape, 1, rank); // the remaining dimensions
+
+      Array data = Array.factory(m.getDataType(), fullShape);
+      m.setDataArray( data);
+      m.setDataObject( data.getIndexIterator());
+    }
+
+    //LOOK this is all wrong - why using recsize ???
+    return null;
+    /* members.setStructureSize(recsize);
+    ArrayStructureMA structureArray = new ArrayStructureMA(members, new int[]{nrecords});
+
+    // note dependency on raf; should probably defer to subclass
+    // loop over records
+    byte[] record = new byte[ recsize];
+    ByteBuffer bb = ByteBuffer.wrap(record);
+    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
+      if (debugRecord) System.out.println(" readRecordDataSubset recno= " + recnum);
+
+      // read one record
+      raf.seek(recStart + recnum * recsize); // where the record starts
+      if (recnum != numrecs - 1)
+        raf.readFully(record, 0, recsize);
+      else
+        raf.read(record, 0, recsize); // "wart" allows file to be one byte short. since its always padding, we allow
+
+      // transfer desired variable(s) to result array(s)
+      for (StructureMembers.Member m : members.getMembers()) {
+        IndexIterator dataIter = (IndexIterator) m.getDataObject();
+        IospHelper.copyFromByteBuffer(bb, m, dataIter);
+      }
+    }
+
+    return structureArray;  */
+  }
+
+  public ucar.ma2.Array readNestedData(ucar.nc2.Variable v2, Section section) throws java.io.IOException, ucar.ma2.InvalidRangeException {
+    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+    DataType dataType = v2.getDataType();
+
+    // construct the full shape for use by RegularIndexer
+    int[] fullShape = new int[v2.getRank() + 1];
+    fullShape[0] = header.numrecs;  // the first dimension
+    System.arraycopy(v2.getShape(), 0, fullShape, 1, v2.getRank()); // the remaining dimensions
+
+    Layout layout = new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, fullShape, section);
+    Object dataObject = readData(layout, dataType);
+    return Array.factory(dataType.getPrimitiveClassType(), section.getShape(), dataObject);
+  }
+
+  public long readToByteChannel(ucar.nc2.Variable v2, Section section, WritableByteChannel channel)
+      throws java.io.IOException, ucar.ma2.InvalidRangeException {
+
+    if (v2 instanceof Structure)
+      return readRecordData((Structure) v2, section, channel);
+
+    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+    DataType dataType = v2.getDataType();
+    Layout layout = getLayout(v2, section);
+
+    return readData(layout, dataType, channel);
+  }
+
+  private long readRecordData(ucar.nc2.Structure s, Section section, WritableByteChannel out) throws java.io.IOException, InvalidRangeException {
+    long count = 0;
+
+    /* RegularIndexer index = new RegularIndexer( s.getShape(), recsize, recStart, section, recsize);
+    while (index.hasNext()) {
+       Indexer.Chunk chunk = index.next();
+       count += raf.readBytes( out, chunk.getFilePos(), chunk.getNelems() * s.getElementSize());
+     }  */
+
+    // LOOK this is the OTW layout based on netcdf-3
+    // not sure this works but should give an idea of timing
+    Range recordRange = section.getRange(0);
+    int stride = recordRange.stride();
+    if (stride == 1) {
+      int first = recordRange.first();
+      int n = recordRange.length();
+      if (false) System.out.println(" read record " + first+" "+ n * header.recsize+" bytes ");
+      return raf.readToByteChannel(out, header.recStart + first * header.recsize, n * header.recsize);
+
+    }  else {
+      for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
+        if (debugRecord) System.out.println(" read record " + recnum);
+        raf.seek(header.recStart + recnum * header.recsize); // where the record starts
+        count += raf.readToByteChannel(out, header.recStart + recnum * header.recsize, header.recsize);
+      }
+    }
+
+    return count;
+  }
+
+  // convert byte array to char array, assuming UTF-8 encoding
+
+  static protected char[] convertByteToCharUTF(byte[] byteArray) {
+    Charset c = Charset.forName("UTF-8");
+    CharBuffer output = c.decode(ByteBuffer.wrap(byteArray));
+    return output.array();
+  }
+
+  // convert char array to byte array, assuming UTF-8 encoding
+  static protected byte[] convertCharToByteUTF(char[] from) {
+    Charset c = Charset.forName("UTF-8");
+    ByteBuffer output = c.encode(CharBuffer.wrap(from));
+    return output.array();
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////
+  // create new file
+
+  protected boolean fill = true;
+  protected HashMap dimHash = new HashMap(50);
+
+  public void create(String filename, ucar.nc2.NetcdfFile ncfile, int extra, long preallocateSize, boolean largeFile) throws IOException {
+    this.ncfile = ncfile;
+    this.readonly = false;
+
+    // finish any structures
+    ncfile.finish();
+
+    raf = new ucar.unidata.io.RandomAccessFile(filename, "rw");
+    raf.order(RandomAccessFile.BIG_ENDIAN);
+
+    if (preallocateSize > 0) {
+      java.io.RandomAccessFile myRaf = raf.getRandomAccessFile();
+      myRaf.setLength(preallocateSize);
+    }
+
+    header = new N3header();
+    header.create(raf, ncfile, extra, largeFile, null);
+
+    //recsize = header.recsize;   // record size
+    //recStart = header.recStart; // record variables start here
+    //fileUsed = headerParser.getMinLength(); // track what is actually used
+
+    _create(raf);
+
+    if (fill)
+      fillNonRecordVariables();
+    //else
+    //  raf.setMinLength(recStart); // make sure file length is long enough, even if not written to.
+  }
+
+  public boolean rewriteHeader(boolean largeFile) throws IOException {
+    return header.rewriteHeader(largeFile, null);
+  }
+
+
+  //////////////////////////////////////////////////////////////////////////////////////
+  // write
+
+  public void writeData(Variable v2, Section section, Array values) throws java.io.IOException, InvalidRangeException {
+
+    DataType dataType = v2.getDataType();
+
+    if (v2.isUnlimited()) {
+      Range firstRange = section.getRange(0);
+      setNumrecs(firstRange.last() + 1);
+    }
+
+    if (v2 instanceof Structure) {
+      writeRecordData((Structure) v2, section, values);
+
+    } else {
+      Layout layout = getLayout(v2, section);
+      writeData(values, layout, dataType);
+    }
+  }
+
+  private void writeRecordData(ucar.nc2.Structure s, Section section, Array values) throws java.io.IOException, ucar.ma2.InvalidRangeException {
+    if (!(values instanceof ArrayStructure))
+      throw new IllegalArgumentException("writeRecordData: data must be ArrayStructure");
+    ArrayStructure structureData = (ArrayStructure) values;
+
+    List<Variable> vars = s.getVariables();
+    StructureMembers members = structureData.getStructureMembers();
+
+    Range recordRange = section.getRange(0);
+    int count = 0;
+    for (int recnum = recordRange.first(); recnum <= recordRange.last(); recnum += recordRange.stride()) {
+      // System.out.println("  wrote "+recnum+" begin at "+begin);
+
+      // loop over members
+      for (Variable v2 : vars) {
+        StructureMembers.Member m = members.findMember(v2.getShortName());
+        if (null == m)
+          continue; // this means that the data is missing from the ArrayStructure
+
+        N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+        long begin = vinfo.begin + recnum * header.recsize;
+        Layout layout = new LayoutRegular(begin, v2.getElementSize(), v2.getShape(), v2.getShapeAsSection());
+
+        // Indexer index =  RegularLayout.factory(begin, v2.getElementSize(), -1, v2.getShape(), v2.getShapeAsSection());
+
+        Array data = structureData.getArray(count, m);
+        writeData(data, layout, v2.getDataType());
+      }
+
+      count++;
+    }
+  }
+
+
+  protected void setNumrecs(int n) throws IOException, InvalidRangeException {
+    if (n <= header.numrecs) return;
+    int startRec = header.numrecs;
+
+    if (debugSize) System.out.println("extend records to = " + n);
+    //fileUsed = recStart + recsize * n;
+    header.setNumrecs(n);
+    //this.numrecs = n;
+
+    // need to let unlimited dimension know of new shape
+    for (Dimension dim : ncfile.getDimensions()) {
+      if (dim.isUnlimited())
+        dim.setLength(n);
+    }
+
+    // need to let all unlimited variables know of new shape
+    for (Variable v : ncfile.getVariables()) {
+      if (v.isUnlimited()) {
+        v.resetShape();
+        v.setCachedData(null, false);
+      }
+    }
+
+    // extend file, handle filling
+    if (fill)
+      fillRecordVariables(startRec, n);
+    else
+      raf.setMinLength( header.calcFileSize());
+  }
+
+  /**
+   * Update the value of an existing attribute. Attribute is found by name, which must match exactly.
+   * You cannot make an attribute longer, or change the number of values.
+   * For strings: truncate if longer, zero fill if shorter.  Strings are padded to 4 byte boundaries, ok to use padding if it exists.
+   * For numerics: must have same number of values.
+   *
+   * @param v2  variable, or null for fglobal attribute
+   * @param att replace with this value
+   * @throws IOException
+   */
+  public void updateAttribute(ucar.nc2.Variable v2, Attribute att) throws IOException {
+    header.updateAttribute(v2, att);
+  }
+
+  /////////////////////////////////////////////////////////////
+
+  // fill buffer with fill value
+
+  protected void fillNonRecordVariables() throws IOException {
+    // run through each variable
+    for (Variable v : ncfile.getVariables()) {
+      if (v.isUnlimited()) continue;
+      try {
+        writeData(v, v.getShapeAsSection(), makeConstantArray(v));
+      } catch (InvalidRangeException e) {
+        e.printStackTrace();  // shouldnt happen
+      }
+    }
+  }
+
+  protected void fillRecordVariables(int recStart, int recEnd) throws IOException, InvalidRangeException {
+    // do each record completely, should be a bit more efficient
+
+    for (int i = recStart; i < recEnd; i++) { // do one record at a time
+      Range r = new Range(i, i);
+
+      // run through each variable
+      for (Variable v : ncfile.getVariables()) {
+        if (!v.isUnlimited() || (v instanceof Structure)) continue;
+        Section recordSection = new Section( v.getRanges());
+        recordSection.setRange(0, r);
+        writeData(v, recordSection, makeConstantArray(v));
+      }
+    }
+  }
+
+  private Array makeConstantArray(Variable v) {
+    Class classType = v.getDataType().getPrimitiveClassType();
+    //int [] shape = v.getShape();
+    Attribute att = v.findAttribute("_FillValue");
+
+    Object storage = null;
+    if (classType == double.class) {
+      double[] storageP = new double[1];
+      storageP[0] = (att == null) ? NC_FILL_DOUBLE : att.getNumericValue().doubleValue();
+      storage = storageP;
+
+    } else if (classType == float.class) {
+      float[] storageP = new float[1];
+      storageP[0] = (att == null) ? NC_FILL_FLOAT : att.getNumericValue().floatValue();
+      storage = storageP;
+
+    } else if (classType == int.class) {
+      int[] storageP = new int[1];
+      storageP[0] = (att == null) ? NC_FILL_INT : att.getNumericValue().intValue();
+      storage = storageP;
+
+    } else if (classType == short.class) {
+      short[] storageP = new short[1];
+      storageP[0] = (att == null) ? NC_FILL_SHORT : att.getNumericValue().shortValue();
+      storage = storageP;
+
+    } else if (classType == byte.class) {
+      byte[] storageP = new byte[1];
+      storageP[0] = (att == null) ? NC_FILL_BYTE : att.getNumericValue().byteValue();
+      storage = storageP;
+
+    } else if (classType == char.class) {
+      char[] storageP = new char[1];
+      storageP[0] = (att != null) && (att.getStringValue().length() > 0) ? att.getStringValue().charAt(0) : NC_FILL_CHAR;
+      storage = storageP;
+    }
+
+    return Array.factoryConstant(classType, v.getShape(), storage);
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////////////
+  @Override
+  public boolean syncExtend() throws IOException {
+    boolean result = header.synchNumrecs();
+    if (result && log.isDebugEnabled())
+      log.debug(" N3iosp syncExtend " + raf.getLocation() + " numrecs =" + header.numrecs);
+    return result;
+  }
+
+  @Override
+  public boolean sync() throws IOException {
+    if (syncExtendOnly)
+      return syncExtend();
+
+    if (lastModified == 0) // ?? HttpRandomAccessFile
+      return false;
+
+    File file = new File(raf.getLocation());
+    if (file.exists()) {
+      long currentModified = file.lastModified();
+      if (currentModified == lastModified)
+        return false;
+
+      // so things have been modified, heres where we need to reread the header !!
+      ncfile.empty();
+      open(raf, ncfile, null);
+      if (log.isDebugEnabled())
+        log.debug(" N3iosp resynced " + raf.getLocation() + " currentModified=" + currentModified + " lastModified= " + lastModified);
+      return true;
+    }
+
+    // can this happen ?
+    throw new IOException("File does not exist");
+  }
+
+  public void flush() throws java.io.IOException {
+    raf.flush();
+    header.writeNumrecs();
+    raf.flush();
+  }
+
+  public void close() throws java.io.IOException {
+    if (raf != null) {
+      long size = header.calcFileSize();
+      raf.setMinLength( size);
+      raf.close();
+    }
+    raf = null;
+  }
+
+  /**
+   * Debug info for this object.
+   */
+  @Override
+  public String toStringDebug(Object o) {
+    return null;
+  }
+
+  @Override
+  public Object sendIospMessage(Object message) {
+    if (null == header)
+      return null;
+    if (message == NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE)
+      return header.makeRecordStructure();
+    else if (message == NetcdfFile.IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE)
+      return header.removeRecordStructure();
+
+    return super.sendIospMessage(message);
+  }
+
+  public String getFileTypeId() { return "netCDF"; }
+
+  public String getFileTypeDescription()  { return "NetCDF classic format"; }
+
+  ////////////////////////////////////////////////////////////////////////////////////////////////////
+  // stuff we need the subclass to implement
+
+  /**
+   * Read data subset from file for a variable, create primitive array.
+   *
+   * @param index    handles skipping around in the file.
+   * @param dataType dataType of the variable
+   * @return primitive array with data read in
+   * @throws java.io.IOException on error
+   */
+  abstract protected Object readData(Layout index, DataType dataType) throws IOException;
+
+  abstract protected long readData(Layout index, DataType dataType, WritableByteChannel out) throws IOException;
+
+
+  /**
+   * Write data subset to file for a variable, create primitive array.
+   *
+   * @param aa       write data in this Array.
+   * @param index    handles skipping around in the file.
+   * @param dataType dataType of the variable
+   * @throws java.io.IOException on error
+   */
+  abstract protected void writeData(Array aa, Layout index, DataType dataType) throws IOException;
+
+  abstract protected void _open(ucar.unidata.io.RandomAccessFile raf) throws java.io.IOException;
+
+  abstract protected void _create(ucar.unidata.io.RandomAccessFile raf) throws java.io.IOException;
+
+}
diff -r -U4 ./cdm/src/main/java/ucar/nc2/NetcdfFile.java ../fake_netcdf/cdm/src/main/java/ucar/nc2/NetcdfFile.java
--- ./cdm/src/main/java/ucar/nc2/NetcdfFile.java	2011-07-27 11:12:34.000000000 -0700
+++ ../fake_netcdf/cdm/src/main/java/ucar/nc2/NetcdfFile.java	2011-11-03 21:57:05.694436833 -0700
@@ -1,2151 +1,2179 @@
-/*
- * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
- *
- * Portions of this software were developed by the Unidata Program at the
- * University Corporation for Atmospheric Research.
- *
- * Access and use of this software shall impose the following obligations
- * and understandings on the user. The user is granted the right, without
- * any fee or cost, to use, copy, modify, alter, enhance and distribute
- * this software, and any derivative works thereof, and its supporting
- * documentation for any purpose whatsoever, provided that this entire
- * notice appears in all copies of the software, derivative works and
- * supporting documentation.  Further, UCAR requests that the user credit
- * UCAR/Unidata in any publications that result from the use of this
- * software or in any product that includes this software. The names UCAR
- * and/or Unidata, however, may not be used in any advertising or publicity
- * to endorse or promote any products or commercial entity unless specific
- * written permission is obtained from UCAR/Unidata. The user also
- * understands that UCAR/Unidata is not obligated to provide the user with
- * any support, consulting, training or assistance of any kind with regard
- * to the use, operation and performance of this software nor to provide
- * the user with any updates, revisions, new versions or "bug fixes."
- *
- * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
- * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
- * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
- * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-package ucar.nc2;
-
-import ucar.unidata.util.EscapeStrings;
-import ucar.ma2.*;
-import ucar.unidata.io.UncompressInputStream;
-import ucar.unidata.io.InMemoryRandomAccessFile;
-import ucar.unidata.io.bzip2.CBZip2InputStream;
-import ucar.nc2.util.DiskCache;
-import ucar.nc2.util.CancelTask;
-import ucar.nc2.util.IO;
-import ucar.nc2.iosp.netcdf3.N3header;
-import ucar.nc2.iosp.netcdf3.N3iosp;
-import ucar.nc2.iosp.netcdf3.SPFactory;
-import ucar.nc2.iosp.IOServiceProvider;
-import ucar.nc2.iosp.IospHelper;
-import ucar.unidata.util.StringUtil;
-
-import java.util.*;
-import java.util.zip.ZipInputStream;
-import java.util.zip.GZIPInputStream;
-import java.net.URL;
-import java.net.URI;
-import java.io.*;
-import java.nio.channels.WritableByteChannel;
-import java.nio.channels.FileLock;
-import java.nio.channels.OverlappingFileLockException;
-
-/**
- * Read-only scientific datasets that are accessible through the netCDF API.
- * Immutable after setImmutable() is called. However, reading data is not thread-safe.
- * <p> Be sure to close the file when done, best practice is to enclose in a try/finally block:
- * <pre>
- * NetcdfFile ncfile = null;
- * try {
- *  ncfile = NetcdfFile.open(fileName);
- *  ...
- * } finally {
- *  ncfile.close();
- * }
- * </pre>
- * <p/>
- * <h3>Naming</h3>
- * Each object has a name (aka "full name") that is unique within the entire netcdf file, and
- * a "short name" that is unique within the parent group.
- * These coincide for objects in the root group, and so are backwards compatible with version 3 files.
- * <ol>
- * <li>Variable: group1/group2/varname
- * <li>Structure member Variable: group1/group2/varname.s1.s2
- * <li>Group Attribute: group1/group2@attName
- * <li>Variable Attribute: group1/group2/varName@attName
- * </ol>
- *
- * @author caron
- */
-
-public class NetcdfFile implements ucar.nc2.util.cache.FileCacheable {
-  static public final String IOSP_MESSAGE_ADD_RECORD_STRUCTURE = "AddRecordStructure";
-  static public final String IOSP_MESSAGE_CONVERT_RECORD_STRUCTURE = "ConvertRecordStructure"; // not implemented yet
-  static public final String IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE = "RemoveRecordStructure";
-  static public final String IOSP_MESSAGE_RANDOM_ACCESS_FILE = "RandomAccessFile";
-
-  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(NetcdfFile.class);
-
-  static private int default_buffersize = 8092;
-  static private ArrayList<IOServiceProvider> registeredProviders = new ArrayList<IOServiceProvider>();
-  static protected boolean debugSPI = false, debugCompress = false, showRequest = false;
-  static boolean debugStructureIterator = false;
-  static boolean loadWarnings = false;
-
-  static private boolean userLoads = false;
-
-  // IOSPs are loaded by reflection
-  static {
-    try {
-      registerIOProvider("ucar.nc2.stream.NcStreamIosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.hdf5.H5iosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.hdf4.H4iosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      NetcdfFile.class.getClassLoader().loadClass("ucar.grib.grib2.Grib2Input"); // only load if grib.jar is present
-      registerIOProvider("ucar.nc2.iosp.grib.GribGridServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      NetcdfFile.class.getClassLoader().loadClass("ucar.grib.grib2.Grib2Input"); // only load if grib.jar is present
-      NetcdfFile.class.getClassLoader().loadClass("visad.util.Trace"); // only load if visad.jar is present
-      registerIOProvider("ucar.nc2.iosp.gempak.GempakGridServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      Class iosp = NetcdfFile.class.getClassLoader().loadClass("ucar.nc2.iosp.bufr.BufrIosp"); // only load if bufr.jar is present
-      registerIOProvider(iosp);
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load resource: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.nexrad2.Nexrad2IOServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.nids.Nidsiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.nowrad.NOWRadiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.dorade.Doradeiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.dmsp.DMSPiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.cinrad.Cinrad2IOServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.misc.GtopoIosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.misc.NmcObsLegacy");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.gini.Giniiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.uf.UFiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.misc.Uspln");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.misc.Nldn");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.fysat.Fysatiosp");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.uamiv.UAMIVServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      NetcdfFile.class.getClassLoader().loadClass("edu.wisc.ssec.mcidas.AreaFile"); // only load if visad.jar is present
-      registerIOProvider("ucar.nc2.iosp.mcidas.AreaServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      NetcdfFile.class.getClassLoader().loadClass("visad.util.Trace"); // only load if visad.jar is present
-      registerIOProvider("ucar.nc2.iosp.gempak.GempakSurfaceIOSP");
-      registerIOProvider("ucar.nc2.iosp.gempak.GempakSoundingIOSP");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      NetcdfFile.class.getClassLoader().loadClass("edu.wisc.ssec.mcidas.GridDirectory"); // only load if visad.jar is present
-      registerIOProvider("ucar.nc2.iosp.mcidas.McIDASGridServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.noaa.Ghcnm2");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.noaa.IgraPor");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-    try {
-      registerIOProvider("ucar.nc2.iosp.grads.GradsBinaryGridServiceProvider");
-    } catch (Throwable e) {
-      if (loadWarnings) log.info("Cant load class: " + e);
-    }
-
-    userLoads = true;
-  }
-
-  ///////////////////////////////////////////////////////////////////////
-
-  /**
-   * Create a valid CDM object name.
-   * Control chars (< 0x20) are not allowed.
-   * Trailing and leading blanks are not allowed and are stripped off.
-   * A forward slash "/" is converted into an underscore "_".
-   *
-   * @param name from this name
-   * @return valid CDM object name
-   */
-  static public String makeValidCdmObjectName(String name) {
-    return StringUtil.makeValidCdmObjectName(name);
-    //return StringUtil.replace(name.trim(), "/", "_");
-  }
-
-  /*
-   * The set of characters in a netcdf object name that are escaped for the "escaped name".
-   */
-  static public final String reserved = ".\\";
-  static public final String reservedSectionSpec = "();,.\\";
-  static public final String reservedCdl = "[ !\"#$%&'()*,:;<=>?[]^`{|}~.\\";
-
-  /**
-   * Escape standard special characters in a netcdf object name.
-   *
-   * @param vname the name
-   * @return escaped version of it
-   */
-  public static String escapeName(String vname) {
-    return EscapeStrings.backslashEscape(vname, NetcdfFile.reserved);
-  }
-
-  /**
-   * Escape special characters in a netcdf object name for CDL.
-   *
-   * @param vname the name
-   * @return escaped version of it
-   */
-  public static String escapeNameCDL(String vname) {
-    return EscapeStrings.backslashEscape(vname, reservedCdl);
-  }
-
-  /**
-   * Escape special characters in a netcdf object name for SectionSpec.
-   *
-   * @param vname the name
-   * @return escaped version of it
-   */
-  public static String escapeNameSectionSpec(String vname) {
-    return EscapeStrings.backslashEscape(vname, reservedSectionSpec);
-  }
-
-  /**
-   * Unescape any escaped characters in a name.
-   *
-   * @param vname the escaped name
-   * @return unescaped version of it
-   */
-  public static String unescapeName(String vname) {
-    return EscapeStrings.backslashUnescape(vname);
-  }
-
-  static protected String makeFullName(Variable v) {
-    return makeFullName(v, null);
-  }
-
-  static protected String makeFullNameEscaped(Variable v) {
-    return makeFullName(v, reserved);
-  }
-
-  static protected String makeFullNameEscapedSectionSpec(Variable v) {
-    return makeFullName(v, reservedSectionSpec);
-  }
-
-  static protected String makeFullName(Variable v, String reserved) {
-    Group parent = v.getParentGroup();
-    if (((parent == null) || parent.isRoot()) && !v.isMemberOfStructure()) return v.getShortName(); // common case
-
-    StringBuilder sbuff = new StringBuilder();
-    appendGroupName(sbuff, parent, reserved);
-    appendStructureName(sbuff, v, reserved);
-    return sbuff.toString();
-  }
-
-  static private void appendGroupName(StringBuilder sbuff, Group g, String reserved) {
-    boolean isRoot = g.getParentGroup() == null;
-    if (isRoot) return;
-
-    if (g.getParentGroup() != null)
-      appendGroupName(sbuff, g.getParentGroup(), reserved);
-    sbuff.append( EscapeStrings.backslashEscape(g.getShortName(), reserved));
-    sbuff.append("/");
-  }
-
-  static private void appendStructureName(StringBuilder sbuff, Variable v, String reserved) {
-    if (v.isMemberOfStructure()) {
-      appendStructureName(sbuff, v.getParentStructure(), reserved);
-      sbuff.append(".");
-    }
-    sbuff.append( EscapeStrings.backslashEscape(v.getShortName(), reserved));
-  }
-
-  //////////////////////////////////////////////////////////////////////////////////////////
-
-  /**
-   * Register an IOServiceProvider, using its class string name.
-   *
-   * @param className Class that implements IOServiceProvider.
-   * @throws IllegalAccessException if class is not accessible.
-   * @throws InstantiationException if class doesnt have a no-arg constructor.
-   * @throws ClassNotFoundException if class not found.
-   */
-  static public void registerIOProvider(String className) throws IllegalAccessException, InstantiationException, ClassNotFoundException {
-    Class ioClass = NetcdfFile.class.getClassLoader().loadClass(className);
-    registerIOProvider(ioClass);
-  }
-
-  /**
-   * Register an IOServiceProvider. A new instance will be created when one of its files is opened.
-   *
-   * @param iospClass Class that implements IOServiceProvider.
-   * @throws IllegalAccessException if class is not accessible.
-   * @throws InstantiationException if class doesnt have a no-arg constructor.
-   * @throws ClassCastException     if class doesnt implement IOServiceProvider interface.
-   */
-  static public void registerIOProvider(Class iospClass) throws IllegalAccessException, InstantiationException {
-    IOServiceProvider spi;
-    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast
-
-    if (userLoads) registeredProviders.add(0, spi);  // put user stuff first
-    else registeredProviders.add(spi);
-  }
-
-  /**
-   * debugging
-   *
-   * @param debugFlag debug flags
-   */
-  static public void setDebugFlags(ucar.nc2.util.DebugFlags debugFlag) {
-    debugSPI = debugFlag.isSet("NetcdfFile/debugSPI");
-    debugCompress = debugFlag.isSet("NetcdfFile/debugCompress");
-    debugStructureIterator = debugFlag.isSet("NetcdfFile/structureIterator");
-    N3header.disallowFileTruncation = debugFlag.isSet("NetcdfFile/disallowFileTruncation");
-    N3header.debugHeaderSize = debugFlag.isSet("NetcdfFile/debugHeaderSize");
-    showRequest = debugFlag.isSet("NetcdfFile/showRequest");
-  }
-
-  /**
-   * debugging
-   * @param printStream write to this stream.
-   *
-  static public void setDebugOutputStream(PrintStream printStream) {
-  ucar.nc2.iosp.hdf5.H5iosp.setDebugOutputStream(printStream);
-  } */
-
-  /**
-   * Set properties. Currently recognized:
-   * "syncExtendOnly", "true" or "false" (default).  if true, can only extend file on a sync.
-   *
-   * @param name  name of property
-   * @param value value of property
-   */
-  static public void setProperty(String name, String value) {
-    N3iosp.setProperty(name, value);
-  }
-
-  /**
-   * Open an existing netcdf file (read only).
-   *
-   * @param location location of file.
-   * @return the NetcdfFile.
-   * @throws java.io.IOException if error
-   */
-  public static NetcdfFile open(String location) throws IOException {
-    return open(location, null);
-  }
-
-  /**
-   * Open an existing file (read only), with option of cancelling.
-   *
-   * @param location   location of the file.
-   * @param cancelTask allow task to be cancelled; may be null.
-   * @return NetcdfFile object, or null if cant find IOServiceProver
-   * @throws IOException if error
-   */
-  static public NetcdfFile open(String location, ucar.nc2.util.CancelTask cancelTask) throws IOException {
-    return open(location, -1, cancelTask);
-  }
-
-  /**
-   * Open an existing file (read only), with option of cancelling, setting the RandomAccessFile buffer size for efficiency.
-   *
-   * @param location    location of file.
-   * @param buffer_size RandomAccessFile buffer size, if <= 0, use default size
-   * @param cancelTask  allow task to be cancelled; may be null.
-   * @return NetcdfFile object, or null if cant find IOServiceProver
-   * @throws IOException if error
-   */
-  static public NetcdfFile open(String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask) throws IOException {
-    return open(location, buffer_size, cancelTask, null);
-  }
-
-  /**
-   * Open an existing file (read only), with option of cancelling, setting the RandomAccessFile buffer size for efficiency,
-   * with an optional special object for the iosp.
-   *
-   * @param location    location of file. This may be a
-   *                    <ol>
-   *                    <li>local netcdf-3 filename (with a file: prefix or no prefix)
-   *                    <li>remote netcdf-3 filename (with an http: prefix)
-   *                    <li>local netcdf-4 filename (with a file: prefix or no prefix)
-   *                    <li>local hdf-5 filename (with a file: prefix or no prefix)
-   *                    <li>local iosp filename (with a file: prefix or no prefix)
-   *                    </ol>
-   *                    If file ends with ".Z", ".zip", ".gzip", ".gz", or ".bz2", it will uncompress/unzip and write to new file without the suffix,
-   *                    then use the uncompressed file. It will look for the uncompressed file before it does any of that. Generally it prefers to
-   *                    place the uncompressed file in the same directory as the original file. If it does not have write permission on that directory,
-   *                    it will use the directory defined by ucar.nc2.util.DiskCache class.
-   * @param buffer_size RandomAccessFile buffer size, if <= 0, use default size
-   * @param cancelTask  allow task to be cancelled; may be null.
-   * @param iospMessage special iosp tweaking (sent before open is called), may be null
-   * @return NetcdfFile object, or null if cant find IOServiceProver
-   * @throws IOException if error
-   */
-  static public NetcdfFile open(String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask, Object iospMessage) throws IOException {
-
-    ucar.unidata.io.RandomAccessFile raf = getRaf(location, buffer_size);
-
-    try {
-      return open(raf, location, cancelTask, iospMessage);
-    } catch (IOException ioe) {
-      raf.close();
-      throw ioe;
-    }
-  }
-
-  /**
-   * Find out if the file can be opened, but dont actually open it.
-   *
-   * @param location same as open
-   * @return true if can be opened
-   * @throws IOException on read error
-   */
-  static public boolean canOpen(String location) throws IOException {
-    ucar.unidata.io.RandomAccessFile raf = null;
-    try {
-      raf = getRaf(location, -1);
-      return (raf != null) ? canOpen(raf) : false;
-    } finally {
-      if (raf != null) raf.close();
-    }
-  }
-
-  private static boolean canOpen(ucar.unidata.io.RandomAccessFile raf) throws IOException {
-    if (N3header.isValidFile(raf)) {
-      return true;
-    } else {
-      for (IOServiceProvider registeredSpi : registeredProviders) {
-        if (registeredSpi.isValidFile(raf))
-          return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Open an existing file (read only), specifying which IOSP is to be used.
-   *
-   * @param location      location of file
-   * @param iospClassName fully qualified class name of the IOSP class to handle this file
-   * @param bufferSize    RandomAccessFile buffer size, if <= 0, use default size
-   * @param cancelTask    allow task to be cancelled; may be null.
-   * @param iospMessage   special iosp tweaking (sent before open is called), may be null
-   * @return NetcdfFile object, or null if cant find IOServiceProver
-   * @throws IOException            if read error
-   * @throws ClassNotFoundException cannat find iospClassName in thye class path
-   * @throws InstantiationException if class cannot be instantiated
-   * @throws IllegalAccessException if class is not accessible
-   */
-  static public NetcdfFile open(String location, String iospClassName, int bufferSize, CancelTask cancelTask, Object iospMessage)
-          throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {
-
-    Class iospClass = NetcdfFile.class.getClassLoader().loadClass(iospClassName);
-    IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast
-
-    // send before iosp is opened
-    if (iospMessage != null)
-      spi.sendIospMessage(iospMessage);
-
-    // get rid of file prefix, if any
-    String uriString = location.trim();
-    if (uriString.startsWith("file://"))
-      uriString = uriString.substring(7);
-    else if (uriString.startsWith("file:"))
-      uriString = uriString.substring(5);
-
-    // get rid of crappy microsnot \ replace with happy /
-    uriString = StringUtil.replace(uriString, '\\', "/");
-
-    if (bufferSize <= 0)
-      bufferSize = default_buffersize;
-    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.RandomAccessFile(uriString, "r", bufferSize);
-
-    NetcdfFile result = new NetcdfFile(spi, raf, location, cancelTask);
-
-    // send after iosp is opened
-    if (iospMessage != null)
-      spi.sendIospMessage(iospMessage);
-
-    return result;
-  }
-
-  static private ucar.unidata.io.RandomAccessFile getRaf(String location, int buffer_size) throws IOException {
-
-    String uriString = location.trim();
-
-    if (buffer_size <= 0)
-      buffer_size = default_buffersize;
-
-    ucar.unidata.io.RandomAccessFile raf;
-    if (uriString.startsWith("http:")) { // open through URL
-      raf = new ucar.unidata.io.http.HTTPRandomAccessFile(uriString);
-
-    } else if (uriString.startsWith("nodods:")) { // open through URL
-      uriString = "http" + uriString.substring(6);
-      raf = new ucar.unidata.io.http.HTTPRandomAccessFile(uriString);
-
-    } else if (uriString.startsWith("slurp:")) { // open through URL
-      uriString = "http" + uriString.substring(5);
-      byte[] contents = IO.readURLContentsToByteArray(uriString); // read all into memory
-      raf = new InMemoryRandomAccessFile(uriString, contents);
-
-    } else {
-      // get rid of crappy microsnot \ replace with happy /
-      uriString = StringUtil.replace(uriString, '\\', "/");
-
-      if (uriString.startsWith("file:")) {
-        // uriString = uriString.substring(5);
-        uriString = StringUtil.unescape(uriString.substring(5));  // 11/10/2010 from erussell@ngs.org
-      }
-
-      String uncompressedFileName = null;
-      try {
-        uncompressedFileName = makeUncompressed(uriString);
-      } catch (Exception e) {
-        log.warn("Failed to uncompress " + uriString + " err= " + e.getMessage() + "; try as a regular file.");
-        //allow to fall through to open the "compressed" file directly - may be a misnamed suffix
-      }
-
-      if (uncompressedFileName != null) {
-        // open uncompressed file as a RandomAccessFile.
-        raf = new ucar.unidata.io.RandomAccessFile(uncompressedFileName, "r", buffer_size);
-        //raf = new ucar.unidata.io.MMapRandomAccessFile(uncompressedFileName, "r");
-
-      } else {
-        // normal case - not compressed
-        raf = new ucar.unidata.io.RandomAccessFile(uriString, "r", buffer_size);
-        //raf = new ucar.unidata.io.MMapRandomAccessFile(uriString, "r");
-      }
-    }
-
-    return raf;
-  }
-
-  static private String makeUncompressed(String filename) throws Exception {
-    // see if its a compressed file
-    int pos = filename.lastIndexOf('.');
-    if (pos < 0) return null;
-
-    String suffix = filename.substring(pos + 1);
-    String uncompressedFilename = filename.substring(0, pos);
-
-    if (!suffix.equalsIgnoreCase("Z") && !suffix.equalsIgnoreCase("zip") && !suffix.equalsIgnoreCase("gzip")
-            && !suffix.equalsIgnoreCase("gz") && !suffix.equalsIgnoreCase("bz2"))
-      return null;
-
-    // see if already decompressed, look in cache if need be
-    File uncompressedFile = DiskCache.getFileStandardPolicy(uncompressedFilename);
-    if (uncompressedFile.exists() && uncompressedFile.length() > 0) {
-      // see if its locked - another thread is writing it
-      FileInputStream stream = null;
-      FileLock lock = null;
-      try {
-        stream = new FileInputStream(uncompressedFile);
-        // obtain the lock
-        while (true) { // loop waiting for the lock
-          try {
-            lock = stream.getChannel().lock(0, 1, true); // wait till its unlocked
-            break;
-
-          } catch (OverlappingFileLockException oe) { // not sure why lock() doesnt block
-            try {
-              Thread.sleep(100); // msecs
-            } catch (InterruptedException e1) {
-              break;
-            }
-          }
-        }
-
-        if (debugCompress) System.out.println("found uncompressed " + uncompressedFile + " for " + filename);
-        return uncompressedFile.getPath();
-      } finally {
-        if (lock != null) lock.release();
-        if (stream != null) stream.close();
-      }
-    }
-
-    // ok gonna write it
-    // make sure compressed file exists
-    File file = new File(filename);
-    if (!file.exists())
-      return null; // bail out  */
-
-    InputStream in = null;
-    FileOutputStream fout = new FileOutputStream(uncompressedFile);
-
-    // obtain the lock
-    FileLock lock = null;
-    while (true) { // loop waiting for the lock
-      try {
-        lock = fout.getChannel().lock(0, 1, false);
-        break;
-
-      } catch (OverlappingFileLockException oe) { // not sure why lock() doesnt block
-        try {
-          Thread.sleep(100); // msecs
-        } catch (InterruptedException e1) {
-        }
-      }
-    }
-
-    try {
-      if (suffix.equalsIgnoreCase("Z")) {
-        in = new UncompressInputStream(new FileInputStream(filename));
-        copy(in, fout, 100000);
-        if (debugCompress) System.out.println("uncompressed " + filename + " to " + uncompressedFile);
-
-      } else if (suffix.equalsIgnoreCase("zip")) {
-        in = new ZipInputStream(new FileInputStream(filename));
-        copy(in, fout, 100000);
-        if (debugCompress) System.out.println("unzipped " + filename + " to " + uncompressedFile);
-
-      } else if (suffix.equalsIgnoreCase("bz2")) {
-        in = new CBZip2InputStream(new FileInputStream(filename), true);
-        copy(in, fout, 100000);
-        if (debugCompress) System.out.println("unbzipped " + filename + " to " + uncompressedFile);
-
-      } else if (suffix.equalsIgnoreCase("gzip") || suffix.equalsIgnoreCase("gz")) {
-
-        in = new GZIPInputStream(new FileInputStream(filename));
-        copy(in, fout, 100000);
-
-        if (debugCompress) System.out.println("ungzipped " + filename + " to " + uncompressedFile);
-      }
-    } catch (Exception e) {
-
-      // appears we have to close before we can delete
-      if (fout != null) fout.close();
-      fout = null;
-
-      // dont leave bad files around
-      if (uncompressedFile.exists()) {
-        if (!uncompressedFile.delete())
-          log.warn("failed to delete uncompressed file (IOException)" + uncompressedFile);
-      }
-      throw e;
-
-    } finally {
-      if (lock != null) lock.release();
-      if (in != null) in.close();
-      if (fout != null) fout.close();
-    }
-
-    return uncompressedFile.getPath();
-  }
-
-  static private void copy(InputStream in, OutputStream out, int bufferSize) throws IOException {
-    byte[] buffer = new byte[bufferSize];
-    while (true) {
-      int bytesRead = in.read(buffer);
-      if (bytesRead == -1) break;
-      out.write(buffer, 0, bytesRead);
-    }
-  }
-
-  /**
-   * Open an in-memory netcdf file, with a specific iosp.
-   *
-   * @param name          name of the dataset. Typically use the filename or URI.
-   * @param data          in-memory netcdf file
-   * @param iospClassName fully qualified class name of the IOSP class to handle this file
-   * @return NetcdfFile object, or null if cant find IOServiceProver
-   * @throws IOException            if read error
-   * @throws ClassNotFoundException cannat find iospClassName in the class path
-   * @throws InstantiationException if class cannot be instantiated
-   * @throws IllegalAccessException if class is not accessible
-   */
-  public static NetcdfFile openInMemory(String name, byte[] data, String iospClassName) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {
-
-    ucar.unidata.io.InMemoryRandomAccessFile raf = new ucar.unidata.io.InMemoryRandomAccessFile(name, data);
-    Class iospClass = NetcdfFile.class.getClassLoader().loadClass(iospClassName);
-    IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance();
-
-    return new NetcdfFile(spi, raf, name, null);
-  }
-
-  /**
-   * Open an in-memory netcdf file.
-   *
-   * @param name name of the dataset. Typically use the filename or URI.
-   * @param data in-memory netcdf file
-   * @return memory-resident NetcdfFile
-   * @throws java.io.IOException if error
-   */
-  public static NetcdfFile openInMemory(String name, byte[] data) throws IOException {
-    ucar.unidata.io.InMemoryRandomAccessFile raf = new ucar.unidata.io.InMemoryRandomAccessFile(name, data);
-    return open(raf, name, null, null);
-  }
-
-  /**
-   * Read a local CDM file into memory. All reads are then done from memory.
-   *
-   * @param filename location of CDM file, must be a local file.
-   * @return a NetcdfFile, which is completely in memory
-   * @throws IOException if error reading file
-   */
-  public static NetcdfFile openInMemory(String filename) throws IOException {
-    File file = new File(filename);
-    ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length());
-    InputStream in = new BufferedInputStream(new FileInputStream(filename));
-    IO.copy(in, bos);
-    return openInMemory(filename, bos.toByteArray());
-  }
-
-  /**
-   * Read a remote CDM file into memory. All reads are then done from memory.
-   *
-   * @param uri location of CDM file, must be accessible through uri.toURL().openStream().
-   * @return a NetcdfFile, which is completely in memory
-   * @throws IOException if error reading file
-   */
-  public static NetcdfFile openInMemory(URI uri) throws IOException {
-    URL url = uri.toURL();
-    byte[] contents = IO.readContentsToByteArray(url.openStream());
-    return openInMemory(uri.toString(), contents);
-  }
-
-  private static NetcdfFile open(ucar.unidata.io.RandomAccessFile raf, String location, ucar.nc2.util.CancelTask cancelTask,
-                                 Object iospMessage) throws IOException {
-
-    IOServiceProvider spi = null;
-    if (debugSPI) System.out.println("NetcdfFile try to open = " + location);
-
-    // avoid opening file more than once, so pass around the raf.
-    if (N3header.isValidFile(raf)) {
-      spi = SPFactory.getServiceProvider();
-
-      //} else if (H5header.isValidFile(raf)) {
-      // spi = new ucar.nc2.iosp.hdf5.H5iosp();
-
-    } else {
-      // look for registered providers
-      for (IOServiceProvider registeredSpi : registeredProviders) {
-        if (debugSPI) System.out.println(" try iosp = " + registeredSpi.getClass().getName());
-
-        if (registeredSpi.isValidFile(raf)) {
-          // need a new instance for thread safety
-          Class c = registeredSpi.getClass();
-          try {
-            spi = (IOServiceProvider) c.newInstance();
-          } catch (InstantiationException e) {
-            throw new IOException("IOServiceProvider " + c.getName() + "must have no-arg constructor."); // shouldnt happen
-          } catch (IllegalAccessException e) {
-            throw new IOException("IOServiceProvider " + c.getName() + " IllegalAccessException: " + e.getMessage()); // shouldnt happen
-          }
-          break;
-        }
-      }
-    }
-
-    if (spi == null) {
-      raf.close();
-      throw new IOException("Cant read " + location + ": not a valid CDM file.");
-    }
-
-    // send before iosp is opened
-    if (iospMessage != null)
-      spi.sendIospMessage(iospMessage);
-
-    if (log.isDebugEnabled())
-      log.debug("Using IOSP " + spi.getClass().getName());
-
-    NetcdfFile result = new NetcdfFile(spi, raf, location, cancelTask);
-
-    // send after iosp is opened
-    if (iospMessage != null)
-      spi.sendIospMessage(iospMessage);
-
-    return result;
-  }
-
-  ////////////////////////////////////////////////////////////////////////////////////////////////
-  protected String location, id, title, cacheName;
-  protected Group rootGroup = makeRootGroup();
-  protected boolean unlocked = false; // in the cache but not locked
-  private boolean immutable = false;
-
-  protected ucar.nc2.util.cache.FileCache cache;
-  protected IOServiceProvider spi;
-
-  // "global view" is derived from the group information.
-  protected List<Variable> variables;
-  protected List<Dimension> dimensions;
-  protected List<Attribute> gattributes;
-
-  /*
-   * Is the dataset closed, and not available for use.
-   * @return true if closed
-   */
-  public synchronized boolean isUnlocked() {
-    return unlocked;
-  }
-
-  /**
-   * Close all resources (files, sockets, etc) associated with this file.
-   * If the underlying file was acquired, it will be released, otherwise closed.
-   * if isClosed() already, nothing will happen
-   *
-   * @throws java.io.IOException if error when closing
-   */
-  public synchronized void close() throws java.io.IOException {
-    if (cache != null) {
-      unlocked = true;
-      cache.release(this);
-
-    } else {
-      try {
-        if (null != spi) {
-          // log.warn("NetcdfFile.close called for ncfile="+this.hashCode()+" for iosp="+spi.hashCode());
-          spi.close();
-        }
-      } finally {
-        spi = null;
-      }
-    }
-  }
-
-  /**
-   * Public by accident.
-   * Optional file caching.
-   */
-  public void setFileCache(ucar.nc2.util.cache.FileCache cache) {
-    this.cache = cache;
-  }
-
-  /**
-   * Public by accident.
-   * Get the name used in the cache, if any.
-   *
-   * @return name in the cache.
-   */
-  public String getCacheName() {
-    return cacheName;
-  }
-
-  /**
-   * Public by accident.
-   *
-   * @param cacheName name in the cache, should be unique for this NetcdfFile. Usually the location.
-   */
-  protected void setCacheName(String cacheName) {
-    this.cacheName = cacheName;
-  }
-
-  /**
-   * Get the NetcdfFile location. This is a URL, or a file pathname.
-   *
-   * @return location URL or file pathname.
-   */
-  public String getLocation() {
-    return location;
-  }
-
-  /**
-   * Get the globally unique dataset identifier, if it exists.
-   *
-   * @return id, or null if none.
-   */
-  public String getId() {
-    return id;
-  }
-
-  /**
-   * Get the human-readable title, if it exists.
-   *
-   * @return title, or null if none.
-   */
-  public String getTitle() {
-    return title;
-  }
-
-  /**
-   * Get the root group.
-   *
-   * @return root group
-   */
-  public Group getRootGroup() {
-    return rootGroup;
-  }
-
-  /**
-   * Get all of the variables in the file, in all groups.
-   * This is part of "version 3 compatibility" interface.
-   * Alternatively, use groups.
-   *
-   * @return List of type Variable.
-   */
-  public java.util.List<Variable> getVariables() {
-    return variables;
-  }
-
-  /*
-   * Retrieve the Variable with the specified (full) name, which is not a member of a Structure.
-   *
-   * @param name full name, starting from root group.
-   * @return the Variable, or null if not found
-   *
-  public Variable findTopVariable(String name) {
-    if (name == null) return null;
-
-    for (Variable v : variables) {
-      if (name.equals(v.getName()))
-        return v;
-    }
-    return null;
-  } */
-
-  /**
-   * Find a Group, with the specified (full) name.
-   * An embedded "/" is interpreted as separating group names.
-   *
-   * @param fullName eg "/group/subgroup/wantGroup". Null or empty string returns the root group.
-   * @return Group or null if not found.
-   */
-  public Group findGroup(String fullName) {
-    if (fullName == null || fullName.length() == 0)
-      return rootGroup;
-
-    Group g = rootGroup;
-    String[] groupNames = fullName.split("/");
-    for (String groupName : groupNames) {
-      g = g.findGroup(groupName);
-      if (g == null) return null;
-    }
-    return g;
-  }
-
-  /**
-   * Find a Variable, with the specified (escaped full) name.
-   * It may possibly be nested in multiple groups and/or structures.
-   * An embedded "." is interpreted as structure.member.
-   * An embedded "/" is interpreted as group/variable.
-   * If the name actually has a ".", you must escape it (call NetcdfFile.escapeName(varname))
-   * Any other chars may also be escaped, as they are removed before testing.
-   *
-   * @param fullNameEscaped eg "/group/subgroup/name1.name2.name".
-   * @return Variable or null if not found.
-   * @see NetcdfFile#escapeName
-   * @see NetcdfFile#unescapeName
-   */
-  public Variable findVariable(String fullNameEscaped) {
-    if (fullNameEscaped == null || fullNameEscaped.length() == 0) {
-      return null;
-    }
-
-    Group g = rootGroup;
-    String vars = fullNameEscaped;
-
-    // break into group/group and var.var
-    int pos = fullNameEscaped.lastIndexOf('/');
-    if (pos >= 0) {
-      String groups = fullNameEscaped.substring(0, pos);
-      vars = fullNameEscaped.substring(pos + 1);
-      StringTokenizer stoke = new StringTokenizer(groups, "/");
-      while (stoke.hasMoreTokens()) {
-        String token = NetcdfFile.unescapeName( stoke.nextToken());
-        g = g.findGroup(token);
-        if (g == null) return null;
-      }
-    }
-
-    // heres var.var - tokenize respecting the possible escaped '.'
-    List<String> snames = EscapeStrings.tokenizeEscapedName(vars);
-    if (snames.size() == 0) return null;
-
-    String varShortName = NetcdfFile.unescapeName(snames.get(0));
-    Variable v = g.findVariable(varShortName);
-    if (v == null) return null;
-
-    int memberCount = 1;
-    while (memberCount < snames.size()) {
-      if (!(v instanceof Structure)) return null;
-      String name = NetcdfFile.unescapeName(snames.get(memberCount++));
-      v = ((Structure) v).findVariable(name);
-      if (v == null) return null;
-    }
-    return v;
-  }
-
-  /**
-   * Get the shared Dimensions used in this file.
-   * This is part of "version 3 compatibility" interface.
-   * <p> If the dimensions are in a group, the dimension name will have the
-   * group name, in order to disambiguate the dimensions. This means that
-   * a Variable's dimensions will not match Dimensions in this list.
-   * Therefore it is better to get the shared Dimensions directly from the Groups.
-   *
-   * @return List of type Dimension.
-   */
-  public List<Dimension> getDimensions() {
-    return immutable ? dimensions : new ArrayList<Dimension>(dimensions);
-  }
-
-  /**
-   * Retrieve a dimension by fullName.
-   *
-   * @param name dimension full name, (using parent group names if not in the root group)
-   * @return the dimension, or null if not found
-   */
-  public Dimension findDimension(String name) {
-    if (name == null) return null;
-    for (Dimension d : dimensions) {
-      if (name.equals(d.getName()))
-        return d;
-    }
-    return null;
-  }
-
-  /**
-   * Return true if this file has one or more unlimited (record) dimension.
-   *
-   * @return if this file has an unlimited Dimension(s)
-   */
-  public boolean hasUnlimitedDimension() {
-    return getUnlimitedDimension() != null;
-  }
-
-  /**
-   * Return the unlimited (record) dimension, or null if not exist.
-   * If there are multiple unlimited dimensions, it will return the first one.
-   *
-   * @return the unlimited Dimension, or null if none.
-   */
-  public Dimension getUnlimitedDimension() {
-    for (Dimension d : dimensions) {
-      if (d.isUnlimited()) return d;
-    }
-    return null;
-  }
-
-  /**
-   * Returns the set of global attributes associated with this file.
-   * This is part of "version 3 compatibility" interface.
-   * Alternatively, use groups.
-   *
-   * @return List of type Attribute
-   */
-  public java.util.List<Attribute> getGlobalAttributes() {
-    return immutable ? gattributes : new ArrayList<Attribute>(gattributes);
-  }
-
-  /**
-   * Look up global Attribute by (full) name.
-   *
-   * @param name the name of the attribute
-   * @return the attribute, or null if not found
-   */
-  public Attribute findGlobalAttribute(String name) {
-    for (Attribute a : gattributes) {
-      if (name.equals(a.getName()))
-        return a;
-    }
-    return null;
-  }
-
-  /**
-   * Look up global Attribute by name, ignore case.
-   *
-   * @param name the name of the attribute
-   * @return the attribute, or null if not found
-   */
-  public Attribute findGlobalAttributeIgnoreCase(String name) {
-    for (Attribute a : gattributes) {
-      if (name.equalsIgnoreCase(a.getName()))
-        return a;
-    }
-    return null;
-  }
-
-  /**
-   * Find a String-valued global or variable Attribute by
-   * Attribute name (ignore case), return the Value of the Attribute.
-   * If not found return defaultValue
-   *
-   * @param v            the variable or null for global attribute
-   * @param attName      the (full) name of the attribute, case insensitive
-   * @param defaultValue return this if attribute not found
-   * @return the attribute value, or defaultValue if not found
-   */
-  public String findAttValueIgnoreCase(Variable v, String attName, String defaultValue) {
-    String attValue = null;
-    Attribute att;
-
-    if (v == null)
-      att = rootGroup.findAttributeIgnoreCase(attName);
-    else
-      att = v.findAttributeIgnoreCase(attName);
-
-    if ((att != null) && att.isString())
-      attValue = att.getStringValue();
-
-    if (null == attValue)                     // not found, use default
-      attValue = defaultValue;
-
-    return attValue;
-  }
-
-  public double readAttributeDouble(Variable v, String attName, double defValue) {
-    Attribute att;
-
-    if (v == null)
-      att = rootGroup.findAttributeIgnoreCase(attName);
-    else
-      att = v.findAttributeIgnoreCase(attName);
-
-    if (att == null) return defValue;
-    if (att.isString())
-      return Double.parseDouble(att.getStringValue());
-    else
-      return att.getNumericValue().doubleValue();
-  }
-
-  public int readAttributeInteger(Variable v, String attName, int defValue) {
-    Attribute att;
-
-    if (v == null)
-      att = rootGroup.findAttributeIgnoreCase(attName);
-    else
-      att = v.findAttributeIgnoreCase(attName);
-
-    if (att == null) return defValue;
-    if (att.isString())
-      return Integer.parseInt(att.getStringValue());
-    else
-      return att.getNumericValue().intValue();
-  }
-
-
-  //////////////////////////////////////////////////////////////////////////////////////
-
-  /**
-   * Write CDL representation to OutputStream.
-   *
-   * @param out    write to this OutputStream
-   * @param strict if true, make it stricly CDL, otherwise, add a little extra info
-   */
-  public void writeCDL(OutputStream out, boolean strict) {
-    PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));
-    toStringStart(pw, strict);
-    toStringEnd(pw);
-    pw.flush();
-  }
-
-  /**
-   * Write CDL representation to PrintWriter.
-   *
-   * @param pw     write to this PrintWriter
-   * @param strict if true, make it stricly CDL, otherwise, add a little extra info
-   */
-  public void writeCDL(PrintWriter pw, boolean strict) {
-    toStringStart(pw, strict);
-    toStringEnd(pw);
-    pw.flush();
-  }
-
-  /**
-   * CDL representation of Netcdf header info.
-   */
-  public String toString() {
-    StringWriter writer = new StringWriter(50000);
-    writeCDL(new PrintWriter(writer), false);
-    return writer.toString();
-  }
-
-  protected void toStringStart(PrintWriter pw, boolean strict) {
-    String name = getLocation();
-    if (strict) {
-      int pos = name.lastIndexOf('/');
-      if (pos < 0) pos = name.lastIndexOf('\\');
-      if (pos >= 0) name = name.substring(pos + 1);
-      if (name.endsWith(".nc")) name = name.substring(0, name.length() - 3);
-      if (name.endsWith(".cdl")) name = name.substring(0, name.length() - 4);
-    }
-    pw.print("netcdf " + name + " {\n");
-    rootGroup.writeCDL(pw, "", strict);
-  }
-
-  protected void toStringEnd(PrintWriter pw) {
-    pw.print("}\n");
-  }
-
-  /**
-   * Write the NcML representation: dont show coodinate values
-   *
-   * @param os  : write to this Output Stream.
-   * @param uri use this for the uri attribute; if null use getLocation(). // ??
-   * @throws IOException if error
-   * @see NCdumpW#writeNcML
-   */
-  public void writeNcML(java.io.OutputStream os, String uri) throws IOException {
-    NCdumpW.writeNcML(this, new OutputStreamWriter(os), false, uri);
-  }
-
-  /**
-   * Write the NcML representation: dont show coodinate values
-   *
-   * @param writer : write to this Writer, should have encoding of UTF-8 if applicable
-   * @param uri    use this for the uri attribute; if null use getLocation().
-   * @throws IOException if error
-   * @see NCdumpW#writeNcML
-   */
-  public void writeNcML(java.io.Writer writer, String uri) throws IOException {
-    NCdumpW.writeNcML(this, writer, false, uri);
-  }
-
-  /**
-   * Extend the file if needed, in a way that is compatible with the current metadata, that is,
-   * does not invalidate structural metadata held by the application.
-   * For example, ok if dimension lengths, data has changed.
-   * All previous object references (variables, dimensions, etc) remain valid.
-   *
-   * @return true if file was extended.
-   * @throws IOException if error
-   */
-  public boolean syncExtend() throws IOException {
-    unlocked = false;
-    return (spi != null) && spi.syncExtend();
-  }
-
-  /**
-   * Check if file has changed, and reread metadata if needed.
-   * All previous object references (variables, dimensions, etc) may become invalid - you must re-obtain.
-   * DO NOT USE THIS ROUTINE YET - NOT FULLY TESTED
-   *
-   * @return true if file was changed.
-   * @throws IOException if error
-   */
-  public boolean sync() throws IOException {
-    unlocked = false;
-    return (spi != null) && spi.sync();
-  }
-
-  //////////////////////////////////////////////////////////////////////////////////////
-  // construction
-
-  /**
-   * This is can only be used for local netcdf-3 files.
-   *
-   * @param filename location
-   * @throws java.io.IOException if error
-   * @deprecated use NetcdfFile.open( location) or NetcdfDataset.openFile( location)
-   */
-  public NetcdfFile(String filename) throws IOException {
-    this.location = filename;
-    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.RandomAccessFile(filename, "r");
-    //ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.MMapRandomAccessFile(filename, "r");
-    this.spi = SPFactory.getServiceProvider();
-    spi.open(raf, this, null);
-    finish();
-  }
-
-  /**
-   * This can only be used for netcdf-3 files served over HTTP
-   *
-   * @param url HTTP URL location
-   * @throws java.io.IOException if error
-   * @deprecated use NetcdfFile.open( http:location) or NetcdfDataset.openFile( http:location)
-   */
-  public NetcdfFile(URL url) throws IOException {
-    this.location = url.toString();
-    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.http.HTTPRandomAccessFile(location);
-    this.spi = SPFactory.getServiceProvider();
-    spi.open(raf, this, null);
-    finish();
-  }
-
-  /**
-   * Open an existing netcdf file (read only), using the specified iosp.
-   * The ClassLoader for the NetcdfFile class is used.
-   *
-   * @param iospClassName the name of the class implementing IOServiceProvider
-   * @param iospParam     parameter to pass to the IOSP (before open is called)
-   * @param location      location of file. This is a URL string, or a local pathname.
-   * @param buffer_size   use this buffer size on the RandomAccessFile
-   * @param cancelTask    allow user to cancel
-   * @throws ClassNotFoundException if the iospClassName cannot be found
-   * @throws IllegalAccessException if the class or its nullary constructor is not accessible.
-   * @throws InstantiationException if the class cannot be instatiated, eg if it has no nullary constructor
-   * @throws IOException            if I/O error
-   */
-  protected NetcdfFile(String iospClassName, String iospParam, String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask)
-          throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {
-
-    Class iospClass = getClass().getClassLoader().loadClass(iospClassName);
-    spi = (IOServiceProvider) iospClass.newInstance();
-    if (debugSPI) System.out.println("NetcdfFile uses iosp = " + spi.getClass().getName());
-    spi.sendIospMessage(iospParam);
-
-    this.location = location;
-    ucar.unidata.io.RandomAccessFile raf = getRaf(location, buffer_size);
-
-    try {
-      this.spi.open(raf, this, cancelTask);
-      finish();
-
-    } catch (IOException e) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      spi = null;
-      throw e;
-
-    } catch (RuntimeException e) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      spi = null;
-      throw e;
-
-    } catch (Throwable t) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      spi = null;
-      throw new RuntimeException(t);
-    }
-
-    if (id == null)
-      setId(findAttValueIgnoreCase(null, "_Id", null));
-    if (title == null)
-      setId(findAttValueIgnoreCase(null, "_Title", null));
-  }
-
-  /**
-   * Open an existing netcdf file (read only).
-   *
-   * @param location   location of file. This is a URL string, or a local pathname.
-   * @param spi        use this IOServiceProvider instance
-   * @param raf        read from this RandomAccessFile
-   * @param cancelTask allow user to cancel
-   * @throws IOException if I/O error
-   */
-  protected NetcdfFile(IOServiceProvider spi, ucar.unidata.io.RandomAccessFile raf, String location, ucar.nc2.util.CancelTask cancelTask) throws IOException {
-
-    this.spi = spi;
-    this.location = location;
-
-    if (debugSPI) System.out.println("NetcdfFile uses iosp = " + spi.getClass().getName());
-
-    try {
-      spi.open(raf, this, cancelTask);
-
-    } catch (IOException e) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      this.spi = null;
-      throw e;
-
-    } catch (RuntimeException e) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      this.spi = null;
-      throw e;
-
-    } catch (Throwable t) {
-      try {
-        spi.close();
-      } catch (Throwable t1) {
-      }
-      try {
-        raf.close();
-      } catch (Throwable t2) {
-      }
-      this.spi = null;
-      throw new RuntimeException(t);
-    }
-
-    if (id == null)
-      setId(findAttValueIgnoreCase(null, "_Id", null));
-    if (title == null)
-      setId(findAttValueIgnoreCase(null, "_Title", null));
-
-    finish();
-  }
-
-  /**
-   * For subclass construction. Call finish() when completed construction.
-   */
-  protected NetcdfFile() {
-  }
-
-  /**
-   * Copy constructor, used by NetcdfDataset.
-   * Shares the iosp.
-   *
-   * @param ncfile copy from here
-   */
-  protected NetcdfFile(NetcdfFile ncfile) {
-    this.location = ncfile.getLocation();
-    this.id = ncfile.getId();
-    this.title = ncfile.getTitle();
-    this.spi = ncfile.spi;
-  }
-
-  /**
-   * Add an attribute to a group.
-   *
-   * @param parent add to this group. If group is null, use root group
-   * @param att    add this attribute
-   * @return the attribute that was added
-   */
-  public Attribute addAttribute(Group parent, Attribute att) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (parent == null) parent = rootGroup;
-    parent.addAttribute(att);
-    return att;
-  }
-
-  /**
-   * Add a group to the parent group.
-   *
-   * @param parent add to this group. If group is null, use root group
-   * @param g      add this group
-   * @return the group that was added
-   */
-  public Group addGroup(Group parent, Group g) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (parent == null) parent = rootGroup;
-    parent.addGroup(g);
-    return g;
-  }
-
-  /**
-   * Add a shared Dimension to a Group.
-   *
-   * @param parent add to this group. If group is null, use root group
-   * @param d      add this Dimension
-   * @return the dimension that was added
-   */
-  public Dimension addDimension(Group parent, Dimension d) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (parent == null) parent = rootGroup;
-    parent.addDimension(d);
-    return d;
-  }
-
-  /**
-   * Remove a shared Dimension from a Group by name.
-   *
-   * @param g       remove from this group. If group is null, use root group
-   * @param dimName name of Dimension to remove.
-   * @return true if found and removed.
-   */
-  public boolean removeDimension(Group g, String dimName) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (g == null) g = rootGroup;
-    return g.removeDimension(dimName);
-  }
-
-  /**
-   * Add a Variable to the given group.
-   *
-   * @param g add to this group. If group is null, use root group
-   * @param v add this Variable
-   * @return the variable that was added
-   */
-  public Variable addVariable(Group g, Variable v) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (g == null) g = rootGroup;
-    if (v != null) g.addVariable(v);
-    return v;
-  }
-
-  /**
-   * Create a new Variable, and add to the given group.
-   *
-   * @param g         add to this group. If group is null, use root group
-   * @param shortName short name of the Variable
-   * @param dtype     data type of the Variable
-   * @param dims      list of dimension names
-   * @return the new Variable
-   */
-  public Variable addVariable(Group g, String shortName, DataType dtype, String dims) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (g == null) g = rootGroup;
-    Variable v = new Variable(this, g, null, shortName);
-    v.setDataType(dtype);
-    v.setDimensions(dims);
-    g.addVariable(v);
-    return v;
-  }
-
-  /**
-   * Create a new Variable of type Datatype.CHAR, and add to the given group.
-   *
-   * @param g         add to this group. If group is null, use root group
-   * @param shortName short name of the Variable
-   * @param dims      list of dimension names
-   * @param strlen    dimension length of the inner (fastest changing) dimension
-   * @return the new Variable
-   */
-  public Variable addStringVariable(Group g, String shortName, String dims, int strlen) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (g == null) g = rootGroup;
-    String dimName = shortName + "_strlen";
-    addDimension(g, new Dimension(dimName, strlen));
-    Variable v = new Variable(this, g, null, shortName);
-    v.setDataType(DataType.CHAR);
-    v.setDimensions(dims + " " + dimName);
-    g.addVariable(v);
-    return v;
-  }
-
-  /**
-   * Remove a Variable from the given group by name.
-   *
-   * @param g       remove from this group. If group is null, use root group
-   * @param varName name of variable to remove.
-   * @return true is variable found and removed
-   */
-  public boolean removeVariable(Group g, String varName) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (g == null) g = rootGroup;
-    return g.removeVariable(varName);
-  }
-
-  /**
-   * Add a variable attribute.
-   *
-   * @param v   add to this Variable.
-   * @param att add this attribute
-   * @return the added Attribute
-   */
-  public Attribute addVariableAttribute(Variable v, Attribute att) {
-    return v.addAttribute(att);
-  }
-
-  /*
-   * Add a Variable to the given structure.
-   * @param s add to this Structure
-   * @param v add this Variable.
-   * @deprecated use Structure.addMemberVariable(StructureMember)
-   *
-  public void addMemberVariable(Structure s, Variable v) {
-    if (v != null) s.addMemberVariable(v);
-  } */
-
-  /**
-   * Generic way to send a "message" to the underlying IOSP.
-   * This message is sent after the file is open. To affect the creation of the file, you must send into the factory method.
-   *
-   * @param message iosp specific message
-   *                Special:<ul>
-   *                <li>NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE : tells Netcdf-3 files to make record (unlimited) variables into a structure.
-   *                return true if it has a Nectdf-3 record structure
-   *                </ul>
-   * @return iosp specific return, may be null
-   */
-  public Object sendIospMessage(Object message) {
-    if (null == message) return null;
-
-    if (message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE) {
-      Variable v = rootGroup.findVariable("record");
-      boolean gotit = (v != null) && (v instanceof Structure);
-      return gotit || makeRecordStructure();
-
-    } else if (message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE) {
-      Variable v = rootGroup.findVariable("record");
-      boolean gotit = (v != null) && (v instanceof Structure);
-      if (gotit) {
-        rootGroup.remove(v);
-        variables.remove(v);
-        removeRecordStructure();
-      }
-      return (gotit);
-    }
-
-    if (spi != null)
-      return spi.sendIospMessage(message);
-    return null;
-  }
-
-  /**
-   * If there is an unlimited dimension, make all variables that use it into a Structure.
-   * A Variable called "record" is added.
-   * You can then access these through the record structure.
-   *
-   * @return true if it has a Nectdf-3 record structure
-   */
-  protected Boolean makeRecordStructure() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-
-    Boolean didit = false;
-    if ((spi != null) && (spi instanceof N3iosp) && hasUnlimitedDimension()) {
-      didit = (Boolean) spi.sendIospMessage(IOSP_MESSAGE_ADD_RECORD_STRUCTURE);
-    }
-    return didit;
-  }
-
-  protected Boolean removeRecordStructure() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-
-    Boolean didit = false;
-    if ((spi != null) && (spi instanceof N3iosp)) {
-      didit = (Boolean) spi.sendIospMessage(IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE);
-    }
-    return didit;
-  }
-
-  //protected boolean addedRecordStructure = false;
-
-  /**
-   * Set the globally unique dataset identifier.
-   *
-   * @param id the id
-   */
-  public void setId(String id) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.id = id;
-  }
-
-  /**
-   * Set the dataset "human readable" title.
-   *
-   * @param title the title
-   */
-  public void setTitle(String title) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.title = title;
-  }
-
-  /**
-   * Set the location, a URL or local filename.
-   *
-   * @param location the location
-   */
-  public void setLocation(String location) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.location = location;
-  }
-
-  /**
-   * Make this immutable.
-   *
-   * @return this
-   */
-  public NetcdfFile setImmutable() {
-    if (immutable) return this;
-    immutable = true;
-    setImmutable(rootGroup);
-    variables = Collections.unmodifiableList(variables);
-    dimensions = Collections.unmodifiableList(dimensions);
-    gattributes = Collections.unmodifiableList(gattributes);
-    return this;
-  }
-
-  private void setImmutable(Group g) {
-    for (Variable v : g.variables)
-      v.setImmutable();
-
-    for (Dimension d : g.dimensions)
-      d.setImmutable();
-
-    for (Group nested : g.getGroups())
-      setImmutable(nested);
-
-    g.setImmutable();
-  }
-
-  /**
-   * Completely empty the objects in the netcdf file.
-   * Used for rereading the file on a sync().
-   */
-  public void empty() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    variables = new ArrayList<Variable>();
-    gattributes = new ArrayList<Attribute>();
-    dimensions = new ArrayList<Dimension>();
-    rootGroup = makeRootGroup();
-    // addedRecordStructure = false;
-  }
-
-  protected Group makeRootGroup() {
-    Group root = new Group(this, null, "");
-    root.parent = null;
-    return root;
-  }
-
-  /**
-   * Finish constructing the object model.
-   * This construsts the "global" variables, attributes and dimensions.
-   * It also looks for coordinate variables.
-   */
-  public void finish() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    variables = new ArrayList<Variable>();
-    dimensions = new ArrayList<Dimension>();
-    gattributes = new ArrayList<Attribute>();
-    finishGroup(rootGroup);
-  }
-
-  private void finishGroup(Group g) {
-
-    variables.addAll(g.variables);
-
-    // LOOK should group atts be promoted to global atts?
-    for (Attribute oldAtt : g.attributes) {
-      if (g == rootGroup) {
-        gattributes.add(oldAtt);
-      } else {
-        String newName = makeFullNameWithString(g, oldAtt.getName());
-        gattributes.add(new Attribute(newName, oldAtt));
-      }
-    }
-
-    // LOOK this wont match the variables' dimensions if there are groups
-    for (Dimension oldDim : g.dimensions) {
-      if (oldDim.isShared()) {
-        if (g == rootGroup) {
-          dimensions.add(oldDim);
-        } else {
-          String newName = makeFullNameWithString(g, oldDim.getName());
-          dimensions.add(new Dimension(newName, oldDim));
-        }
-      }
-    }
-
-    List<Group> groups = g.getGroups();
-    for (Group nested : groups) {
-      finishGroup(nested);
-    }
-
-  }
-
-  protected String makeFullNameWithString(Group parent, String name) {
-    StringBuilder sbuff = new StringBuilder();
-    appendGroupName(sbuff, parent, null);
-    sbuff.append(name);
-    return sbuff.toString();
-  }
-
-  //////////////////////////////////////////////////////////////////////////////////////
-  // Service Provider calls
-  // All IO eventually goes through these calls.
-  // LOOK: these should not be public !!! not hitting variable cache
-  // used in NetcdfDataset - try to refactor
-
-  // this is for reading non-member variables
-  // section is null for full read
-
-  /*
-   * Do not call this directly, use Variable.read() !!
-   * Ranges must be filled (no nulls)
-   */
-  protected Array readData(ucar.nc2.Variable v, Section ranges) throws IOException, InvalidRangeException {
-    if (showRequest)
-      System.out.println("Data request for variable: " + v.getFullName() + " section= " + ranges);
-    if (unlocked) {
-      String info = cache.getInfo(this);
-      throw new IllegalStateException("File is unlocked - cannot use\n" + info);
-    }
-
-    if (spi == null) {
-      throw new IOException("BAD: missing spi: " + v.getFullName());
-    }
-    Array result = spi.readData(v, ranges);
-    result.setUnsigned(v.isUnsigned());
-    return result;
-  }
-
-  /**
-   * Read a variable using the given section specification.
-   * The result is always an array of the type of the innermost variable.
-   * Its shape is the accumulation of all the shapes of its parent structures.
-   *
-   * @param variableSection the constraint expression.
-   * @return data requested
-   * @throws IOException           if error
-   * @throws InvalidRangeException if variableSection is invalid
-   * @see <a href="http://www.unidata.ucar.edu/software/netcdf-java/reference/SectionSpecification.html">SectionSpecification</a>
-   */
-  public Array readSection(String variableSection) throws IOException, InvalidRangeException {
-    if (unlocked)
-      throw new IllegalStateException("File is unlocked - cannot use");
-
-    ParsedSectionSpec cer = ParsedSectionSpec.parseVariableSection(this, variableSection);
-    if (cer.child == null) {
-      Array result = cer.v.read(cer.section);
-      result.setUnsigned(cer.v.isUnsigned());
-      return result;
-    }
-
-    if (spi == null)
-      return IospHelper.readSection(cer);
-    else
-      // allow iosp to optimize
-      return spi.readSection(cer);
-  }
-
-
-  /**
-   * Read data from a top level Variable and send data to a WritableByteChannel. Experimental.
-   *
-   * @param v       a top-level Variable
-   * @param section the section of data to read.
-   *                There must be a Range for each Dimension in the variable, in order.
-   *                Note: no nulls allowed. IOSP may not modify.
-   * @param wbc     write data to this WritableByteChannel
-   * @return the number of bytes written to the channel
-   * @throws java.io.IOException            if read error
-   * @throws ucar.ma2.InvalidRangeException if invalid section
-   */
-
-  protected long readToByteChannel(ucar.nc2.Variable v, Section section, WritableByteChannel wbc)
-          throws java.io.IOException, ucar.ma2.InvalidRangeException {
-
-    if (unlocked)
-      throw new IllegalStateException("File is unlocked - cannot use");
-
-    if ((spi == null) || v.hasCachedData())
-      return IospHelper.copyToByteChannel(v.read(section), wbc);
-
-    return spi.readToByteChannel(v, section, wbc);
-  }
-
-
-  protected StructureDataIterator getStructureIterator(Structure s, int bufferSize) throws java.io.IOException {
-    return spi.getStructureIterator(s, bufferSize);
-  }
-
-  /* public long readToByteChannel(ucar.nc2.Variable v, WritableByteChannel wbc) throws java.io.IOException {
-    try {
-      return readToByteChannel(v, v.getShapeAsSection(), wbc);
-    } catch (InvalidRangeException e) {
-      throw new IllegalStateException(e);
-    }
-  } */
-
-  /*
-   * Read using a section specification and send data to a WritableByteChannel. Experimental.
-   *
-   * @param variableSection the constraint expression.
-   * @param wbc write data to this WritableByteChannel
-   * @return the number of bytes written to the channel
-   * @throws java.io.IOException if read error
-   * @throws ucar.ma2.InvalidRangeException if invalid section
-   *
-  public long readToByteChannel(String variableSection, WritableByteChannel wbc) throws IOException, InvalidRangeException {
-    ParsedSectionSpec cer = ParsedSectionSpec.parseVariableSection(this, variableSection);
-    return readToByteChannel(cer.v, cer.section, wbc);
-  } */
-
-  ///////////////////////////////////////////////////////////////////////////////////
-
-  // public I/O
-
-  /**
-   * Do a bulk read on a list of Variables and
-   * return a corresponding list of Array that contains the results
-   * of a full read on each Variable.
-   * This is mostly here so DODSNetcdf can override it with one call to the server.
-   *
-   * @param variables List of type Variable
-   * @return List of Array, one for each Variable in the input.
-   * @throws IOException if read error
-   */
-  public java.util.List<Array> readArrays(java.util.List<Variable> variables) throws IOException {
-    java.util.List<Array> result = new java.util.ArrayList<Array>();
-    for (Variable variable : variables)
-      result.add(variable.read());
-    return result;
-  }
-
-  /**
-   * Read a variable using the given section specification.
-   *
-   * @param variableSection the constraint expression.
-   * @param flatten         MUST BE TRUE
-   * @return Array data read.
-   * @throws IOException           if error
-   * @throws InvalidRangeException if variableSection is invalid
-   * @see <a href="http://www.unidata.ucar.edu/software/netcdf-java/reference/SectionSpecification.html">SectionSpecification</a>
-   * @deprecated use readSection(), flatten=false no longer supported
-   */
-  public Array read(String variableSection, boolean flatten) throws IOException, InvalidRangeException {
-    if (!flatten)
-      throw new UnsupportedOperationException("NetdfFile.read(String variableSection, boolean flatten=false)");
-    return readSection(variableSection);
-  }
-
-  /**
-   * Access to iosp debugging info.
-   *
-   * @param o must be a Variable, Dimension, Attribute, or Group
-   * @return debug info for this object.
-   */
-  protected String toStringDebug(Object o) {
-    return (spi == null) ? "" : spi.toStringDebug(o);
-  }
-
-  /**
-   * Access to iosp debugging info.
-   *
-   * @return debug / underlying implementation details
-   */
-  public String getDetailInfo() {
-    Formatter f = new Formatter();
-    getDetailInfo(f);
-    return f.toString();
-  }
-
-  public void getDetailInfo(Formatter f) {
-    f.format("NetcdfFile location= %s%n", getLocation());
-    f.format("  title= %s%n", getTitle());
-    f.format("  id= %s%n", getId());
-    f.format("  fileType= %s%n", getFileTypeId());
-    f.format("  fileDesc= %s%n", getFileTypeDescription());
-
-    f.format("  class= %s%n", getClass().getName());
-    if (spi == null) {
-      f.format("  has no IOSP%n");
-    } else {
-      f.format("  iosp= %s%n%n", spi.getClass());
-      f.format("%s", spi.getDetailInfo());
-    }
-    showCached(f);
-    showProxies(f);
-  }
-
-  protected void showCached(Formatter f) {
-    int maxNameLen = 8;
-    for (Variable v : getVariables()) {
-      maxNameLen = Math.max(maxNameLen, v.getShortName().length());
-    }
-
-    long total = 0;
-    f.format("%n%-" + maxNameLen + "s isCaching  size     cachedSize (bytes) %n", "Variable");
-    for (Variable v : getVariables()) {
-      f.format(" %-" + maxNameLen + "s %5s %8d ", v.getShortName(), v.isCaching(), v.getSize() * v.getElementSize());
-      if (v.hasCachedData()) {
-        Array data = null;
-        try {
-          data = v.read();
-        } catch (IOException e) {
-          e.printStackTrace();
-        }
-        long size = data.getSizeBytes();
-        f.format(" %8d", size);
-        total += size;
-      }
-      f.format("%n");
-    }
-    f.format(" %" + maxNameLen + "s                  --------%n", " ");
-    f.format(" %" + maxNameLen + "s                 %8d Kb total cached%n", " ", total / 1000);
-  }
-
-  protected void showProxies(Formatter f) {
-    int maxNameLen = 8;
-    boolean hasProxy = false;
-    for (Variable v : getVariables()) {
-      if (v.proxyReader != v) hasProxy = true;
-      maxNameLen = Math.max(maxNameLen, v.getShortName().length());
-    }
-    if (!hasProxy) return;
-
-    f.format("%n%-" + maxNameLen + "s  proxyReader   Variable.Class %n", "Variable");
-    for (Variable v : getVariables()) {
-      if (v.proxyReader != v)
-        f.format(" %-" + maxNameLen + "s  %s %s%n", v.getShortName(), v.proxyReader.getClass().getName(), v.getClass().getName());
-    }
-    f.format("%n");
-  }
-
-  /**
-   * DO NOT USE - public by accident
-   *
-   * @return the IOSP for this NetcdfFile
-   */
-  public IOServiceProvider getIosp() {
-    return spi;
-  }
-
-  /**
-   * Get the file type id for the underlying data source.
-   *
-   * @return registered id of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeId() {
-    if (spi != null) return spi.getFileTypeId();
-    return "N/A";
-  }
-
-  /**
-   * Get a human-readable description for this file type.
-   *
-   * @return description of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeDescription() {
-    if (spi != null) return spi.getFileTypeDescription();
-    return "N/A";
-  }
-
-
-  /**
-   * Get the version of this file type.
-   *
-   * @return version of the file type
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
-   */
-  public String getFileTypeVersion() {
-    if (spi != null) return spi.getFileTypeVersion();
-    return "N/A";
-  }
-
-  /* "safety net" use of finalize cf Bloch p 22
-  protected void finalize() throws Throwable {
-    try {
-      if (null != spi) {
-        log.warn("NetcdfFile.finalizer called on "+location+" for ncfile="+this.hashCode());
-        spi.close();
-      }
-      spi = null;
-    } finally {
-      super.finalize();
-    }
-  } */
-
-  //////////////////////////////////////////////////////////
-
-  /**
-   * debugging - do not use
-   */
-  public static void main(String[] arg) throws Exception {
-    //NetcdfFile.registerIOProvider( ucar.nc2.grib.GribServiceProvider.class);
-
-    int wide = 20;
-    Formatter f = new Formatter(System.out);
-    f.format(" %" + wide + "s %n", "test");
-    f.format(" %20s %n", "asiuasdipuasiud");
-
-    /*
-    try {
-      String filename = "R:/testdata2/hdf5/npoess/ExampleFiles/AVAFO_NPP_d2003125_t10109_e101038_b9_c2005829155458_devl_Tst.h5";
-      NetcdfFile ncfile = NetcdfFile.open(filename);
-      //Thread.currentThread().sleep( 60 * 60 * 1000); // pause to examine in profiler
-
-      ncfile.close();
-
-    } catch (Exception e) {
-      e.printStackTrace();
-    }            */
-  }
-
-}
+/*
+ * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
+ *
+ * Portions of this software were developed by the Unidata Program at the
+ * University Corporation for Atmospheric Research.
+ *
+ * Access and use of this software shall impose the following obligations
+ * and understandings on the user. The user is granted the right, without
+ * any fee or cost, to use, copy, modify, alter, enhance and distribute
+ * this software, and any derivative works thereof, and its supporting
+ * documentation for any purpose whatsoever, provided that this entire
+ * notice appears in all copies of the software, derivative works and
+ * supporting documentation.  Further, UCAR requests that the user credit
+ * UCAR/Unidata in any publications that result from the use of this
+ * software or in any product that includes this software. The names UCAR
+ * and/or Unidata, however, may not be used in any advertising or publicity
+ * to endorse or promote any products or commercial entity unless specific
+ * written permission is obtained from UCAR/Unidata. The user also
+ * understands that UCAR/Unidata is not obligated to provide the user with
+ * any support, consulting, training or assistance of any kind with regard
+ * to the use, operation and performance of this software nor to provide
+ * the user with any updates, revisions, new versions or "bug fixes."
+ *
+ * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+package ucar.nc2;
+
+import ucar.unidata.util.EscapeStrings;
+import ucar.ma2.*;
+import ucar.unidata.io.UncompressInputStream;
+import ucar.unidata.io.InMemoryRandomAccessFile;
+import ucar.unidata.io.bzip2.CBZip2InputStream;
+import ucar.nc2.util.DiskCache;
+import ucar.nc2.util.CancelTask;
+import ucar.nc2.util.IO;
+import ucar.nc2.iosp.netcdf3.N3header;
+import ucar.nc2.iosp.netcdf3.N3iosp;
+import ucar.nc2.iosp.netcdf3.SPFactory;
+import ucar.nc2.iosp.IOServiceProvider;
+import ucar.nc2.iosp.IospHelper;
+import ucar.unidata.util.StringUtil;
+
+import java.util.*;
+import java.util.zip.ZipInputStream;
+import java.util.zip.GZIPInputStream;
+import java.net.URL;
+import java.net.URI;
+import java.io.*;
+import java.nio.channels.WritableByteChannel;
+import java.nio.channels.FileLock;
+import java.nio.channels.OverlappingFileLockException;
+
+/**
+ * Read-only scientific datasets that are accessible through the netCDF API.
+ * Immutable after setImmutable() is called. However, reading data is not thread-safe.
+ * <p> Be sure to close the file when done, best practice is to enclose in a try/finally block:
+ * <pre>
+ * NetcdfFile ncfile = null;
+ * try {
+ *  ncfile = NetcdfFile.open(fileName);
+ *  ...
+ * } finally {
+ *  ncfile.close();
+ * }
+ * </pre>
+ * <p/>
+ * <h3>Naming</h3>
+ * Each object has a name (aka "full name") that is unique within the entire netcdf file, and
+ * a "short name" that is unique within the parent group.
+ * These coincide for objects in the root group, and so are backwards compatible with version 3 files.
+ * <ol>
+ * <li>Variable: group1/group2/varname
+ * <li>Structure member Variable: group1/group2/varname.s1.s2
+ * <li>Group Attribute: group1/group2@attName
+ * <li>Variable Attribute: group1/group2/varName@attName
+ * </ol>
+ *
+ * @author caron
+ */
+
+public class NetcdfFile implements ucar.nc2.util.cache.FileCacheable {
+  static public final String IOSP_MESSAGE_ADD_RECORD_STRUCTURE = "AddRecordStructure";
+  static public final String IOSP_MESSAGE_CONVERT_RECORD_STRUCTURE = "ConvertRecordStructure"; // not implemented yet
+  static public final String IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE = "RemoveRecordStructure";
+  static public final String IOSP_MESSAGE_RANDOM_ACCESS_FILE = "RandomAccessFile";
+
+  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(NetcdfFile.class);
+
+  static private int default_buffersize = 8092;
+  static private ArrayList<IOServiceProvider> registeredProviders = new ArrayList<IOServiceProvider>();
+  static protected boolean debugSPI = false, debugCompress = false, showRequest = false;
+  static boolean debugStructureIterator = false;
+  static boolean loadWarnings = false;
+
+  static private boolean userLoads = false;
+
+  // IOSPs are loaded by reflection
+  static {
+    try {
+      registerIOProvider("ucar.nc2.stream.NcStreamIosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.hdf5.H5iosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.hdf4.H4iosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      NetcdfFile.class.getClassLoader().loadClass("ucar.grib.grib2.Grib2Input"); // only load if grib.jar is present
+      registerIOProvider("ucar.nc2.iosp.grib.GribGridServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      NetcdfFile.class.getClassLoader().loadClass("ucar.grib.grib2.Grib2Input"); // only load if grib.jar is present
+      NetcdfFile.class.getClassLoader().loadClass("visad.util.Trace"); // only load if visad.jar is present
+      registerIOProvider("ucar.nc2.iosp.gempak.GempakGridServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      Class iosp = NetcdfFile.class.getClassLoader().loadClass("ucar.nc2.iosp.bufr.BufrIosp"); // only load if bufr.jar is present
+      registerIOProvider(iosp);
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load resource: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.nexrad2.Nexrad2IOServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.nids.Nidsiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.nowrad.NOWRadiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.dorade.Doradeiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.dmsp.DMSPiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.cinrad.Cinrad2IOServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.misc.GtopoIosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.misc.NmcObsLegacy");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.gini.Giniiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.uf.UFiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.misc.Uspln");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.misc.Nldn");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.fysat.Fysatiosp");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.uamiv.UAMIVServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      NetcdfFile.class.getClassLoader().loadClass("edu.wisc.ssec.mcidas.AreaFile"); // only load if visad.jar is present
+      registerIOProvider("ucar.nc2.iosp.mcidas.AreaServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      NetcdfFile.class.getClassLoader().loadClass("visad.util.Trace"); // only load if visad.jar is present
+      registerIOProvider("ucar.nc2.iosp.gempak.GempakSurfaceIOSP");
+      registerIOProvider("ucar.nc2.iosp.gempak.GempakSoundingIOSP");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      NetcdfFile.class.getClassLoader().loadClass("edu.wisc.ssec.mcidas.GridDirectory"); // only load if visad.jar is present
+      registerIOProvider("ucar.nc2.iosp.mcidas.McIDASGridServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.noaa.Ghcnm2");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.noaa.IgraPor");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+    try {
+      registerIOProvider("ucar.nc2.iosp.grads.GradsBinaryGridServiceProvider");
+    } catch (Throwable e) {
+      if (loadWarnings) log.info("Cant load class: " + e);
+    }
+
+    userLoads = true;
+  }
+
+  ///////////////////////////////////////////////////////////////////////
+
+  /**
+   * Create a valid CDM object name.
+   * Control chars (< 0x20) are not allowed.
+   * Trailing and leading blanks are not allowed and are stripped off.
+   * A forward slash "/" is converted into an underscore "_".
+   *
+   * @param name from this name
+   * @return valid CDM object name
+   */
+  static public String makeValidCdmObjectName(String name) {
+    return StringUtil.makeValidCdmObjectName(name);
+    //return StringUtil.replace(name.trim(), "/", "_");
+  }
+
+  /*
+   * The set of characters in a netcdf object name that are escaped for the "escaped name".
+   */
+  static public final String reserved = ".\\";
+  static public final String reservedSectionSpec = "();,.\\";
+  static public final String reservedCdl = "[ !\"#$%&'()*,:;<=>?[]^`{|}~.\\";
+
+  /**
+   * Escape standard special characters in a netcdf object name.
+   *
+   * @param vname the name
+   * @return escaped version of it
+   */
+  public static String escapeName(String vname) {
+    return EscapeStrings.backslashEscape(vname, NetcdfFile.reserved);
+  }
+
+  /**
+   * Escape special characters in a netcdf object name for CDL.
+   *
+   * @param vname the name
+   * @return escaped version of it
+   */
+  public static String escapeNameCDL(String vname) {
+    return EscapeStrings.backslashEscape(vname, reservedCdl);
+  }
+
+  /**
+   * Escape special characters in a netcdf object name for SectionSpec.
+   *
+   * @param vname the name
+   * @return escaped version of it
+   */
+  public static String escapeNameSectionSpec(String vname) {
+    return EscapeStrings.backslashEscape(vname, reservedSectionSpec);
+  }
+
+  /**
+   * Unescape any escaped characters in a name.
+   *
+   * @param vname the escaped name
+   * @return unescaped version of it
+   */
+  public static String unescapeName(String vname) {
+    return EscapeStrings.backslashUnescape(vname);
+  }
+
+  static protected String makeFullName(Variable v) {
+    return makeFullName(v, null);
+  }
+
+  static protected String makeFullNameEscaped(Variable v) {
+    return makeFullName(v, reserved);
+  }
+
+  static protected String makeFullNameEscapedSectionSpec(Variable v) {
+    return makeFullName(v, reservedSectionSpec);
+  }
+
+  static protected String makeFullName(Variable v, String reserved) {
+    Group parent = v.getParentGroup();
+    if (((parent == null) || parent.isRoot()) && !v.isMemberOfStructure()) return v.getShortName(); // common case
+
+    StringBuilder sbuff = new StringBuilder();
+    appendGroupName(sbuff, parent, reserved);
+    appendStructureName(sbuff, v, reserved);
+    return sbuff.toString();
+  }
+
+  static private void appendGroupName(StringBuilder sbuff, Group g, String reserved) {
+    boolean isRoot = g.getParentGroup() == null;
+    if (isRoot) return;
+
+    if (g.getParentGroup() != null)
+      appendGroupName(sbuff, g.getParentGroup(), reserved);
+    sbuff.append( EscapeStrings.backslashEscape(g.getShortName(), reserved));
+    sbuff.append("/");
+  }
+
+  static private void appendStructureName(StringBuilder sbuff, Variable v, String reserved) {
+    if (v.isMemberOfStructure()) {
+      appendStructureName(sbuff, v.getParentStructure(), reserved);
+      sbuff.append(".");
+    }
+    sbuff.append( EscapeStrings.backslashEscape(v.getShortName(), reserved));
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////////
+
+  /**
+   * Register an IOServiceProvider, using its class string name.
+   *
+   * @param className Class that implements IOServiceProvider.
+   * @throws IllegalAccessException if class is not accessible.
+   * @throws InstantiationException if class doesnt have a no-arg constructor.
+   * @throws ClassNotFoundException if class not found.
+   */
+  static public void registerIOProvider(String className) throws IllegalAccessException, InstantiationException, ClassNotFoundException {
+    Class ioClass = NetcdfFile.class.getClassLoader().loadClass(className);
+    registerIOProvider(ioClass);
+  }
+
+  /**
+   * Register an IOServiceProvider. A new instance will be created when one of its files is opened.
+   *
+   * @param iospClass Class that implements IOServiceProvider.
+   * @throws IllegalAccessException if class is not accessible.
+   * @throws InstantiationException if class doesnt have a no-arg constructor.
+   * @throws ClassCastException     if class doesnt implement IOServiceProvider interface.
+   */
+  static public void registerIOProvider(Class iospClass) throws IllegalAccessException, InstantiationException {
+    IOServiceProvider spi;
+    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast
+
+    if (userLoads) registeredProviders.add(0, spi);  // put user stuff first
+    else registeredProviders.add(spi);
+  }
+
+  /**
+   * debugging
+   *
+   * @param debugFlag debug flags
+   */
+  static public void setDebugFlags(ucar.nc2.util.DebugFlags debugFlag) {
+    debugSPI = debugFlag.isSet("NetcdfFile/debugSPI");
+    debugCompress = debugFlag.isSet("NetcdfFile/debugCompress");
+    debugStructureIterator = debugFlag.isSet("NetcdfFile/structureIterator");
+    N3header.disallowFileTruncation = debugFlag.isSet("NetcdfFile/disallowFileTruncation");
+    N3header.debugHeaderSize = debugFlag.isSet("NetcdfFile/debugHeaderSize");
+    showRequest = debugFlag.isSet("NetcdfFile/showRequest");
+  }
+
+  /**
+   * debugging
+   * @param printStream write to this stream.
+   *
+  static public void setDebugOutputStream(PrintStream printStream) {
+  ucar.nc2.iosp.hdf5.H5iosp.setDebugOutputStream(printStream);
+  } */
+
+  /**
+   * Set properties. Currently recognized:
+   * "syncExtendOnly", "true" or "false" (default).  if true, can only extend file on a sync.
+   *
+   * @param name  name of property
+   * @param value value of property
+   */
+  static public void setProperty(String name, String value) {
+    N3iosp.setProperty(name, value);
+  }
+
+  /**
+   * Open an existing netcdf file (read only).
+   *
+   * @param location location of file.
+   * @return the NetcdfFile.
+   * @throws java.io.IOException if error
+   */
+  public static NetcdfFile open(String location) throws IOException {
+    return open(location, null);
+  }
+
+  public static NetcdfFile open(ucar.unidata.io.RandomAccessFile raf, String location) throws IOException {
+    return open(raf, location, null, null);
+  }
+
+  /**
+   * Open an existing file (read only), with option of cancelling.
+   *
+   * @param location   location of the file.
+   * @param cancelTask allow task to be cancelled; may be null.
+   * @return NetcdfFile object, or null if cant find IOServiceProver
+   * @throws IOException if error
+   */
+  static public NetcdfFile open(String location, ucar.nc2.util.CancelTask cancelTask) throws IOException {
+    return open(location, -1, cancelTask);
+  }
+
+  /**
+   * Open an existing file (read only), with option of cancelling, setting the RandomAccessFile buffer size for efficiency.
+   *
+   * @param location    location of file.
+   * @param buffer_size RandomAccessFile buffer size, if <= 0, use default size
+   * @param cancelTask  allow task to be cancelled; may be null.
+   * @return NetcdfFile object, or null if cant find IOServiceProver
+   * @throws IOException if error
+   */
+  static public NetcdfFile open(String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask) throws IOException {
+    return open(location, buffer_size, cancelTask, null);
+  }
+
+  /**
+   * Open an existing file (read only), with option of cancelling, setting the RandomAccessFile buffer size for efficiency,
+   * with an optional special object for the iosp.
+   *
+   * @param location    location of file. This may be a
+   *                    <ol>
+   *                    <li>local netcdf-3 filename (with a file: prefix or no prefix)
+   *                    <li>remote netcdf-3 filename (with an http: prefix)
+   *                    <li>local netcdf-4 filename (with a file: prefix or no prefix)
+   *                    <li>local hdf-5 filename (with a file: prefix or no prefix)
+   *                    <li>local iosp filename (with a file: prefix or no prefix)
+   *                    </ol>
+   *                    If file ends with ".Z", ".zip", ".gzip", ".gz", or ".bz2", it will uncompress/unzip and write to new file without the suffix,
+   *                    then use the uncompressed file. It will look for the uncompressed file before it does any of that. Generally it prefers to
+   *                    place the uncompressed file in the same directory as the original file. If it does not have write permission on that directory,
+   *                    it will use the directory defined by ucar.nc2.util.DiskCache class.
+   * @param buffer_size RandomAccessFile buffer size, if <= 0, use default size
+   * @param cancelTask  allow task to be cancelled; may be null.
+   * @param iospMessage special iosp tweaking (sent before open is called), may be null
+   * @return NetcdfFile object, or null if cant find IOServiceProver
+   * @throws IOException if error
+   */
+  static public NetcdfFile open(String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask, Object iospMessage) throws IOException {
+
+    ucar.unidata.io.RandomAccessFile raf = getRaf(location, buffer_size);
+
+    try {
+      return open(raf, location, cancelTask, iospMessage);
+    } catch (IOException ioe) {
+      raf.close();
+      throw ioe;
+    }
+  }
+
+  /**
+   * Find out if the file can be opened, but dont actually open it.
+   *
+   * @param location same as open
+   * @return true if can be opened
+   * @throws IOException on read error
+   */
+  static public boolean canOpen(String location) throws IOException {
+    ucar.unidata.io.RandomAccessFile raf = null;
+    try {
+      raf = getRaf(location, -1);
+      return (raf != null) ? canOpen(raf) : false;
+    } finally {
+      if (raf != null) raf.close();
+    }
+  }
+
+  private static boolean canOpen(ucar.unidata.io.RandomAccessFile raf) throws IOException {
+    if (N3header.isValidFile(raf)) {
+      return true;
+    } else {
+      for (IOServiceProvider registeredSpi : registeredProviders) {
+        if (registeredSpi.isValidFile(raf))
+          return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Open an existing file (read only), specifying which IOSP is to be used.
+   *
+   * @param location      location of file
+   * @param iospClassName fully qualified class name of the IOSP class to handle this file
+   * @param bufferSize    RandomAccessFile buffer size, if <= 0, use default size
+   * @param cancelTask    allow task to be cancelled; may be null.
+   * @param iospMessage   special iosp tweaking (sent before open is called), may be null
+   * @return NetcdfFile object, or null if cant find IOServiceProver
+   * @throws IOException            if read error
+   * @throws ClassNotFoundException cannat find iospClassName in thye class path
+   * @throws InstantiationException if class cannot be instantiated
+   * @throws IllegalAccessException if class is not accessible
+   */
+  static public NetcdfFile open(String location, String iospClassName, int bufferSize, CancelTask cancelTask, Object iospMessage)
+          throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {
+
+    Class iospClass = NetcdfFile.class.getClassLoader().loadClass(iospClassName);
+    IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance(); // fail fast
+
+    // send before iosp is opened
+    if (iospMessage != null)
+      spi.sendIospMessage(iospMessage);
+
+    // get rid of file prefix, if any
+    String uriString = location.trim();
+    if (uriString.startsWith("file://"))
+      uriString = uriString.substring(7);
+    else if (uriString.startsWith("file:"))
+      uriString = uriString.substring(5);
+
+    // get rid of crappy microsnot \ replace with happy /
+    uriString = StringUtil.replace(uriString, '\\', "/");
+
+    if (bufferSize <= 0)
+      bufferSize = default_buffersize;
+    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.RandomAccessFile(uriString, "r", bufferSize);
+
+    NetcdfFile result = new NetcdfFile(spi, raf, location, cancelTask);
+
+    // send after iosp is opened
+    if (iospMessage != null)
+      spi.sendIospMessage(iospMessage);
+
+    return result;
+  }
+
+  static private ucar.unidata.io.RandomAccessFile getRaf(String location, int buffer_size) throws IOException {
+
+    String uriString = location.trim();
+
+    if (buffer_size <= 0)
+      buffer_size = default_buffersize;
+
+    ucar.unidata.io.RandomAccessFile raf;
+    if (uriString.startsWith("http:")) { // open through URL
+      raf = new ucar.unidata.io.http.HTTPRandomAccessFile(uriString);
+
+    } else if (uriString.startsWith("nodods:")) { // open through URL
+      uriString = "http" + uriString.substring(6);
+      raf = new ucar.unidata.io.http.HTTPRandomAccessFile(uriString);
+
+    } else if (uriString.startsWith("slurp:")) { // open through URL
+      uriString = "http" + uriString.substring(5);
+      byte[] contents = IO.readURLContentsToByteArray(uriString); // read all into memory
+      raf = new InMemoryRandomAccessFile(uriString, contents);
+
+    } else {
+      // get rid of crappy microsnot \ replace with happy /
+      uriString = StringUtil.replace(uriString, '\\', "/");
+
+      if (uriString.startsWith("file:")) {
+        // uriString = uriString.substring(5);
+        uriString = StringUtil.unescape(uriString.substring(5));  // 11/10/2010 from erussell@ngs.org
+      }
+
+      String uncompressedFileName = null;
+      try {
+        uncompressedFileName = makeUncompressed(uriString);
+      } catch (Exception e) {
+        log.warn("Failed to uncompress " + uriString + " err= " + e.getMessage() + "; try as a regular file.");
+        //allow to fall through to open the "compressed" file directly - may be a misnamed suffix
+      }
+
+      if (uncompressedFileName != null) {
+        // open uncompressed file as a RandomAccessFile.
+        raf = new ucar.unidata.io.RandomAccessFile(uncompressedFileName, "r", buffer_size);
+        //raf = new ucar.unidata.io.MMapRandomAccessFile(uncompressedFileName, "r");
+
+      } else {
+        // normal case - not compressed
+        raf = new ucar.unidata.io.RandomAccessFile(uriString, "r", buffer_size);
+        //raf = new ucar.unidata.io.MMapRandomAccessFile(uriString, "r");
+      }
+    }
+
+    return raf;
+  }
+
+  static private String makeUncompressed(String filename) throws Exception {
+    // see if its a compressed file
+    int pos = filename.lastIndexOf('.');
+    if (pos < 0) return null;
+
+    String suffix = filename.substring(pos + 1);
+    String uncompressedFilename = filename.substring(0, pos);
+
+    if (!suffix.equalsIgnoreCase("Z") && !suffix.equalsIgnoreCase("zip") && !suffix.equalsIgnoreCase("gzip")
+            && !suffix.equalsIgnoreCase("gz") && !suffix.equalsIgnoreCase("bz2"))
+      return null;
+
+    // see if already decompressed, look in cache if need be
+    File uncompressedFile = DiskCache.getFileStandardPolicy(uncompressedFilename);
+    if (uncompressedFile.exists() && uncompressedFile.length() > 0) {
+      // see if its locked - another thread is writing it
+      FileInputStream stream = null;
+      FileLock lock = null;
+      try {
+        stream = new FileInputStream(uncompressedFile);
+        // obtain the lock
+        while (true) { // loop waiting for the lock
+          try {
+            lock = stream.getChannel().lock(0, 1, true); // wait till its unlocked
+            break;
+
+          } catch (OverlappingFileLockException oe) { // not sure why lock() doesnt block
+            try {
+              Thread.sleep(100); // msecs
+            } catch (InterruptedException e1) {
+              break;
+            }
+          }
+        }
+
+        if (debugCompress) System.out.println("found uncompressed " + uncompressedFile + " for " + filename);
+        return uncompressedFile.getPath();
+      } finally {
+        if (lock != null) lock.release();
+        if (stream != null) stream.close();
+      }
+    }
+
+    // ok gonna write it
+    // make sure compressed file exists
+    File file = new File(filename);
+    if (!file.exists())
+      return null; // bail out  */
+
+    InputStream in = null;
+    FileOutputStream fout = new FileOutputStream(uncompressedFile);
+
+    // obtain the lock
+    FileLock lock = null;
+    while (true) { // loop waiting for the lock
+      try {
+        lock = fout.getChannel().lock(0, 1, false);
+        break;
+
+      } catch (OverlappingFileLockException oe) { // not sure why lock() doesnt block
+        try {
+          Thread.sleep(100); // msecs
+        } catch (InterruptedException e1) {
+        }
+      }
+    }
+
+    try {
+      if (suffix.equalsIgnoreCase("Z")) {
+        in = new UncompressInputStream(new FileInputStream(filename));
+        copy(in, fout, 100000);
+        if (debugCompress) System.out.println("uncompressed " + filename + " to " + uncompressedFile);
+
+      } else if (suffix.equalsIgnoreCase("zip")) {
+        in = new ZipInputStream(new FileInputStream(filename));
+        copy(in, fout, 100000);
+        if (debugCompress) System.out.println("unzipped " + filename + " to " + uncompressedFile);
+
+      } else if (suffix.equalsIgnoreCase("bz2")) {
+        in = new CBZip2InputStream(new FileInputStream(filename), true);
+        copy(in, fout, 100000);
+        if (debugCompress) System.out.println("unbzipped " + filename + " to " + uncompressedFile);
+
+      } else if (suffix.equalsIgnoreCase("gzip") || suffix.equalsIgnoreCase("gz")) {
+
+        in = new GZIPInputStream(new FileInputStream(filename));
+        copy(in, fout, 100000);
+
+        if (debugCompress) System.out.println("ungzipped " + filename + " to " + uncompressedFile);
+      }
+    } catch (Exception e) {
+
+      // appears we have to close before we can delete
+      if (fout != null) fout.close();
+      fout = null;
+
+      // dont leave bad files around
+      if (uncompressedFile.exists()) {
+        if (!uncompressedFile.delete())
+          log.warn("failed to delete uncompressed file (IOException)" + uncompressedFile);
+      }
+      throw e;
+
+    } finally {
+      if (lock != null) lock.release();
+      if (in != null) in.close();
+      if (fout != null) fout.close();
+    }
+
+    return uncompressedFile.getPath();
+  }
+
+  static private void copy(InputStream in, OutputStream out, int bufferSize) throws IOException {
+    byte[] buffer = new byte[bufferSize];
+    while (true) {
+      int bytesRead = in.read(buffer);
+      if (bytesRead == -1) break;
+      out.write(buffer, 0, bytesRead);
+    }
+  }
+
+  /**
+   * Open an in-memory netcdf file, with a specific iosp.
+   *
+   * @param name          name of the dataset. Typically use the filename or URI.
+   * @param data          in-memory netcdf file
+   * @param iospClassName fully qualified class name of the IOSP class to handle this file
+   * @return NetcdfFile object, or null if cant find IOServiceProver
+   * @throws IOException            if read error
+   * @throws ClassNotFoundException cannat find iospClassName in the class path
+   * @throws InstantiationException if class cannot be instantiated
+   * @throws IllegalAccessException if class is not accessible
+   */
+  public static NetcdfFile openInMemory(String name, byte[] data, String iospClassName) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {
+
+    ucar.unidata.io.InMemoryRandomAccessFile raf = new ucar.unidata.io.InMemoryRandomAccessFile(name, data);
+    Class iospClass = NetcdfFile.class.getClassLoader().loadClass(iospClassName);
+    IOServiceProvider spi = (IOServiceProvider) iospClass.newInstance();
+
+    return new NetcdfFile(spi, raf, name, null);
+  }
+
+  /**
+   * Open an in-memory netcdf file.
+   *
+   * @param name name of the dataset. Typically use the filename or URI.
+   * @param data in-memory netcdf file
+   * @return memory-resident NetcdfFile
+   * @throws java.io.IOException if error
+   */
+  public static NetcdfFile openInMemory(String name, byte[] data) throws IOException {
+    ucar.unidata.io.InMemoryRandomAccessFile raf = new ucar.unidata.io.InMemoryRandomAccessFile(name, data);
+    return open(raf, name, null, null);
+  }
+
+  /**
+   * Read a local CDM file into memory. All reads are then done from memory.
+   *
+   * @param filename location of CDM file, must be a local file.
+   * @return a NetcdfFile, which is completely in memory
+   * @throws IOException if error reading file
+   */
+  public static NetcdfFile openInMemory(String filename) throws IOException {
+    File file = new File(filename);
+    ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length());
+    InputStream in = new BufferedInputStream(new FileInputStream(filename));
+    IO.copy(in, bos);
+    return openInMemory(filename, bos.toByteArray());
+  }
+
+  /**
+   * Read a remote CDM file into memory. All reads are then done from memory.
+   *
+   * @param uri location of CDM file, must be accessible through uri.toURL().openStream().
+   * @return a NetcdfFile, which is completely in memory
+   * @throws IOException if error reading file
+   */
+  public static NetcdfFile openInMemory(URI uri) throws IOException {
+    URL url = uri.toURL();
+    byte[] contents = IO.readContentsToByteArray(url.openStream());
+    return openInMemory(uri.toString(), contents);
+  }
+
+  private static NetcdfFile open(ucar.unidata.io.RandomAccessFile raf, String location, ucar.nc2.util.CancelTask cancelTask,
+                                 Object iospMessage) throws IOException {
+
+    IOServiceProvider spi = null;
+    if (debugSPI) System.out.println("NetcdfFile try to open = " + location);
+
+    // avoid opening file more than once, so pass around the raf.
+    if (N3header.isValidFile(raf)) {
+      spi = SPFactory.getServiceProvider();
+
+      //} else if (H5header.isValidFile(raf)) {
+      // spi = new ucar.nc2.iosp.hdf5.H5iosp();
+
+    } else {
+      // look for registered providers
+      for (IOServiceProvider registeredSpi : registeredProviders) {
+        if (debugSPI) System.out.println(" try iosp = " + registeredSpi.getClass().getName());
+
+        if (registeredSpi.isValidFile(raf)) {
+          // need a new instance for thread safety
+          Class c = registeredSpi.getClass();
+          try {
+            spi = (IOServiceProvider) c.newInstance();
+          } catch (InstantiationException e) {
+            throw new IOException("IOServiceProvider " + c.getName() + "must have no-arg constructor."); // shouldnt happen
+          } catch (IllegalAccessException e) {
+            throw new IOException("IOServiceProvider " + c.getName() + " IllegalAccessException: " + e.getMessage()); // shouldnt happen
+          }
+          break;
+        }
+      }
+    }
+
+    if (spi == null) {
+      raf.close();
+      throw new IOException("Cant read " + location + ": not a valid CDM file.");
+    }
+
+    // send before iosp is opened
+    if (iospMessage != null)
+      spi.sendIospMessage(iospMessage);
+
+    if (log.isDebugEnabled())
+      log.debug("Using IOSP " + spi.getClass().getName());
+
+    NetcdfFile result = new NetcdfFile(spi, raf, location, cancelTask);
+
+    // send after iosp is opened
+    if (iospMessage != null)
+      spi.sendIospMessage(iospMessage);
+
+    return result;
+  }
+
+  ////////////////////////////////////////////////////////////////////////////////////////////////
+  protected String location, id, title, cacheName;
+  protected Group rootGroup = makeRootGroup();
+  protected boolean unlocked = false; // in the cache but not locked
+  private boolean immutable = false;
+
+  protected ucar.nc2.util.cache.FileCache cache;
+  protected IOServiceProvider spi;
+
+  // "global view" is derived from the group information.
+  protected List<Variable> variables;
+  protected List<Dimension> dimensions;
+  protected List<Attribute> gattributes;
+
+  /*
+   * Is the dataset closed, and not available for use.
+   * @return true if closed
+   */
+  public synchronized boolean isUnlocked() {
+    return unlocked;
+  }
+
+  /**
+   * Close all resources (files, sockets, etc) associated with this file.
+   * If the underlying file was acquired, it will be released, otherwise closed.
+   * if isClosed() already, nothing will happen
+   *
+   * @throws java.io.IOException if error when closing
+   */
+  public synchronized void close() throws java.io.IOException {
+    if (cache != null) {
+      unlocked = true;
+      cache.release(this);
+
+    } else {
+      try {
+        if (null != spi) {
+          // log.warn("NetcdfFile.close called for ncfile="+this.hashCode()+" for iosp="+spi.hashCode());
+          spi.close();
+        }
+      } finally {
+        spi = null;
+      }
+    }
+  }
+
+  /**
+   * Public by accident.
+   * Optional file caching.
+   */
+  public void setFileCache(ucar.nc2.util.cache.FileCache cache) {
+    this.cache = cache;
+  }
+
+  /**
+   * Public by accident.
+   * Get the name used in the cache, if any.
+   *
+   * @return name in the cache.
+   */
+  public String getCacheName() {
+    return cacheName;
+  }
+
+  /**
+   * Public by accident.
+   *
+   * @param cacheName name in the cache, should be unique for this NetcdfFile. Usually the location.
+   */
+  protected void setCacheName(String cacheName) {
+    this.cacheName = cacheName;
+  }
+
+  /**
+   * Get the NetcdfFile location. This is a URL, or a file pathname.
+   *
+   * @return location URL or file pathname.
+   */
+  public String getLocation() {
+    return location;
+  }
+
+  /**
+   * Get the globally unique dataset identifier, if it exists.
+   *
+   * @return id, or null if none.
+   */
+  public String getId() {
+    return id;
+  }
+
+  /**
+   * Get the human-readable title, if it exists.
+   *
+   * @return title, or null if none.
+   */
+  public String getTitle() {
+    return title;
+  }
+
+  /**
+   * Get the root group.
+   *
+   * @return root group
+   */
+  public Group getRootGroup() {
+    return rootGroup;
+  }
+
+  /**
+   * Get all of the variables in the file, in all groups.
+   * This is part of "version 3 compatibility" interface.
+   * Alternatively, use groups.
+   *
+   * @return List of type Variable.
+   */
+  public java.util.List<Variable> getVariables() {
+    return variables;
+  }
+
+  /*
+   * Retrieve the Variable with the specified (full) name, which is not a member of a Structure.
+   *
+   * @param name full name, starting from root group.
+   * @return the Variable, or null if not found
+   *
+  public Variable findTopVariable(String name) {
+    if (name == null) return null;
+
+    for (Variable v : variables) {
+      if (name.equals(v.getName()))
+        return v;
+    }
+    return null;
+  } */
+
+  /**
+   * Find a Group, with the specified (full) name.
+   * An embedded "/" is interpreted as separating group names.
+   *
+   * @param fullName eg "/group/subgroup/wantGroup". Null or empty string returns the root group.
+   * @return Group or null if not found.
+   */
+  public Group findGroup(String fullName) {
+    if (fullName == null || fullName.length() == 0)
+      return rootGroup;
+
+    Group g = rootGroup;
+    String[] groupNames = fullName.split("/");
+    for (String groupName : groupNames) {
+      g = g.findGroup(groupName);
+      if (g == null) return null;
+    }
+    return g;
+  }
+
+  /**
+   * Find a Variable, with the specified (escaped full) name.
+   * It may possibly be nested in multiple groups and/or structures.
+   * An embedded "." is interpreted as structure.member.
+   * An embedded "/" is interpreted as group/variable.
+   * If the name actually has a ".", you must escape it (call NetcdfFile.escapeName(varname))
+   * Any other chars may also be escaped, as they are removed before testing.
+   *
+   * @param fullNameEscaped eg "/group/subgroup/name1.name2.name".
+   * @return Variable or null if not found.
+   * @see NetcdfFile#escapeName
+   * @see NetcdfFile#unescapeName
+   */
+  public Variable findVariable(String fullNameEscaped) {
+    if (fullNameEscaped == null || fullNameEscaped.length() == 0) {
+      return null;
+    }
+
+    Group g = rootGroup;
+    String vars = fullNameEscaped;
+
+    // break into group/group and var.var
+    int pos = fullNameEscaped.lastIndexOf('/');
+    if (pos >= 0) {
+      String groups = fullNameEscaped.substring(0, pos);
+      vars = fullNameEscaped.substring(pos + 1);
+      StringTokenizer stoke = new StringTokenizer(groups, "/");
+      while (stoke.hasMoreTokens()) {
+        String token = NetcdfFile.unescapeName( stoke.nextToken());
+        g = g.findGroup(token);
+        if (g == null) return null;
+      }
+    }
+
+    // heres var.var - tokenize respecting the possible escaped '.'
+    List<String> snames = EscapeStrings.tokenizeEscapedName(vars);
+    if (snames.size() == 0) return null;
+
+    String varShortName = NetcdfFile.unescapeName(snames.get(0));
+    Variable v = g.findVariable(varShortName);
+    if (v == null) return null;
+
+    int memberCount = 1;
+    while (memberCount < snames.size()) {
+      if (!(v instanceof Structure)) return null;
+      String name = NetcdfFile.unescapeName(snames.get(memberCount++));
+      v = ((Structure) v).findVariable(name);
+      if (v == null) return null;
+    }
+    return v;
+  }
+
+  /**
+   * Get the shared Dimensions used in this file.
+   * This is part of "version 3 compatibility" interface.
+   * <p> If the dimensions are in a group, the dimension name will have the
+   * group name, in order to disambiguate the dimensions. This means that
+   * a Variable's dimensions will not match Dimensions in this list.
+   * Therefore it is better to get the shared Dimensions directly from the Groups.
+   *
+   * @return List of type Dimension.
+   */
+  public List<Dimension> getDimensions() {
+    return immutable ? dimensions : new ArrayList<Dimension>(dimensions);
+  }
+
+  /**
+   * Retrieve a dimension by fullName.
+   *
+   * @param name dimension full name, (using parent group names if not in the root group)
+   * @return the dimension, or null if not found
+   */
+  public Dimension findDimension(String name) {
+    if (name == null) return null;
+    for (Dimension d : dimensions) {
+      if (name.equals(d.getName()))
+        return d;
+    }
+    return null;
+  }
+
+  /**
+   * Return true if this file has one or more unlimited (record) dimension.
+   *
+   * @return if this file has an unlimited Dimension(s)
+   */
+  public boolean hasUnlimitedDimension() {
+    return getUnlimitedDimension() != null;
+  }
+
+  /**
+   * Return true if this file supports querying for locality information.
+   * @return if the file can return locality information
+   * @throws IOException if there is not an IOServiceProvider set
+   */
+  public boolean supportsLocalityInformation() throws IOException {
+    if (spi == null) {
+      throw new IOException("spi is null");
+    }
+
+    return spi.supportsLocalityInformation();
+  }
+
+  /**
+   * Return the unlimited (record) dimension, or null if not exist.
+   * If there are multiple unlimited dimensions, it will return the first one.
+   *
+   * @return the unlimited Dimension, or null if none.
+   */
+  public Dimension getUnlimitedDimension() {
+    for (Dimension d : dimensions) {
+      if (d.isUnlimited()) return d;
+    }
+    return null;
+  }
+
+  /**
+   * Returns the set of global attributes associated with this file.
+   * This is part of "version 3 compatibility" interface.
+   * Alternatively, use groups.
+   *
+   * @return List of type Attribute
+   */
+  public java.util.List<Attribute> getGlobalAttributes() {
+    return immutable ? gattributes : new ArrayList<Attribute>(gattributes);
+  }
+
+  /**
+   * Look up global Attribute by (full) name.
+   *
+   * @param name the name of the attribute
+   * @return the attribute, or null if not found
+   */
+  public Attribute findGlobalAttribute(String name) {
+    for (Attribute a : gattributes) {
+      if (name.equals(a.getName()))
+        return a;
+    }
+    return null;
+  }
+
+  /**
+   * Look up global Attribute by name, ignore case.
+   *
+   * @param name the name of the attribute
+   * @return the attribute, or null if not found
+   */
+  public Attribute findGlobalAttributeIgnoreCase(String name) {
+    for (Attribute a : gattributes) {
+      if (name.equalsIgnoreCase(a.getName()))
+        return a;
+    }
+    return null;
+  }
+
+  /**
+   * Find a String-valued global or variable Attribute by
+   * Attribute name (ignore case), return the Value of the Attribute.
+   * If not found return defaultValue
+   *
+   * @param v            the variable or null for global attribute
+   * @param attName      the (full) name of the attribute, case insensitive
+   * @param defaultValue return this if attribute not found
+   * @return the attribute value, or defaultValue if not found
+   */
+  public String findAttValueIgnoreCase(Variable v, String attName, String defaultValue) {
+    String attValue = null;
+    Attribute att;
+
+    if (v == null)
+      att = rootGroup.findAttributeIgnoreCase(attName);
+    else
+      att = v.findAttributeIgnoreCase(attName);
+
+    if ((att != null) && att.isString())
+      attValue = att.getStringValue();
+
+    if (null == attValue)                     // not found, use default
+      attValue = defaultValue;
+
+    return attValue;
+  }
+
+  public double readAttributeDouble(Variable v, String attName, double defValue) {
+    Attribute att;
+
+    if (v == null)
+      att = rootGroup.findAttributeIgnoreCase(attName);
+    else
+      att = v.findAttributeIgnoreCase(attName);
+
+    if (att == null) return defValue;
+    if (att.isString())
+      return Double.parseDouble(att.getStringValue());
+    else
+      return att.getNumericValue().doubleValue();
+  }
+
+  public int readAttributeInteger(Variable v, String attName, int defValue) {
+    Attribute att;
+
+    if (v == null)
+      att = rootGroup.findAttributeIgnoreCase(attName);
+    else
+      att = v.findAttributeIgnoreCase(attName);
+
+    if (att == null) return defValue;
+    if (att.isString())
+      return Integer.parseInt(att.getStringValue());
+    else
+      return att.getNumericValue().intValue();
+  }
+
+
+  //////////////////////////////////////////////////////////////////////////////////////
+
+  /**
+   * Write CDL representation to OutputStream.
+   *
+   * @param out    write to this OutputStream
+   * @param strict if true, make it stricly CDL, otherwise, add a little extra info
+   */
+  public void writeCDL(OutputStream out, boolean strict) {
+    PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));
+    toStringStart(pw, strict);
+    toStringEnd(pw);
+    pw.flush();
+  }
+
+  /**
+   * Write CDL representation to PrintWriter.
+   *
+   * @param pw     write to this PrintWriter
+   * @param strict if true, make it stricly CDL, otherwise, add a little extra info
+   */
+  public void writeCDL(PrintWriter pw, boolean strict) {
+    toStringStart(pw, strict);
+    toStringEnd(pw);
+    pw.flush();
+  }
+
+  /**
+   * CDL representation of Netcdf header info.
+   */
+  public String toString() {
+    StringWriter writer = new StringWriter(50000);
+    writeCDL(new PrintWriter(writer), false);
+    return writer.toString();
+  }
+
+  protected void toStringStart(PrintWriter pw, boolean strict) {
+    String name = getLocation();
+    if (strict) {
+      int pos = name.lastIndexOf('/');
+      if (pos < 0) pos = name.lastIndexOf('\\');
+      if (pos >= 0) name = name.substring(pos + 1);
+      if (name.endsWith(".nc")) name = name.substring(0, name.length() - 3);
+      if (name.endsWith(".cdl")) name = name.substring(0, name.length() - 4);
+    }
+    pw.print("netcdf " + name + " {\n");
+    rootGroup.writeCDL(pw, "", strict);
+  }
+
+  protected void toStringEnd(PrintWriter pw) {
+    pw.print("}\n");
+  }
+
+  /**
+   * Write the NcML representation: dont show coodinate values
+   *
+   * @param os  : write to this Output Stream.
+   * @param uri use this for the uri attribute; if null use getLocation(). // ??
+   * @throws IOException if error
+   * @see NCdumpW#writeNcML
+   */
+  public void writeNcML(java.io.OutputStream os, String uri) throws IOException {
+    NCdumpW.writeNcML(this, new OutputStreamWriter(os), false, uri);
+  }
+
+  /**
+   * Write the NcML representation: dont show coodinate values
+   *
+   * @param writer : write to this Writer, should have encoding of UTF-8 if applicable
+   * @param uri    use this for the uri attribute; if null use getLocation().
+   * @throws IOException if error
+   * @see NCdumpW#writeNcML
+   */
+  public void writeNcML(java.io.Writer writer, String uri) throws IOException {
+    NCdumpW.writeNcML(this, writer, false, uri);
+  }
+
+  /**
+   * Extend the file if needed, in a way that is compatible with the current metadata, that is,
+   * does not invalidate structural metadata held by the application.
+   * For example, ok if dimension lengths, data has changed.
+   * All previous object references (variables, dimensions, etc) remain valid.
+   *
+   * @return true if file was extended.
+   * @throws IOException if error
+   */
+  public boolean syncExtend() throws IOException {
+    unlocked = false;
+    return (spi != null) && spi.syncExtend();
+  }
+
+  /**
+   * Check if file has changed, and reread metadata if needed.
+   * All previous object references (variables, dimensions, etc) may become invalid - you must re-obtain.
+   * DO NOT USE THIS ROUTINE YET - NOT FULLY TESTED
+   *
+   * @return true if file was changed.
+   * @throws IOException if error
+   */
+  public boolean sync() throws IOException {
+    unlocked = false;
+    return (spi != null) && spi.sync();
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////
+  // construction
+
+  /**
+   * This is can only be used for local netcdf-3 files.
+   *
+   * @param filename location
+   * @throws java.io.IOException if error
+   * @deprecated use NetcdfFile.open( location) or NetcdfDataset.openFile( location)
+   */
+  public NetcdfFile(String filename) throws IOException {
+    this.location = filename;
+    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.RandomAccessFile(filename, "r");
+    //ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.MMapRandomAccessFile(filename, "r");
+    this.spi = SPFactory.getServiceProvider();
+    spi.open(raf, this, null);
+    finish();
+  }
+
+  /**
+   * This can only be used for netcdf-3 files served over HTTP
+   *
+   * @param url HTTP URL location
+   * @throws java.io.IOException if error
+   * @deprecated use NetcdfFile.open( http:location) or NetcdfDataset.openFile( http:location)
+   */
+  public NetcdfFile(URL url) throws IOException {
+    this.location = url.toString();
+    ucar.unidata.io.RandomAccessFile raf = new ucar.unidata.io.http.HTTPRandomAccessFile(location);
+    this.spi = SPFactory.getServiceProvider();
+    spi.open(raf, this, null);
+    finish();
+  }
+
+  /**
+   * Open an existing netcdf file (read only), using the specified iosp.
+   * The ClassLoader for the NetcdfFile class is used.
+   *
+   * @param iospClassName the name of the class implementing IOServiceProvider
+   * @param iospParam     parameter to pass to the IOSP (before open is called)
+   * @param location      location of file. This is a URL string, or a local pathname.
+   * @param buffer_size   use this buffer size on the RandomAccessFile
+   * @param cancelTask    allow user to cancel
+   * @throws ClassNotFoundException if the iospClassName cannot be found
+   * @throws IllegalAccessException if the class or its nullary constructor is not accessible.
+   * @throws InstantiationException if the class cannot be instatiated, eg if it has no nullary constructor
+   * @throws IOException            if I/O error
+   */
+  protected NetcdfFile(String iospClassName, String iospParam, String location, int buffer_size, ucar.nc2.util.CancelTask cancelTask)
+          throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {
+
+    Class iospClass = getClass().getClassLoader().loadClass(iospClassName);
+    spi = (IOServiceProvider) iospClass.newInstance();
+    if (debugSPI) System.out.println("NetcdfFile uses iosp = " + spi.getClass().getName());
+    spi.sendIospMessage(iospParam);
+
+    this.location = location;
+    ucar.unidata.io.RandomAccessFile raf = getRaf(location, buffer_size);
+
+    try {
+      this.spi.open(raf, this, cancelTask);
+      finish();
+
+    } catch (IOException e) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      spi = null;
+      throw e;
+
+    } catch (RuntimeException e) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      spi = null;
+      throw e;
+
+    } catch (Throwable t) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      spi = null;
+      throw new RuntimeException(t);
+    }
+
+    if (id == null)
+      setId(findAttValueIgnoreCase(null, "_Id", null));
+    if (title == null)
+      setId(findAttValueIgnoreCase(null, "_Title", null));
+  }
+
+  /**
+   * Open an existing netcdf file (read only).
+   *
+   * @param location   location of file. This is a URL string, or a local pathname.
+   * @param spi        use this IOServiceProvider instance
+   * @param raf        read from this RandomAccessFile
+   * @param cancelTask allow user to cancel
+   * @throws IOException if I/O error
+   */
+  protected NetcdfFile(IOServiceProvider spi, ucar.unidata.io.RandomAccessFile raf, String location, ucar.nc2.util.CancelTask cancelTask) throws IOException {
+
+    this.spi = spi;
+    this.location = location;
+
+    if (debugSPI) System.out.println("NetcdfFile uses iosp = " + spi.getClass().getName());
+
+    try {
+      spi.open(raf, this, cancelTask);
+
+    } catch (IOException e) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      this.spi = null;
+      throw e;
+
+    } catch (RuntimeException e) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      this.spi = null;
+      throw e;
+
+    } catch (Throwable t) {
+      try {
+        spi.close();
+      } catch (Throwable t1) {
+      }
+      try {
+        raf.close();
+      } catch (Throwable t2) {
+      }
+      this.spi = null;
+      throw new RuntimeException(t);
+    }
+
+    if (id == null)
+      setId(findAttValueIgnoreCase(null, "_Id", null));
+    if (title == null)
+      setId(findAttValueIgnoreCase(null, "_Title", null));
+
+    finish();
+  }
+
+  /**
+   * For subclass construction. Call finish() when completed construction.
+   */
+  protected NetcdfFile() {
+  }
+
+  /**
+   * Copy constructor, used by NetcdfDataset.
+   * Shares the iosp.
+   *
+   * @param ncfile copy from here
+   */
+  protected NetcdfFile(NetcdfFile ncfile) {
+    this.location = ncfile.getLocation();
+    this.id = ncfile.getId();
+    this.title = ncfile.getTitle();
+    this.spi = ncfile.spi;
+  }
+
+  /**
+   * Add an attribute to a group.
+   *
+   * @param parent add to this group. If group is null, use root group
+   * @param att    add this attribute
+   * @return the attribute that was added
+   */
+  public Attribute addAttribute(Group parent, Attribute att) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (parent == null) parent = rootGroup;
+    parent.addAttribute(att);
+    return att;
+  }
+
+  /**
+   * Add a group to the parent group.
+   *
+   * @param parent add to this group. If group is null, use root group
+   * @param g      add this group
+   * @return the group that was added
+   */
+  public Group addGroup(Group parent, Group g) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (parent == null) parent = rootGroup;
+    parent.addGroup(g);
+    return g;
+  }
+
+  /**
+   * Add a shared Dimension to a Group.
+   *
+   * @param parent add to this group. If group is null, use root group
+   * @param d      add this Dimension
+   * @return the dimension that was added
+   */
+  public Dimension addDimension(Group parent, Dimension d) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (parent == null) parent = rootGroup;
+    parent.addDimension(d);
+    return d;
+  }
+
+  /**
+   * Remove a shared Dimension from a Group by name.
+   *
+   * @param g       remove from this group. If group is null, use root group
+   * @param dimName name of Dimension to remove.
+   * @return true if found and removed.
+   */
+  public boolean removeDimension(Group g, String dimName) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (g == null) g = rootGroup;
+    return g.removeDimension(dimName);
+  }
+
+  /**
+   * Add a Variable to the given group.
+   *
+   * @param g add to this group. If group is null, use root group
+   * @param v add this Variable
+   * @return the variable that was added
+   */
+  public Variable addVariable(Group g, Variable v) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (g == null) g = rootGroup;
+    if (v != null) g.addVariable(v);
+    return v;
+  }
+
+  /**
+   * Create a new Variable, and add to the given group.
+   *
+   * @param g         add to this group. If group is null, use root group
+   * @param shortName short name of the Variable
+   * @param dtype     data type of the Variable
+   * @param dims      list of dimension names
+   * @return the new Variable
+   */
+  public Variable addVariable(Group g, String shortName, DataType dtype, String dims) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (g == null) g = rootGroup;
+    Variable v = new Variable(this, g, null, shortName);
+    v.setDataType(dtype);
+    v.setDimensions(dims);
+    g.addVariable(v);
+    return v;
+  }
+
+  /**
+   * Create a new Variable of type Datatype.CHAR, and add to the given group.
+   *
+   * @param g         add to this group. If group is null, use root group
+   * @param shortName short name of the Variable
+   * @param dims      list of dimension names
+   * @param strlen    dimension length of the inner (fastest changing) dimension
+   * @return the new Variable
+   */
+  public Variable addStringVariable(Group g, String shortName, String dims, int strlen) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (g == null) g = rootGroup;
+    String dimName = shortName + "_strlen";
+    addDimension(g, new Dimension(dimName, strlen));
+    Variable v = new Variable(this, g, null, shortName);
+    v.setDataType(DataType.CHAR);
+    v.setDimensions(dims + " " + dimName);
+    g.addVariable(v);
+    return v;
+  }
+
+  /**
+   * Remove a Variable from the given group by name.
+   *
+   * @param g       remove from this group. If group is null, use root group
+   * @param varName name of variable to remove.
+   * @return true is variable found and removed
+   */
+  public boolean removeVariable(Group g, String varName) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (g == null) g = rootGroup;
+    return g.removeVariable(varName);
+  }
+
+  /**
+   * Add a variable attribute.
+   *
+   * @param v   add to this Variable.
+   * @param att add this attribute
+   * @return the added Attribute
+   */
+  public Attribute addVariableAttribute(Variable v, Attribute att) {
+    return v.addAttribute(att);
+  }
+
+  /*
+   * Add a Variable to the given structure.
+   * @param s add to this Structure
+   * @param v add this Variable.
+   * @deprecated use Structure.addMemberVariable(StructureMember)
+   *
+  public void addMemberVariable(Structure s, Variable v) {
+    if (v != null) s.addMemberVariable(v);
+  } */
+
+  /**
+   * Generic way to send a "message" to the underlying IOSP.
+   * This message is sent after the file is open. To affect the creation of the file, you must send into the factory method.
+   *
+   * @param message iosp specific message
+   *                Special:<ul>
+   *                <li>NetcdfFile.IOSP_MESSAGE_ADD_RECORD_STRUCTURE : tells Netcdf-3 files to make record (unlimited) variables into a structure.
+   *                return true if it has a Nectdf-3 record structure
+   *                </ul>
+   * @return iosp specific return, may be null
+   */
+  public Object sendIospMessage(Object message) {
+    if (null == message) return null;
+
+    if (message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE) {
+      Variable v = rootGroup.findVariable("record");
+      boolean gotit = (v != null) && (v instanceof Structure);
+      return gotit || makeRecordStructure();
+
+    } else if (message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE) {
+      Variable v = rootGroup.findVariable("record");
+      boolean gotit = (v != null) && (v instanceof Structure);
+      if (gotit) {
+        rootGroup.remove(v);
+        variables.remove(v);
+        removeRecordStructure();
+      }
+      return (gotit);
+    }
+
+    if (spi != null)
+      return spi.sendIospMessage(message);
+    return null;
+  }
+
+  /**
+   * If there is an unlimited dimension, make all variables that use it into a Structure.
+   * A Variable called "record" is added.
+   * You can then access these through the record structure.
+   *
+   * @return true if it has a Nectdf-3 record structure
+   */
+  protected Boolean makeRecordStructure() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+
+    Boolean didit = false;
+    if ((spi != null) && (spi instanceof N3iosp) && hasUnlimitedDimension()) {
+      didit = (Boolean) spi.sendIospMessage(IOSP_MESSAGE_ADD_RECORD_STRUCTURE);
+    }
+    return didit;
+  }
+
+  protected Boolean removeRecordStructure() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+
+    Boolean didit = false;
+    if ((spi != null) && (spi instanceof N3iosp)) {
+      didit = (Boolean) spi.sendIospMessage(IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE);
+    }
+    return didit;
+  }
+
+  //protected boolean addedRecordStructure = false;
+
+  /**
+   * Set the globally unique dataset identifier.
+   *
+   * @param id the id
+   */
+  public void setId(String id) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.id = id;
+  }
+
+  /**
+   * Set the dataset "human readable" title.
+   *
+   * @param title the title
+   */
+  public void setTitle(String title) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.title = title;
+  }
+
+  /**
+   * Set the location, a URL or local filename.
+   *
+   * @param location the location
+   */
+  public void setLocation(String location) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.location = location;
+  }
+
+  /**
+   * Make this immutable.
+   *
+   * @return this
+   */
+  public NetcdfFile setImmutable() {
+    if (immutable) return this;
+    immutable = true;
+    setImmutable(rootGroup);
+    variables = Collections.unmodifiableList(variables);
+    dimensions = Collections.unmodifiableList(dimensions);
+    gattributes = Collections.unmodifiableList(gattributes);
+    return this;
+  }
+
+  private void setImmutable(Group g) {
+    for (Variable v : g.variables)
+      v.setImmutable();
+
+    for (Dimension d : g.dimensions)
+      d.setImmutable();
+
+    for (Group nested : g.getGroups())
+      setImmutable(nested);
+
+    g.setImmutable();
+  }
+
+  /**
+   * Completely empty the objects in the netcdf file.
+   * Used for rereading the file on a sync().
+   */
+  public void empty() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    variables = new ArrayList<Variable>();
+    gattributes = new ArrayList<Attribute>();
+    dimensions = new ArrayList<Dimension>();
+    rootGroup = makeRootGroup();
+    // addedRecordStructure = false;
+  }
+
+  protected Group makeRootGroup() {
+    Group root = new Group(this, null, "");
+    root.parent = null;
+    return root;
+  }
+
+  /**
+   * Finish constructing the object model.
+   * This construsts the "global" variables, attributes and dimensions.
+   * It also looks for coordinate variables.
+   */
+  public void finish() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    variables = new ArrayList<Variable>();
+    dimensions = new ArrayList<Dimension>();
+    gattributes = new ArrayList<Attribute>();
+    finishGroup(rootGroup);
+  }
+
+  private void finishGroup(Group g) {
+
+    variables.addAll(g.variables);
+
+    // LOOK should group atts be promoted to global atts?
+    for (Attribute oldAtt : g.attributes) {
+      if (g == rootGroup) {
+        gattributes.add(oldAtt);
+      } else {
+        String newName = makeFullNameWithString(g, oldAtt.getName());
+        gattributes.add(new Attribute(newName, oldAtt));
+      }
+    }
+
+    // LOOK this wont match the variables' dimensions if there are groups
+    for (Dimension oldDim : g.dimensions) {
+      if (oldDim.isShared()) {
+        if (g == rootGroup) {
+          dimensions.add(oldDim);
+        } else {
+          String newName = makeFullNameWithString(g, oldDim.getName());
+          dimensions.add(new Dimension(newName, oldDim));
+        }
+      }
+    }
+
+    List<Group> groups = g.getGroups();
+    for (Group nested : groups) {
+      finishGroup(nested);
+    }
+
+  }
+
+  protected String makeFullNameWithString(Group parent, String name) {
+    StringBuilder sbuff = new StringBuilder();
+    appendGroupName(sbuff, parent, null);
+    sbuff.append(name);
+    return sbuff.toString();
+  }
+
+  public ArrayLong getLocalityInformation(ucar.nc2.Variable v, Section ranges) 
+         throws IOException, InvalidRangeException {
+    if (spi == null) {
+      throw new IOException("spi is null");
+    } else if (!spi.supportsLocalityInformation()) { 
+      throw new IOException("IOSP " + spi.getFileTypeId() + " does not support getLocalityInformation()");
+    }
+
+    return spi.getLocalityInformation(v, ranges);
+  }
+
+  //////////////////////////////////////////////////////////////////////////////////////
+  // Service Provider calls
+  // All IO eventually goes through these calls.
+  // LOOK: these should not be public !!! not hitting variable cache
+  // used in NetcdfDataset - try to refactor
+
+  // this is for reading non-member variables
+  // section is null for full read
+
+  /*
+   * Do not call this directly, use Variable.read() !!
+   * Ranges must be filled (no nulls)
+   */
+  protected Array readData(ucar.nc2.Variable v, Section ranges) throws IOException, InvalidRangeException {
+    if (showRequest)
+      System.out.println("Data request for variable: " + v.getFullName() + " section= " + ranges);
+    if (unlocked) {
+      String info = cache.getInfo(this);
+      throw new IllegalStateException("File is unlocked - cannot use\n" + info);
+    }
+
+    if (spi == null) {
+      throw new IOException("BAD: missing spi: " + v.getFullName());
+    }
+    Array result = spi.readData(v, ranges);
+    result.setUnsigned(v.isUnsigned());
+    return result;
+  }
+
+  /**
+   * Read a variable using the given section specification.
+   * The result is always an array of the type of the innermost variable.
+   * Its shape is the accumulation of all the shapes of its parent structures.
+   *
+   * @param variableSection the constraint expression.
+   * @return data requested
+   * @throws IOException           if error
+   * @throws InvalidRangeException if variableSection is invalid
+   * @see <a href="http://www.unidata.ucar.edu/software/netcdf-java/reference/SectionSpecification.html">SectionSpecification</a>
+   */
+  public Array readSection(String variableSection) throws IOException, InvalidRangeException {
+    if (unlocked)
+      throw new IllegalStateException("File is unlocked - cannot use");
+
+    ParsedSectionSpec cer = ParsedSectionSpec.parseVariableSection(this, variableSection);
+    if (cer.child == null) {
+      Array result = cer.v.read(cer.section);
+      result.setUnsigned(cer.v.isUnsigned());
+      return result;
+    }
+
+    if (spi == null)
+      return IospHelper.readSection(cer);
+    else
+      // allow iosp to optimize
+      return spi.readSection(cer);
+  }
+
+
+  /**
+   * Read data from a top level Variable and send data to a WritableByteChannel. Experimental.
+   *
+   * @param v       a top-level Variable
+   * @param section the section of data to read.
+   *                There must be a Range for each Dimension in the variable, in order.
+   *                Note: no nulls allowed. IOSP may not modify.
+   * @param wbc     write data to this WritableByteChannel
+   * @return the number of bytes written to the channel
+   * @throws java.io.IOException            if read error
+   * @throws ucar.ma2.InvalidRangeException if invalid section
+   */
+
+  protected long readToByteChannel(ucar.nc2.Variable v, Section section, WritableByteChannel wbc)
+          throws java.io.IOException, ucar.ma2.InvalidRangeException {
+
+    if (unlocked)
+      throw new IllegalStateException("File is unlocked - cannot use");
+
+    if ((spi == null) || v.hasCachedData())
+      return IospHelper.copyToByteChannel(v.read(section), wbc);
+
+    return spi.readToByteChannel(v, section, wbc);
+  }
+
+
+  protected StructureDataIterator getStructureIterator(Structure s, int bufferSize) throws java.io.IOException {
+    return spi.getStructureIterator(s, bufferSize);
+  }
+
+  /* public long readToByteChannel(ucar.nc2.Variable v, WritableByteChannel wbc) throws java.io.IOException {
+    try {
+      return readToByteChannel(v, v.getShapeAsSection(), wbc);
+    } catch (InvalidRangeException e) {
+      throw new IllegalStateException(e);
+    }
+  } */
+
+  /*
+   * Read using a section specification and send data to a WritableByteChannel. Experimental.
+   *
+   * @param variableSection the constraint expression.
+   * @param wbc write data to this WritableByteChannel
+   * @return the number of bytes written to the channel
+   * @throws java.io.IOException if read error
+   * @throws ucar.ma2.InvalidRangeException if invalid section
+   *
+  public long readToByteChannel(String variableSection, WritableByteChannel wbc) throws IOException, InvalidRangeException {
+    ParsedSectionSpec cer = ParsedSectionSpec.parseVariableSection(this, variableSection);
+    return readToByteChannel(cer.v, cer.section, wbc);
+  } */
+
+  ///////////////////////////////////////////////////////////////////////////////////
+
+  // public I/O
+
+  /**
+   * Do a bulk read on a list of Variables and
+   * return a corresponding list of Array that contains the results
+   * of a full read on each Variable.
+   * This is mostly here so DODSNetcdf can override it with one call to the server.
+   *
+   * @param variables List of type Variable
+   * @return List of Array, one for each Variable in the input.
+   * @throws IOException if read error
+   */
+  public java.util.List<Array> readArrays(java.util.List<Variable> variables) throws IOException {
+    java.util.List<Array> result = new java.util.ArrayList<Array>();
+    for (Variable variable : variables)
+      result.add(variable.read());
+    return result;
+  }
+
+  /**
+   * Read a variable using the given section specification.
+   *
+   * @param variableSection the constraint expression.
+   * @param flatten         MUST BE TRUE
+   * @return Array data read.
+   * @throws IOException           if error
+   * @throws InvalidRangeException if variableSection is invalid
+   * @see <a href="http://www.unidata.ucar.edu/software/netcdf-java/reference/SectionSpecification.html">SectionSpecification</a>
+   * @deprecated use readSection(), flatten=false no longer supported
+   */
+  public Array read(String variableSection, boolean flatten) throws IOException, InvalidRangeException {
+    if (!flatten)
+      throw new UnsupportedOperationException("NetdfFile.read(String variableSection, boolean flatten=false)");
+    return readSection(variableSection);
+  }
+
+  /**
+   * Access to iosp debugging info.
+   *
+   * @param o must be a Variable, Dimension, Attribute, or Group
+   * @return debug info for this object.
+   */
+  protected String toStringDebug(Object o) {
+    return (spi == null) ? "" : spi.toStringDebug(o);
+  }
+
+  /**
+   * Access to iosp debugging info.
+   *
+   * @return debug / underlying implementation details
+   */
+  public String getDetailInfo() {
+    Formatter f = new Formatter();
+    getDetailInfo(f);
+    return f.toString();
+  }
+
+  public void getDetailInfo(Formatter f) {
+    f.format("NetcdfFile location= %s%n", getLocation());
+    f.format("  title= %s%n", getTitle());
+    f.format("  id= %s%n", getId());
+    f.format("  fileType= %s%n", getFileTypeId());
+    f.format("  fileDesc= %s%n", getFileTypeDescription());
+
+    f.format("  class= %s%n", getClass().getName());
+    if (spi == null) {
+      f.format("  has no IOSP%n");
+    } else {
+      f.format("  iosp= %s%n%n", spi.getClass());
+      f.format("%s", spi.getDetailInfo());
+    }
+    showCached(f);
+    showProxies(f);
+  }
+
+  protected void showCached(Formatter f) {
+    int maxNameLen = 8;
+    for (Variable v : getVariables()) {
+      maxNameLen = Math.max(maxNameLen, v.getShortName().length());
+    }
+
+    long total = 0;
+    f.format("%n%-" + maxNameLen + "s isCaching  size     cachedSize (bytes) %n", "Variable");
+    for (Variable v : getVariables()) {
+      f.format(" %-" + maxNameLen + "s %5s %8d ", v.getShortName(), v.isCaching(), v.getSize() * v.getElementSize());
+      if (v.hasCachedData()) {
+        Array data = null;
+        try {
+          data = v.read();
+        } catch (IOException e) {
+          e.printStackTrace();
+        }
+        long size = data.getSizeBytes();
+        f.format(" %8d", size);
+        total += size;
+      }
+      f.format("%n");
+    }
+    f.format(" %" + maxNameLen + "s                  --------%n", " ");
+    f.format(" %" + maxNameLen + "s                 %8d Kb total cached%n", " ", total / 1000);
+  }
+
+  protected void showProxies(Formatter f) {
+    int maxNameLen = 8;
+    boolean hasProxy = false;
+    for (Variable v : getVariables()) {
+      if (v.proxyReader != v) hasProxy = true;
+      maxNameLen = Math.max(maxNameLen, v.getShortName().length());
+    }
+    if (!hasProxy) return;
+
+    f.format("%n%-" + maxNameLen + "s  proxyReader   Variable.Class %n", "Variable");
+    for (Variable v : getVariables()) {
+      if (v.proxyReader != v)
+        f.format(" %-" + maxNameLen + "s  %s %s%n", v.getShortName(), v.proxyReader.getClass().getName(), v.getClass().getName());
+    }
+    f.format("%n");
+  }
+
+  /**
+   * DO NOT USE - public by accident
+   *
+   * @return the IOSP for this NetcdfFile
+   */
+  public IOServiceProvider getIosp() {
+    return spi;
+  }
+
+  /**
+   * Get the file type id for the underlying data source.
+   *
+   * @return registered id of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeId() {
+    if (spi != null) return spi.getFileTypeId();
+    return "N/A";
+  }
+
+  /**
+   * Get a human-readable description for this file type.
+   *
+   * @return description of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeDescription() {
+    if (spi != null) return spi.getFileTypeDescription();
+    return "N/A";
+  }
+
+
+  /**
+   * Get the version of this file type.
+   *
+   * @return version of the file type
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/formats/FileTypes.html"
+   */
+  public String getFileTypeVersion() {
+    if (spi != null) return spi.getFileTypeVersion();
+    return "N/A";
+  }
+
+  /* "safety net" use of finalize cf Bloch p 22
+  protected void finalize() throws Throwable {
+    try {
+      if (null != spi) {
+        log.warn("NetcdfFile.finalizer called on "+location+" for ncfile="+this.hashCode());
+        spi.close();
+      }
+      spi = null;
+    } finally {
+      super.finalize();
+    }
+  } */
+
+  //////////////////////////////////////////////////////////
+
+  /**
+   * debugging - do not use
+   */
+  public static void main(String[] arg) throws Exception {
+    //NetcdfFile.registerIOProvider( ucar.nc2.grib.GribServiceProvider.class);
+
+    int wide = 20;
+    Formatter f = new Formatter(System.out);
+    f.format(" %" + wide + "s %n", "test");
+    f.format(" %20s %n", "asiuasdipuasiud");
+
+    /*
+    try {
+      String filename = "R:/testdata2/hdf5/npoess/ExampleFiles/AVAFO_NPP_d2003125_t10109_e101038_b9_c2005829155458_devl_Tst.h5";
+      NetcdfFile ncfile = NetcdfFile.open(filename);
+      //Thread.currentThread().sleep( 60 * 60 * 1000); // pause to examine in profiler
+
+      ncfile.close();
+
+    } catch (Exception e) {
+      e.printStackTrace();
+    }            */
+  }
+
+}
diff -r -U4 ./cdm/src/main/java/ucar/nc2/Variable.java ../fake_netcdf/cdm/src/main/java/ucar/nc2/Variable.java
--- ./cdm/src/main/java/ucar/nc2/Variable.java	2011-07-27 11:12:34.000000000 -0700
+++ ../fake_netcdf/cdm/src/main/java/ucar/nc2/Variable.java	2011-11-03 21:57:20.944436824 -0700
@@ -1,1804 +1,1838 @@
-/*
- * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
- *
- * Portions of this software were developed by the Unidata Program at the
- * University Corporation for Atmospheric Research.
- *
- * Access and use of this software shall impose the following obligations
- * and understandings on the user. The user is granted the right, without
- * any fee or cost, to use, copy, modify, alter, enhance and distribute
- * this software, and any derivative works thereof, and its supporting
- * documentation for any purpose whatsoever, provided that this entire
- * notice appears in all copies of the software, derivative works and
- * supporting documentation.  Further, UCAR requests that the user credit
- * UCAR/Unidata in any publications that result from the use of this
- * software or in any product that includes this software. The names UCAR
- * and/or Unidata, however, may not be used in any advertising or publicity
- * to endorse or promote any products or commercial entity unless specific
- * written permission is obtained from UCAR/Unidata. The user also
- * understands that UCAR/Unidata is not obligated to provide the user with
- * any support, consulting, training or assistance of any kind with regard
- * to the use, operation and performance of this software nor to provide
- * the user with any updates, revisions, new versions or "bug fixes."
- *
- * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
- * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
- * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
- * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-package ucar.nc2;
-
-import ucar.ma2.*;
-import ucar.nc2.iosp.IospHelper;
-import ucar.nc2.util.CancelTask;
-
-import java.util.*;
-import java.io.IOException;
-import java.nio.channels.WritableByteChannel;
-
-/**
- * A Variable is a logical container for data. It has a dataType, a set of Dimensions that define its array shape,
- * and optionally a set of Attributes.
- * <p/>
- * The data is a multidimensional array of primitive types, Strings, or Structures.
- * Data access is done through the read() methods, which return a memory resident Array.
- * <p> Immutable if setImmutable() was called.
- * @author caron
- * @see ucar.ma2.Array
- * @see ucar.ma2.DataType
- */
-
-public class Variable implements VariableIF, ProxyReader {
-  static public final int defaultSizeToCache = 4000; // bytes  cache any variable whose size() < defaultSizeToCache
-  static public final int defaultCoordsSizeToCache = 40 * 1000; // bytes cache coordinate variable whose size() < defaultSizeToCache
-
-  static protected boolean debugCaching = false;
-  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Variable.class);
-
-  protected NetcdfFile ncfile; // physical container for this Variable; where the I/O happens. may be null if Variable is self contained.
-  protected Group group; // logical container for this Variable. may not be null.
-  protected String shortName; // may not be blank; must not be escaped
-  protected int[] shape;
-  protected Section shapeAsSection;  // derived from the shape, immutable; used for every read, deferred creation
-
-  protected DataType dataType;
-  protected int elementSize;
-  protected List<Dimension> dimensions = new ArrayList<Dimension>(5);
-  protected List<Attribute> attributes = new ArrayList<Attribute>();
-
-  protected boolean isVariableLength = false;
-  protected boolean isMetadata = false;
-  private boolean immutable = false; // cache can change
-
-  protected Cache cache = new Cache();
-  protected int sizeToCache = -1; // bytes
-
-  protected Structure parent = null; // for variables inside a Structure, aka "structure members"
-  protected ProxyReader proxyReader = this;
-
-  /**
-   * Get the variable name.
-   * @return full unescaped name
-   * @deprecated use getFullName or getShortName
-   */
-  public String getName() {
-    return getFullName();
-  }
-
-  /**
-   * Get the full, unescaped name of this Variable, starting from rootGroup.
-   * The name is unique within the entire NetcdfFile.
-   * @return  full, unescaped name
-   */
-  public String getFullName() {
-    return NetcdfFile.makeFullName(this);
-  }
-
-  /**
-   * Get the full, escaped name of this Variable. Use for NetcdfFile.findVariable().
-   * @return  full, escaped name
-   * @see "http://www.unidata.ucar.edu/software/netcdf-java/CDM/Identifiers.html"
-   */
-  public String getFullNameEscaped() {
-    return NetcdfFile.makeFullNameEscaped(this);
-  }
-
-  /**
-   * Get the short name of this Variable. The name is unique within its parent group.
-   */
-  public String getShortName() {
-    return shortName;
-  }
-
-  /**
-   * Get the data type of the Variable.
-   */
-  public DataType getDataType() {
-    return dataType;
-  }
-
-  /**
-   * Get the shape: length of Variable in each dimension.
-   *
-   * @return int array whose length is the rank of this Variable
-   *         and whose values equal the length of that Dimension.
-   */
-  public int[] getShape() {
-    int[] result = new int[shape.length];  // optimization over clone()
-    System.arraycopy(shape, 0, result, 0, shape.length);
-    return result;
-  }
-
-  /**
-   * Get the size of the ith dimension
-   *
-   * @param index which dimension
-   * @return size of the ith dimension
-   */
-  public int getShape(int index) {
-    return shape[index];
-  }
-
-  /**
-   * Get the total number of elements in the Variable.
-   * If this is an unlimited Variable, will use the current number of elements.
-   * If this is a Sequence, will return 1.
-   * If variable length, will skip vlen dimensions
-   *
-   * @return total number of elements in the Variable.
-   */
-  public long getSize() {
-    long size = 1;
-    for (int i = 0; i < shape.length; i++) {
-      if (shape[i] >= 0)
-        size *= shape[i];
-    }
-    return size;
-  }
-
-  /**
-   * Get the number of bytes for one element of this Variable.
-   * For Variables of primitive type, this is equal to getDataType().getSize().
-   * Variables of String type dont know their size, so what they return is undefined.
-   * Variables of Structure type return the total number of bytes for all the members of
-   * one Structure, plus possibly some extra padding, depending on the underlying format.
-   * Variables of Sequence type return the number of bytes of one element.
-   *
-   * @return total number of bytes for the Variable
-   */
-  public int getElementSize() {
-    return elementSize;
-  }
-
-  /**
-   * Get the number of dimensions of the Variable.
-   * @return the rank
-   */
-  public int getRank() {
-    return shape.length;
-  }
-
-  /**
-   * Get the containing Group.
-   * @return the containing Group.
-   */
-  public Group getParentGroup() {
-    return group;
-  }
-
-  /**
-   * Is this variable metadata?. True if its values need to be included explicitly in NcML output.
-   * @return true if Variable values need to be included in NcML
-   */
-  public boolean isMetadata() {
-    return isMetadata;
-  }
-
-  /**
-   * Whether this is a scalar Variable (rank == 0).
-   * @return true if Variable has rank 0
-   */
-  public boolean isScalar() {
-    return getRank() == 0;
-  }
-
-  /**
-   * Does this variable have a variable length dimension?
-   * If so, it has as one of its dimensions Dimension.VLEN.
-   * @return true if Variable has a variable length dimension?
-   */
-  public boolean isVariableLength() {
-    return isVariableLength;
-  }
-
-  /**
-   * Is this Variable unsigned?. Only meaningful for byte, short, int, long types.
-   * Looks for attribute "_Unsigned", case insensitive
-   * @return true if Variable is unsigned
-   */
-  public boolean isUnsigned() {
-    Attribute att = findAttributeIgnoreCase("_Unsigned");
-    return (att != null) && att.getStringValue().equalsIgnoreCase("true");
-  }
-
-  /**
-   * Can this variable's size grow?.
-   * This is equivalent to saying at least one of its dimensions is unlimited.
-   *
-   * @return boolean true iff this variable can grow
-   */
-  public boolean isUnlimited() {
-    for (Dimension d : dimensions) {
-      if (d.isUnlimited()) return true;
-    }
-    return false;
-  }
-
-  /**
-   * Get the list of dimensions used by this variable.
-   * The most slowly varying (leftmost for Java and C programmers) dimension is first.
-   * For scalar variables, the list is empty.
-   *
-   * @return List<Dimension>, immutable
-   */
-  public java.util.List<Dimension> getDimensions() {
-    return dimensions;
-  }
-
-  /**
-   * Get the ith dimension.
-   *
-   * @param i index of the dimension.
-   * @return requested Dimension, or null if i is out of bounds.
-   */
-  public Dimension getDimension(int i) {
-    if ((i < 0) || (i >= getRank())) return null;
-    return dimensions.get(i);
-  }
-
-  /**
-   * Get the list of Dimension names, space delineated.
-   * @return Dimension names, space delineated
-   */
-  /* public String getDimensionsStringOld() {
-    StringBuilder buff = new StringBuilder();
-    for (int i = 0; i < dimensions.size(); i++) {
-      Dimension dim = dimensions.get(i);
-      if (i > 0) buff.append(" ");
-      buff.append(dim.getName());
-    }
-    return buff.toString();
-  }  */
-
-  public String getDimensionsString() {
-    Formatter buf = new Formatter();
-    for (int i = 0; i < dimensions.size(); i++) {
-      Dimension myd = dimensions.get(i);
-      String dimName = myd.getName();
-
-      if (i != 0) buf.format(" ");
-
-      if (myd.isVariableLength()) {
-        buf.format("*");
-      } else if (myd.isShared()) {
-        buf.format("%s", dimName);
-      } else {
-        //if (dimName != null)          // LOOK losing anon dim name
-        //  buf.format("%s=", dimName);
-        buf.format("%d", myd.getLength());
-      }
-    }
-    return buf.toString();
-  }
-  /**
-   * Find the index of the named Dimension in this Variable.
-   *
-   * @param name the name of the dimension
-   * @return the index of the named Dimension, or -1 if not found.
-   */
-  public int findDimensionIndex(String name) {
-    for (int i = 0; i < dimensions.size(); i++) {
-      Dimension d = dimensions.get(i);
-      if (name.equals(d.getName()))
-        return i;
-    }
-    return -1;
-  }
-
-  /**
-   * Returns the set of attributes for this variable.
-   *
-   * @return List<Attribute>, not a copy, but may be immutable
-   */
-  public java.util.List<Attribute> getAttributes() {
-    return attributes;
-  }
-
-  /**
-   * Find an Attribute by name.
-   *
-   * @param name the name of the attribute
-   * @return the attribute, or null if not found
-   */
-  public Attribute findAttribute(String name) {
-    for (Attribute a : attributes) {
-      if (name.equals(a.getName()))
-        return a;
-    }
-    return null;
-  }
-
-  /**
-   * Find an Attribute by name, ignoring the case.
-   *
-   * @param name the name of the attribute
-   * @return the attribute, or null if not found
-   */
-  public Attribute findAttributeIgnoreCase(String name) {
-    for (Attribute a : attributes) {
-      if (name.equalsIgnoreCase(a.getName()))
-        return a;
-    }
-    return null;
-  }
-
-  /**
-   * Get the description of the Variable.
-   * Default is to use "long_name" attribute value. If not exist, look for "description", "title", or
-   * "standard_name" attribute value (in that order).
-   *
-   * @return description, or null if not found.
-   */
-  public String getDescription() {
-    String desc = null;
-    Attribute att = findAttributeIgnoreCase("long_name");
-    if ((att != null) && att.isString())
-      desc = att.getStringValue();
-
-    if (desc == null) {
-      att = findAttributeIgnoreCase("description");
-      if ((att != null) && att.isString())
-        desc = att.getStringValue();
-    }
-
-    if (desc == null) {
-      att = findAttributeIgnoreCase("title");
-      if ((att != null) && att.isString())
-        desc = att.getStringValue();
-    }
-
-    if (desc == null) {
-      att = findAttributeIgnoreCase("standard_name");
-      if ((att != null) && att.isString())
-        desc = att.getStringValue();
-    }
-
-    return desc;
-  }
-
-  /**
-   * Get the Unit String for the Variable.
-   * Looks for the "units" attribute value
-   *
-   * @return unit string, or null if not found.
-   */
-  public String getUnitsString() {
-    String units = null;
-    Attribute att = findAttributeIgnoreCase("units");
-    if ((att != null) && att.isString()) {
-      units = att.getStringValue();
-      if (units != null) units = units.trim();
-    }
-    return units;
-  }
-
-  /**
-   * Get shape as an List of Range objects.
-   * The List is immutable.
-   * @return List of Ranges, one for each Dimension.
-   */
-  public List<Range> getRanges() {
-    return getShapeAsSection().getRanges();
-  }
-
-  /**
-   * Get shape as a Section object.
-   * @return Section containing List<Range>, one for each Dimension.
-   */
-  public Section getShapeAsSection() {
-    if (shapeAsSection == null) {
-      try {
-        List<Range> list = new ArrayList<Range>();
-        for (Dimension d : dimensions) {
-          int len = d.getLength();
-          if (len > 0)
-            list.add(new Range(d.getName(), 0, len - 1));
-          else if (len == 0)
-            list.add( Range.EMPTY); // LOOK empty not named
-          else
-            list.add( Range.VLEN); // LOOK vlen not named
-        }
-        shapeAsSection = new Section(list).makeImmutable();
-        
-      } catch (InvalidRangeException e) {
-        log.error("Bad shape in variable " + getFullName(), e);
-        throw new IllegalStateException(e.getMessage());
-      }
-    }
-    return shapeAsSection;
-  }
-
-  public ProxyReader getProxyReader() {
-    return proxyReader;
-  }
-
-  public void setProxyReader(ProxyReader proxyReader) {
-    this.proxyReader = proxyReader;
-  }
-
-
-  /** Get the proxy reader, or null.
-   * @return return the proxy reader, if any
-   *
-  public ProxyReader getProxyReader() {
-    return this.postReader;
-  } */
-
-  /**
-   * Create a new Variable that is a logical subsection of this Variable.
-   * No data is read until a read method is called on it.
-   *
-   * @param ranges List of type ucar.ma2.Range, with size equal to getRank().
-   *               Each Range corresponds to a Dimension, and specifies the section of data to read in that Dimension.
-   *               A Range object may be null, which means use the entire dimension.
-   * @return a new Variable which is a logical section of this Variable.
-   * @throws InvalidRangeException
-   */
-  public Variable section(List<Range> ranges) throws InvalidRangeException {
-    return section(new Section(ranges, shape).makeImmutable());
-  }
-
-  /**
-   * Create a new Variable that is a logical subsection of this Variable.
-   * No data is read until a read method is called on it.
-   *
-   * @param subsection Section of this variable.
-   *                   Each Range in the section corresponds to a Dimension, and specifies the section of data to read in that Dimension.
-   *                   A Range object may be null, which means use the entire dimension.
-   * @return a new Variable which is a logical section of this Variable.
-   * @throws InvalidRangeException if section not compatible with shape
-   */
-  public Variable section(Section subsection) throws InvalidRangeException {
-
-    subsection = Section.fill(subsection, shape);
-
-    // create a copy of this variable with a proxy reader
-    Variable sectionV = copy(); // subclasses must override
-    sectionV.setProxyReader( new SectionReader(this, subsection));
-    sectionV.shape = subsection.getShape();
-    sectionV.createNewCache(); // dont share the cache
-    sectionV.setCaching(false); // dont cache
-    
-    // replace dimensions if needed !! LOOK not shared
-    sectionV.dimensions = new ArrayList<Dimension>();
-    for (int i = 0; i < getRank(); i++) {
-      Dimension oldD = getDimension(i);
-      Dimension newD = (oldD.getLength() == sectionV.shape[i]) ? oldD : new Dimension(oldD.getName(), sectionV.shape[i], false);
-      newD.setUnlimited(oldD.isUnlimited());
-      sectionV.dimensions.add(newD);
-    }
-    sectionV.resetShape();
-    return sectionV;
-  }
-
-
-  /**
-   * Create a new Variable that is a logical slice of this Variable, by
-   * fixing the specified dimension at the specified index value. This reduces rank by 1.
-   * No data is read until a read method is called on it.
-   *
-   * @param dim   which dimension to fix
-   * @param value at what index value
-   * @return a new Variable which is a logical slice of this Variable.
-   * @throws InvalidRangeException if dimension or value is illegal
-   */
-  public Variable slice(int dim, int value) throws InvalidRangeException {
-    if ((dim < 0) || (dim >= shape.length))
-      throw new InvalidRangeException("Slice dim invalid= " + dim);
-
-    // ok to make slice of record dimension with length 0
-    boolean recordSliceOk = false;
-    if ((dim == 0) && (value == 0)) {
-      Dimension d = getDimension(0);
-      recordSliceOk = d.isUnlimited();
-    }
-
-    // otherwise check slice in range
-    if (!recordSliceOk) {
-      if ((value < 0) || (value >= shape[dim]))
-        throw new InvalidRangeException("Slice value invalid= " + value + " for dimension " + dim);
-    }
-
-    // create a copy of this variable with a proxy reader
-    Variable sliceV = copy(); // subclasses must override
-    Section slice = new Section( getShapeAsSection());
-    slice.replaceRange(dim, new Range(value, value)).makeImmutable();
-    sliceV.setProxyReader( new SliceReader(this, dim, slice));
-    sliceV.createNewCache(); // dont share the cache
-    sliceV.setCaching(false); // dont cache
-
-    // remove that dimension - reduce rank
-    sliceV.dimensions.remove(dim);
-    sliceV.resetShape();
-    return sliceV;
-  }
-
-  protected Variable copy() {
-    return new Variable(this);
-  }
-
-  //////////////////////////////////////////////////////////////////////////////
-
-  /**
-   * Lookup the enum string for this value.
-   * Can only be called on enum types, where dataType.isEnum() is true.
-   * @param val the integer value of this enum
-   * @return the String value
-   */
-  public String lookupEnumString(int val) {
-    if (!dataType.isEnum())
-      throw new UnsupportedOperationException("Can only call Variable.lookupEnumVal() on enum types");
-    return enumTypedef.lookupEnumString(val);
-  }
-  private EnumTypedef enumTypedef;
-
-  /**
-   * Public by accident.
-   * @param enumTypedef set the EnumTypedef, only use if getDataType.isEnum()
-   */
-  public void setEnumTypedef(EnumTypedef enumTypedef) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    if (!dataType.isEnum())
-      throw new UnsupportedOperationException("Can only call Variable.setEnumTypedef() on enum types");
-    this.enumTypedef = enumTypedef;
-  }
-
-  public EnumTypedef getEnumTypedef() { return enumTypedef; }
-
-  //////////////////////////////////////////////////////////////////////////////
-  // IO
-  // implementation notes to subclassers
-  // all other calls use them, so override only these:
-  //   _read()
-  //   _read(Section section)
-  //   _readNestedData(Section section, boolean flatten)
-
-  /**
-   * Read a section of the data for this Variable and return a memory resident Array.
-   * The Array has the same element type as the Variable, and the requested shape.
-   * Note that this does not do rank reduction, so the returned Array has the same rank
-   * as the Variable. Use Array.reduce() for rank reduction.
-   * <p/>
-   * <code>assert(origin[ii] + shape[ii]*stride[ii] <= Variable.shape[ii]); </code>
-   * <p/>
-   *
-   * @param origin int array specifying the starting index. If null, assume all zeroes.
-   * @param shape  int array specifying the extents in each dimension.
-   *               This becomes the shape of the returned Array.
-   * @return the requested data in a memory-resident Array
-   */
-  public Array read(int[] origin, int[] shape) throws IOException, InvalidRangeException {
-    if ((origin == null) && (shape == null))
-      return read();
-
-    if (origin == null)
-      return read(new Section(shape));
-
-    if (shape == null) // LOOK not very useful, origin must be 0 to be valid
-      return read(new Section(origin, shape));
-
-    return read(new Section(origin, shape));
-  }
-
-  /**
-   * Read data section specified by a "section selector", and return a memory resident Array. Uses
-   * Fortran 90 array section syntax.
-   *
-   * @param sectionSpec specification string, eg "1:2,10,:,1:100:10". May optionally have ().
-   * @return the requested data in a memory-resident Array
-   * @see ucar.ma2.Section for sectionSpec syntax
-   */
-  public Array read(String sectionSpec) throws IOException, InvalidRangeException {
-    return read(new Section(sectionSpec));
-  }
-
-  /**
-   * Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
-   *
-   * @param ranges list of Range specifying the section of data to read.
-   * @return the requested data in a memory-resident Array
-   * @see #read(Section)
-   * @throws IOException if error
-   * @throws InvalidRangeException if ranges is invalid
-   */
-  public Array read(List<Range> ranges) throws IOException, InvalidRangeException {
-    if (null == ranges)
-      return _read();
-
-    return read(new Section(ranges));
-  }
-
-  /**
-   * Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
-   * The Array has the same element type as the Variable, and the requested shape.
-   * Note that this does not do rank reduction, so the returned Array has the same rank
-   * as the Variable. Use Array.reduce() for rank reduction.
-   * <p/>
-   * If the Variable is a member of an array of Structures, this returns only the variable's data
-   * in the first Structure, so that the Array shape is the same as the Variable.
-   * To read the data in all structures, use readAllStructures().
-   * <p/>
-   * Note this only allows you to specify a subset of this variable.
-   * If the variable is nested in a array of structures and you want to subset that, use
-   * NetcdfFile.read(String sectionSpec, boolean flatten);
-   *
-   * @param section list of Range specifying the section of data to read.
-   *                Must be null or same rank as variable.
-   *                If list is null, assume all data.
-   *                Each Range corresponds to a Dimension. If the Range object is null, it means use the entire dimension.
-   * @return the requested data in a memory-resident Array
-   * @throws IOException if error
-   * @throws InvalidRangeException if section is invalid
-   */
-  public Array read(ucar.ma2.Section section) throws java.io.IOException, ucar.ma2.InvalidRangeException {
-    return (section == null) ? _read() : _read(Section.fill(section, shape));
-  }
-
-  /**
-   * Read all the data for this Variable and return a memory resident Array.
-   * The Array has the same element type and shape as the Variable.
-   * <p/>
-   * If the Variable is a member of an array of Structures, this returns only the variable's data
-   * in the first Structure, so that the Array shape is the same as the Variable.
-   * To read the data in all structures, use readAllStructures().
-   *
-   * @return the requested data in a memory-resident Array.
-   */
-  public Array read() throws IOException {
-    return _read();
-  }
-
-  /**
-   * *********************************************************************
-   */
-  // scalar reading
-
-  /**
-   * Get the value as a byte for a scalar Variable. May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
-   * @throws ForbiddenConversionException  if data type not convertible to byte
-   */
-  public byte readScalarByte() throws IOException {
-    Array data = getScalarData();
-    return data.getByte(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a short for a scalar Variable.  May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable  or one-dimensional of length 1.
-   * @throws ForbiddenConversionException  if data type not convertible to short
-   */
-  public short readScalarShort() throws IOException {
-    Array data = getScalarData();
-    return data.getShort(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a int for a scalar Variable. May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
-   * @throws ForbiddenConversionException  if data type not convertible to int
-   */
-  public int readScalarInt() throws IOException {
-    Array data = getScalarData();
-    return data.getInt(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a long for a scalar Variable.  May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable
-   * @throws ForbiddenConversionException  if data type not convertible to long
-   */
-  public long readScalarLong() throws IOException {
-    Array data = getScalarData();
-    return data.getLong(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a float for a scalar Variable.  May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
-   * @throws ForbiddenConversionException  if data type not convertible to float
-   */
-  public float readScalarFloat() throws IOException {
-    Array data = getScalarData();
-    return data.getFloat(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a double for a scalar Variable.  May also be one-dimensional of length 1.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
-   * @throws ForbiddenConversionException  if data type not convertible to double
-   */
-  public double readScalarDouble() throws IOException {
-    Array data = getScalarData();
-    return data.getDouble(Index.scalarIndexImmutable);
-  }
-
-  /**
-   * Get the value as a String for a scalar Variable.  May also be one-dimensional of length 1.
-   * May also be one-dimensional of type CHAR, which wil be turned into a scalar String.
-   *
-   * @throws IOException                   if theres an IO Error
-   * @throws UnsupportedOperationException if not a scalar or one-dimensional.
-   * @throws ClassCastException            if data type not DataType.STRING or DataType.CHAR.
-   */
-  public String readScalarString() throws IOException {
-    Array data = getScalarData();
-    if (dataType == DataType.STRING)
-      return (String) data.getObject(Index.scalarIndexImmutable);
-    else if (dataType == DataType.CHAR) {
-      ArrayChar dataC = (ArrayChar) data;
-      return dataC.getString();
-    } else
-      throw new IllegalArgumentException("readScalarString not STRING or CHAR " + getFullName());
-  }
-
-  protected Array getScalarData() throws IOException {
-    Array scalarData = (cache != null && cache.data != null) ? cache.data : read();
-    scalarData = scalarData.reduce();
-
-    if ((scalarData.getRank() == 0) || ((scalarData.getRank() == 1) && dataType == DataType.CHAR))
-      return scalarData;
-    throw new java.lang.UnsupportedOperationException("not a scalar variable =" + this);
-  }
-
-  ///////////////
-  // internal reads: all other calls go through these.
-  // subclasses must override, so that NetcdfDataset wrapping will work.
-
-  // non-structure-member Variables.
-
-  protected Array _read() throws IOException {
-    // caching overrides the proxyReader
-    // check if already cached
-    if (cache != null && cache.data != null) {
-      if (debugCaching) System.out.println("got data from cache " + getFullName());
-      return cache.data.copy();
-    }
-
-    Array data = proxyReader.reallyRead(this, null);
-
-    // optionally cache it
-    if (isCaching()) {
-      setCachedData(data);
-      if (debugCaching) System.out.println("cache " + getFullName());
-      return cache.data.copy(); // dont let users get their nasty hands on cached data
-    } else {
-      return data;
-    }
-  }
-
- /**
-   * public by accident, do not call directly.
-   * @return Array
-   * @throws IOException on error
-   */
-  @Override
-  public Array reallyRead(Variable client, CancelTask cancelTask) throws IOException {
-   if (isMemberOfStructure()) { // LOOK should be UnsupportedOperationException ??
-     List<String> memList = new ArrayList<String>();
-     memList.add(this.getShortName());
-     Structure s = parent.select(memList);
-     ArrayStructure as = (ArrayStructure) s.read();
-     return as.extractMemberArray( as.findMember( shortName));
-   }
-
-    try {
-      return ncfile.readData(this, getShapeAsSection());
-    } catch (InvalidRangeException e) {
-      e.printStackTrace();
-      throw new IOException(e.getMessage()); // cant happen haha
-    }
-  }
-
-  // section of non-structure-member Variable
-  // assume filled, validated Section
-  protected Array _read(Section section) throws IOException, InvalidRangeException {
-    // check if its really a full read
-    if ((null == section) || section.computeSize() == getSize())
-      return _read();
-
-    // full read was cached
-    if (isCaching()) {
-      if (cache.data == null) {
-        setCachedData(  _read()); // read and cache entire array
-        if (debugCaching) System.out.println("cache " + getFullName());
-      }
-      if (debugCaching) System.out.println("got data from cache " + getFullName());
-      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy
-    }
-
-    return proxyReader.reallyRead(this, section, null);
-  }
-
-   /**
-   * public by accident, do not call directly.
-   * @return Array
-   * @throws IOException on error
-   */
-  @Override
-  public Array reallyRead(Variable client, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {
-    if (isMemberOfStructure()) {
-      throw new UnsupportedOperationException("Cannot directly read section of Member Variable="+getFullName());
-    }
-    // read just this section
-    return ncfile.readData(this, section);
-  }
-
-  /* structure-member Variable;  section has a Range for each array in the parent
-  // stuctures(s) and for the Variable.
-  private Array _readMemberData(List<Range> section, boolean flatten) throws IOException, InvalidRangeException {
-    /*Variable useVar = (ioVar != null) ? ioVar : this;
-    NetcdfFile useFile = (ncfileIO != null) ? ncfileIO : ncfile;
-    return useFile.readMemberData(useVar, section, flatten);
-  } */
-
-  public long readToByteChannel(Section section, WritableByteChannel wbc) throws IOException, InvalidRangeException {
-    if ((ncfile == null) || hasCachedData())
-      return IospHelper.copyToByteChannel( read(section), wbc);
-    
-    return ncfile.readToByteChannel(this, section, wbc);
-  }
-
-  /*******************************************/
-  /* nicely formatted string representation */
-
-  /**
-   * Get the display name plus the dimensions, eg 'float name(dim1, dim2)'
-   * @return display name plus the dimensions
-   */
-  public String getNameAndDimensions() {
-    Formatter buf = new Formatter();
-    getNameAndDimensions(buf, true, false);
-    return buf.toString();
-  }
-
-  /**
-   * Get the display name plus the dimensions, eg 'float name(dim1, dim2)'
-   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
-   * @return display name plus the dimensions
-   */
-  public String getNameAndDimensions(boolean strict) {
-    Formatter buf = new Formatter();
-    getNameAndDimensions(buf, false, strict);
-    return buf.toString();
-  }
-
-  /**
-   * Get the display name plus the dimensions, eg 'name(dim1, dim2)'
-   * @param buf add info to this StringBuilder
-   */
-  public void getNameAndDimensions(StringBuilder buf) {
-    getNameAndDimensions(buf, true, false);
-  }
-
-  /**
-   * Get the display name plus the dimensions, eg 'name(dim1, dim2)'
-   * @param buf add info to this StringBuffer
-   * @deprecated use getNameAndDimensions(StringBuilder buf)
-   */
-  public void getNameAndDimensions(StringBuffer buf) {
-    Formatter proxy = new Formatter();
-    getNameAndDimensions(proxy, true, false);
-    buf.append(proxy.toString());
-  }
-
-  /**
-   * Add display name plus the dimensions to the StringBuffer
-   * @param buf add info to this
-   * @param useFullName use full name else short name. strict = true implies short name
-   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
-   */
-  public void getNameAndDimensions(StringBuilder buf, boolean useFullName, boolean strict) {
-    Formatter proxy = new Formatter();
-    getNameAndDimensions(proxy, useFullName, strict);
-    buf.append(proxy.toString());
-  }
-
-
-  /**
-   * Add display name plus the dimensions to the StringBuffer
-   * @param buf add info to this
-   * @param useFullName use full name else short name. strict = true implies short name
-   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
-   */
-  public void getNameAndDimensions(Formatter buf, boolean useFullName, boolean strict) {
-    useFullName = useFullName && !strict;
-    String name = useFullName ? getFullName() : getShortName();
-    if (strict) name = NetcdfFile.escapeNameCDL( getShortName());
-    buf.format("%s", name);
-
-    if (getRank() > 0) buf.format("(");
-    for (int i = 0; i < dimensions.size(); i++) {
-      Dimension myd = dimensions.get(i);
-      String dimName = myd.getName();
-      if ((dimName != null) && strict)
-        dimName = NetcdfFile.escapeNameCDL(dimName);
-
-      if (i != 0) buf.format(", ");
-
-      if (myd.isVariableLength()) {
-        buf.format("*");
-      } else if (myd.isShared()) {
-        if (!strict)
-          buf.format("%s=%d",dimName,myd.getLength());
-        else
-          buf.format("%s",dimName);
-      } else {
-        if (dimName != null) {
-          buf.format("%s=", dimName);
-        }
-        buf.format("%d", myd.getLength());
-      }
-    }
-
-    if (getRank() > 0) buf.format(")");
-  }
-
-  /**
-   * CDL representation of Variable, not strict.
-   */
-  public String toString() {
-    return writeCDL("   ", false, false);
-  }
-
-  /**
-   * CDL representation of a Variable.
-   *
-   * @param indent      start each line with this much space
-   * @param useFullName use full name, else use short name
-   * @param strict      strictly comply with ncgen syntax
-   * @return CDL representation of the Variable.
-   */
-  public String writeCDL(String indent, boolean useFullName, boolean strict) {
-    Formatter buf = new Formatter();
-    writeCDL(buf, indent, useFullName, strict);
-    return buf.toString();
-  }
-
-  protected void writeCDL(Formatter buf, String indent, boolean useFullName, boolean strict) {
-    buf.format(indent);
-    if (dataType.isEnum()) {
-      if (enumTypedef == null)
-        buf.format("enum UNKNOWN");
-      else
-        buf.format("enum %s", NetcdfFile.escapeNameCDL(enumTypedef.getName()));
-    } else
-      buf.format(dataType.toString());
-
-    //if (isVariableLength) buf.append("(*)"); // LOOK
-    buf.format(" ");
-    getNameAndDimensions(buf, useFullName, strict);
-    buf.format(";");
-    if (!strict) buf.format(extraInfo());
-    buf.format("\n");
-
-    for (Attribute att : getAttributes()) {
-      buf.format("%s  ", indent);
-      if (strict) buf.format( NetcdfFile.escapeNameCDL(getShortName()));
-      buf.format(":%s;", att.toString(strict));
-      if (!strict && (att.getDataType() != DataType.STRING))
-        buf.format(" // %s", att.getDataType());
-      buf.format("\n");
-    }
-  }
-
-  /**
-   * String representation of Variable and its attributes.
-   */
-  public String toStringDebug() {
-    return ncfile.toStringDebug(this);
-  }
-
-  private static boolean showSize = false;
-
-  protected String extraInfo() {
-    return showSize ? " // " + getElementSize() + " " + getSize() : "";
-  }
-
-  /**
-   * Instances which have same content are equal.
-   */
-  public boolean equals(Object oo) {
-    if (this == oo) return true;
-    if (!(oo instanceof Variable)) return false;
-    Variable o = (Variable) oo;
-
-    if (!getShortName().equals(o.getShortName())) return false;
-    if (isScalar() != o.isScalar()) return false;
-    if (getDataType() != o.getDataType()) return false;
-    if (!getParentGroup().equals(o.getParentGroup())) return false;
-    if ((getParentStructure() != null) && !getParentStructure().equals(o.getParentStructure())) return false;
-    if (isVariableLength() != o.isVariableLength()) return false;
-    if (dimensions.size() != o.getDimensions().size()) return false;
-    for (int i=0; i<dimensions.size(); i++)
-      if (!getDimension(i).equals(o.getDimension(i))) return false;
-
-    return true;
-  }
-
-  /**
-   * Override Object.hashCode() to implement equals.
-   */
-  public int hashCode() {
-    if (hashCode == 0) {
-      int result = 17;
-      result = 37 * result + getShortName().hashCode();
-      if (isScalar()) result++;
-      result = 37 * result + getDataType().hashCode();
-      result = 37 * result + getParentGroup().hashCode();
-      if (parent != null)
-        result = 37 * result + parent.hashCode();
-      if (isVariableLength) result++;
-      result = 37 * result + dimensions.hashCode();
-      hashCode = result;
-    }
-    return hashCode;
-  }
-
-  protected int hashCode = 0;
-
-  /**
-   * Sort by name
-   */
-  public int compareTo(VariableSimpleIF o) {
-    return getShortName().compareTo(o.getShortName());
-  }
-
-  /////////////////////////////////////////////////////////////////////////////
-
-  protected Variable() {
-  }
-
-  /**
-   * Create a Variable. Also must call setDataType() and setDimensions()
-   *
-   * @param ncfile    the containing NetcdfFile.
-   * @param group     the containing group; if null, use rootGroup
-   * @param parent    parent Structure, may be null
-   * @param shortName variable shortName, must be unique within the Group
-   */
-  public Variable(NetcdfFile ncfile, Group group, Structure parent, String shortName) {
-    this.ncfile = ncfile;
-    this.group = (group == null) ? ncfile.getRootGroup() : group;
-    this.parent = parent;
-    this.shortName = shortName;
-  }
-
-  /**
-   * Create a Variable. Also must call setDataType() and setDimensions()
-   *
-   * @param ncfile    the containing NetcdfFile.
-   * @param group     the containing group; if null, use rootGroup
-   * @param parent    parent Structure, may be null
-   * @param shortName variable shortName, must be unique within the Group
-   * @param dtype     the Variable's DataType
-   * @param dims      space delimited list of dimension names. may be null or "" for scalars.
-   */
-  public Variable(NetcdfFile ncfile, Group group, Structure parent, String shortName, DataType dtype, String dims) {
-    this.ncfile = ncfile;
-    this.group = (group == null) ? ncfile.getRootGroup() : group;
-    this.parent = parent;
-    this.shortName = shortName;
-    setDataType( dtype);
-    setDimensions( dims);
-  }
-
-  /**
-   * Copy constructor.
-   * The returned Variable is mutable.
-   * It shares the cache object and the iosp Object, attributes and dimensions with the original.
-   * Does not share the proxyReader.
-   * Use for section, slice, "logical views" of original variable.
-   *
-   * @param from copy from this Variable.
-   */
-  public Variable(Variable from) {
-    this.attributes = new ArrayList<Attribute>(from.attributes); // attributes are immutable
-    this.cache = from.cache; // caller should do createNewCache() if dont want to share
-    this.dataType = from.getDataType();
-    this.dimensions = new ArrayList<Dimension>(from.dimensions); // dimensions are shared
-    this.elementSize = from.getElementSize();
-    this.enumTypedef = from.enumTypedef;
-    this.group = from.group;
-    this.isMetadata = from.isMetadata;
-    this.isVariableLength = from.isVariableLength;
-    this.ncfile = from.ncfile;
-    this.parent = from.parent;
-    this.shape = from.getShape();
-    this.shortName = from.shortName;
-    this.sizeToCache = from.sizeToCache;
-    this.spiObject = from.spiObject;
-  }
-
-  ///////////////////////////////////////////////////
-  // the following make this mutable
-
-  /**
-   * Set the data type
-   *
-   * @param dataType set to this value
-   */
-  public void setDataType(DataType dataType) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.dataType = dataType;
-    this.elementSize = getDataType().getSize();
-  }
-
-  /**
-   * Set the short name, converting to valid CDM object name if needed.
-   *
-   * @param shortName set to this value
-   * @return valid CDM object name
-   */
-  public String setName(String shortName) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.shortName = NetcdfFile.makeValidCdmObjectName(shortName);
-    return this.shortName;
-  }
-
-  /**
-   * Set the parent group.
-   *
-   * @param group set to this value
-   */
-  public void setParentGroup(Group group) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.group = group;
-  }
-
-  /**
-   * Set the element size. Usually elementSize is determined by the dataType,
-   * use this only for exceptional cases.
-   *
-   * @param elementSize set to this value
-   */
-  public void setElementSize(int elementSize) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.elementSize = elementSize;
-  }
-
-  /**
-   * Add new or replace old if has same name
-   *
-   * @param att add this Attribute
-   * @return the added attribute
-   */
-  public Attribute addAttribute(Attribute att) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    for (int i = 0; i < attributes.size(); i++) {
-      Attribute a = attributes.get(i);
-      if (att.getName().equals(a.getName())) {
-        attributes.set(i, att); // replace
-        return att;
-      }
-    }
-    attributes.add(att);
-    return att;
-  }
-
-  /**
-   * Remove an Attribute : uses the attribute hashCode to find it.
-   *
-   * @param a remove this attribute
-   * @return true if was found and removed
-   */
-  public boolean remove(Attribute a) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    return a != null && attributes.remove(a);
-  }
-
-  /**
-   * Remove an Attribute by name.
-   *
-   * @param attName if exists, remove this attribute
-   * @return true if was found and removed
-   */
-  public boolean removeAttribute(String attName) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    Attribute att = findAttribute(attName);
-    return att != null && attributes.remove(att);
-  }
-
-  /**
-   * Remove an Attribute by name, ignoring case
-   *
-   * @param attName if exists, remove this attribute
-   * @return true if was found and removed
-   */
-  public boolean removeAttributeIgnoreCase(String attName) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    Attribute att = findAttributeIgnoreCase(attName);
-    return att != null && attributes.remove(att);
-  }
-
-  /**
-   * Set the shape with a list of Dimensions. The Dimensions may be shared or not.
-   * Dimensions are in order, slowest varying first. Send a null for a scalar.
-   * Technically you can use Dimensions from any group; pragmatically you should only use
-   * Dimensions contained in the Variable's parent groups.
-   *
-   * @param dims list of type ucar.nc2.Dimension
-   */
-  public void setDimensions(List<Dimension> dims) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.dimensions = (dims == null) ? new ArrayList<Dimension>() : new ArrayList<Dimension>(dims);
-    resetShape();
-  }
-
-  /**
-   * Use when dimensions have changed, to recalculate the shape.
-   */
-  public void resetShape() {
-    // if (immutable) throw new IllegalStateException("Cant modify");  LOOK allow this for unlimited dimension updating
-    this.shape = new int[dimensions.size()];
-    for (int i = 0; i < dimensions.size(); i++) {
-      Dimension dim = dimensions.get(i);
-      shape[i] = dim.getLength();
-      //shape[i] = Math.max(dim.getLength(), 0); // LOOK
-      // if (dim.isUnlimited() && (i != 0)) // LOOK only true for Netcdf-3
-      //   throw new IllegalArgumentException("Unlimited dimension must be outermost");
-      if (dim.isVariableLength()) {
-        //if (dimensions.size() != 1)
-        //  throw new IllegalArgumentException("Unknown dimension can only be used in 1 dim array");
-        //else
-          isVariableLength = true;
-      }
-    }
-    this.shapeAsSection = null; // recalc next time its asked for
-  }
-
-  /**
-   * Set the dimensions using the dimensions names. The dimension is searched for recursively in the parent groups.
-   *
-   * @param dimString : whitespace seperated list of dimension names, or '*' for Dimension.UNKNOWN. null or empty String is a scalar.
-   */
-  public void setDimensions(String dimString) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    List<Dimension> newDimensions = new ArrayList<Dimension>();
-
-    if ((dimString == null) || (dimString.length() == 0)) { // scalar
-      this.dimensions = newDimensions;
-      resetShape();
-      return;
-    }
-
-    StringTokenizer stoke = new StringTokenizer(dimString);
-    while (stoke.hasMoreTokens()) {
-      String dimName = stoke.nextToken();
-      Dimension d = dimName.equals("*") ? Dimension.VLEN : group.findDimension(dimName);
-      if (d == null) {
-        // if numeric - then its anonymous dimension
-        try {
-          int len = Integer.parseInt(dimName);
-          d = new Dimension("", len, false, false, false);
-        } catch (Exception e)  {
-          throw new IllegalArgumentException("Variable " + getFullName() + " setDimensions = " + dimString +
-              " FAILED, dim doesnt exist=" + dimName+ " file = "+ncfile.getLocation());
-        }
-      }
-      newDimensions.add(d);
-    }
-
-    this.dimensions = newDimensions;
-    resetShape();
-  }
-
-  /**
-   * Reset the dimension array. Anonymous dimensions are left alone.
-   * Shared dimensions are searched for recursively in the parent groups.
-   */
-  public void resetDimensions() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    ArrayList<Dimension> newDimensions = new ArrayList<Dimension>();
-
-    for (Dimension dim : dimensions) {
-      if (dim.isShared()) {
-        Dimension newD = group.findDimension(dim.getName());
-        if (newD == null)
-          throw new IllegalArgumentException("Variable " + getFullName() + " resetDimensions  FAILED, dim doesnt exist in parent group=" + dim);
-        newDimensions.add(newD);
-      } else {
-        newDimensions.add( dim);
-      }
-    }
-    this.dimensions = newDimensions;
-    resetShape();
-  }
-
-  /**
-   * Set the dimensions using all anonymous (unshared) dimensions
-   *
-   * @param shape defines the dimension lengths. must be > 0, or -1 for VLEN
-   * @throws ucar.ma2.InvalidRangeException if any shape < 1
-   */
-  public void setDimensionsAnonymous(int[] shape) throws InvalidRangeException {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.dimensions = new ArrayList<Dimension>();
-    for (int i = 0; i < shape.length; i++) {
-      if ((shape[i] < 1) &&  (shape[i] != -1)) throw new InvalidRangeException("shape[" + i + "]=" + shape[i] + " must be > 0");
-      Dimension anon;
-      if (shape[i] == -1) {
-        anon = Dimension.VLEN;
-        isVariableLength = true;
-      } else {
-        anon = new Dimension(null, shape[i], false, false, false);
-      }
-
-      dimensions.add(anon);
-    }
-    resetShape();
-  }
-
-  /**
-   * Set this Variable to be a scalar
-   */
-  public void setIsScalar() {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.dimensions = new ArrayList<Dimension>();
-    resetShape();
-  }
-
-  /**
-   * Replace a dimension with an equivalent one.
-   * @param dim must have the same name, length as old one
-   *
-  public void replaceDimension( Dimension dim) {
-  int idx = findDimensionIndex( dim.getName());
-  if (idx >= 0)
-  dimensions.set( idx, dim);
-  resetShape();
-  } */
-
-  /**
-   * Replace a dimension with an equivalent one.
-   *
-   * @param idx index into dimension array
-   * @param dim to set
-   */
-  public void setDimension(int idx, Dimension dim) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    dimensions.set(idx, dim);
-    resetShape();
-  }
-
-  /**
-   * Make this immutable.
-   * @return this
-   */
-  public Variable setImmutable() {
-    immutable = true;
-    dimensions = Collections.unmodifiableList(dimensions);
-    attributes = Collections.unmodifiableList(attributes);
-    return this;
-  }
-
-  /**
-   * Is this Variable immutable
-   * @return if immutable
-   */
-  public boolean isImmutable() { return immutable; }
-
-
-  // for IOServiceProvider
-  protected Object spiObject;
-
-  /**
-   * Should not be public.
-   * @return the IOSP object
-   */
-  public Object getSPobject() {
-    return spiObject;
-  }
-
-  /**
-   * Should not be public.
-   * @param spiObject the IOSP object
-   */
-  public void setSPobject(Object spiObject) {
-    this.spiObject = spiObject;
-  }
-
-  ////////////////////////////////////////////////////////////////////////////////////
-  // caching
-
-  /**
-   * If total data size is less than SizeToCache in bytes, then cache.
-   *
-   * @return size at which caching happens
-   */
-  public int getSizeToCache() {
-    if (sizeToCache >= 0) return sizeToCache; // it was set
-    return isCoordinateVariable() ? defaultCoordsSizeToCache : defaultSizeToCache;
-  }
-
-  /**
-   * Set the sizeToCache. If not set, use defaults
-   *
-   * @param sizeToCache size at which caching happens. < 0 means use defaults
-   */
-  public void setSizeToCache(int sizeToCache) {
-    this.sizeToCache = sizeToCache;
-  }
-
-  /**
-   * Set whether to cache or not. Implies that the entire array will be stored, once read.
-   * Normally this is set automatically based on size of data.
-   *
-   * @param caching set if caching.
-   */
-  public void setCaching(boolean caching) {
-    this.cache.isCaching = caching;
-    this.cache.cachingSet = true;
-  }
-
-  /**
-   * Will this Variable be cached when read.
-   * Set externally, or calculated based on total size < sizeToCache.
-   *
-   * @return true is caching
-   */
-  public boolean isCaching() {
-    if (!this.cache.cachingSet) {
-      cache.isCaching = !isVariableLength && (getSize() * getElementSize() < getSizeToCache());
-      this.cache.cachingSet = true;
-    }
-    return cache.isCaching;
-  }
-
-  /**
-   * Invalidate the data cache
-   */
-  public void invalidateCache() {
-    cache.data = null;
-  }
-
-  public void setCachedData(Array cacheData) {
-    setCachedData(cacheData, false);
-  }
-
-  //public Array getCachedData() {
-  //  return (cache == null) ? null : cache.data;
-  //}
-  /**
-   * Set the data cache
-   *
-   * @param cacheData  cache this Array
-   * @param isMetadata : synthesized data, set true if must be saved in NcML output (ie data not actually in the file).
-   */
-  public void setCachedData(Array cacheData, boolean isMetadata) {
-    if ((cacheData != null) && (cacheData.getElementType() != getDataType().getPrimitiveClassType()))
-      throw new IllegalArgumentException("setCachedData type="+cacheData.getElementType()+" incompatible with variable type="+getDataType());
-
-    //if (cacheData.getSize() > 10 * 1000 * 1000)
-    //   System.out.println("HEY");   
-
-    this.cache.data = cacheData;
-    this.isMetadata = isMetadata;
-    this.cache.cachingSet = true;
-    this.cache.isCaching = true;
-  }
-
-  /**
-   * Create a new data cache, use this when you dont want to share the cache.
-   */
-  public void createNewCache() {
-    this.cache = new Cache();
-  }
-
-  /**
-   * Has data been read and cached.
-   * Use only on a Variable, not a subclass.
-   * @return true if data is read and cached
-   */
-  public boolean hasCachedData() {
-    return (cache != null) && (null != cache.data);
-  }
-
-  // this indirection allows us to share the cache among the variable's sections and copies
-  static protected class Cache {
-    public Array data;
-    public boolean isCaching = false;
-    public boolean cachingSet = false;
-
-    public Cache() {
-    }
-  }
-
-  ///////////////////////////////////////////////////////////////////////
-  // setting variable data values
-
-  /**
-   * Generate the list of values from a starting value and an increment.
-   * Will reshape to variable if needed.
-   *
-   * @param npts  number of values, must = v.getSize()
-   * @param start starting value
-   * @param incr  increment
-   */
-  public void setValues(int npts, double start, double incr) {
-    if (npts != getSize())
-      throw new IllegalArgumentException("bad npts = " + npts + " should be " + getSize());
-    Array data = Array.makeArray(getDataType(), npts, start, incr);
-    if (getRank() != 1)
-      data = data.reshape(getShape());
-    setCachedData(data, true);
-  }
-
-  /**
-   * Set the data values from a list of Strings.
-   *
-   * @param values list of Strings
-   * @throws IllegalArgumentException if values array not correct size, or values wont parse to the correct type
-   */
-  public void setValues(List<String> values) throws IllegalArgumentException {
-    Array data = Array.makeArray(getDataType(), values);
-
-    if (data.getSize() != getSize())
-      throw new IllegalArgumentException("Incorrect number of values specified for the Variable " + getFullName() +
-              " needed= " + getSize() + " given=" + data.getSize());
-
-    if (getRank() != 1) // dont have to reshape for rank 1
-      data = data.reshape(getShape());
-
-    setCachedData(data, true);
-  }
-
-  ////////////////////////////////////////////////////////////////////////
-  // StructureMember - could be a subclass, but that has problems
-
-  /**
-   * Is this variable a member of a Structure?.
-   */
-  public boolean isMemberOfStructure() {
-    return parent != null;
-  }
-
-  /**
-   * Get the parent Variable if this is a member of a Structure, or null if its not.
-   */
-  public Structure getParentStructure() {
-    return parent;
-  }
-
-  /**
-   * Set the parent structure.
-   *
-   * @param parent set to this value
-   */
-  public void setParentStructure(Structure parent) {
-    if (immutable) throw new IllegalStateException("Cant modify");
-    this.parent = parent;
-  }
-
-  /**
-   * Get list of Dimensions, including parents if any.
-   *
-   * @return array of Dimension, rank of v plus all parents.
-   */
-  public List<Dimension> getDimensionsAll() {
-    List<Dimension> dimsAll = new ArrayList<Dimension>();
-    addDimensionsAll(dimsAll, this);
-    return dimsAll;
-  }
-
-  private void addDimensionsAll(List<Dimension> result, Variable v) {
-    if (v.isMemberOfStructure())
-      addDimensionsAll(result, v.getParentStructure());
-
-    for (int i=0; i<v.getRank(); i++)
-      result.add( v.getDimension(i));
-  }
-
-  public int[] getShapeAll() {
-    if (parent == null) return getShape();
-    List<Dimension> dimAll = getDimensionsAll();
-    int[] shapeAll = new int[dimAll.size()];
-    for (int i=0; i<dimAll.size(); i++)
-      shapeAll[i] = dimAll.get(i).getLength();
-    return shapeAll;
-  }
-
-
-  /*
-   * Read data in all structures for this Variable, using a string sectionSpec to specify the section.
-   * See readAllStructures(Section section, boolean flatten) method for details.
-   *
-   * @param sectionSpec specification string, eg "1:2,10,:,1:100:10"
-   * @param flatten     if true, remove enclosing StructureData.
-   * @return the requested data which has the shape of the request.
-   * @see #readAllStructures
-   * @deprecated
-   *
-  public Array readAllStructuresSpec(String sectionSpec, boolean flatten) throws IOException, InvalidRangeException {
-    return readAllStructures(new Section(sectionSpec), flatten);
-  }
-
-  /*
-   * Read data from all structures for this Variable.
-   * This is used for member variables whose parent Structure(s) is not a scalar.
-   * You must specify a Range for each dimension in the enclosing parent Structure(s).
-   * The returned Array will have the same shape as the requested section.
-   * <p/>
-   * <p>If flatten is false, return nested Arrays of StructureData that correspond to the nested Structures.
-   * The innermost Array(s) will match the rank and type of the Variable, but they will be inside Arrays of
-   * StructureData.
-   * <p/>
-   * <p>If flatten is true, remove the Arrays of StructureData that wrap the data, and return an Array of the
-   * same type as the Variable. The shape of the returned Array will be an accumulation of all the shapes of the
-   * Structures containing the variable.
-   *
-   * @param sectionAll an array of Range objects, one for each Dimension of the enclosing Structures, as well as
-   *                   for the Variable itself. If the list is null, use the full shape for everything.
-   *                   If an individual Range is null, use the full shape for that dimension.
-   * @param flatten    if true, remove enclosing StructureData. Otherwise, each parent Structure will create a
-   *                   StructureData container for the returned data array.
-   * @return the requested data which has the shape of the request.
-   * @deprecated
-   *
-  public Array readAllStructures(ucar.ma2.Section sectionAll, boolean flatten) throws java.io.IOException, ucar.ma2.InvalidRangeException {
-    Section resolved; // resolve all nulls
-    if (sectionAll == null)
-      resolved = makeSectionAddParents(null, false); // everything
-    else {
-      ArrayList<Range> resultAll = new ArrayList<Range>();
-      makeSectionWithParents(resultAll, sectionAll.getRanges(), this);
-      resolved = new Section(resultAll);
-    }
-
-    return _readMemberData(resolved, flatten);
-  }
-
-  // recursively create the section (list of Range) array
-  private List<Range> makeSectionWithParents(List<Range> result, List<Range> orgSection, Variable v) throws InvalidRangeException {
-    List<Range> section = orgSection;
-
-    // do parent stuctures(s) first
-    if (v.isMemberOfStructure())
-      section = makeSectionWithParents(result, orgSection, v.getParentStructure());
-
-    // process just this variable's subList
-    List<Range> myList = section.subList(0, v.getRank());
-    Section mySection = new Section(myList, v.getShape());
-    result.addAll(mySection.getRanges());
-
-    // return section with this variable's sublist removed
-    return section.subList(v.getRank(), section.size());
-  } */
-
-  /*
-   * Composes this variable's ranges with another list of ranges, adding parent ranges; resolves nulls.
-   *
-   * @param section   Section of this Variable, same rank as v, may have nulls or be null.
-   * @param firstOnly if true, get first parent, else get all parrents.
-   * @return Section, rank of v plus parents, no nulls
-   * @throws InvalidRangeException if bad
-   *
-  private Section makeSectionAddParents(Section section, boolean firstOnly) throws InvalidRangeException {
-    Section result;
-    if (section == null)
-      result = new Section(getRanges());
-    else
-      result = new Section(section.getRanges(), getShape());
-
-    // add parents
-    Structure p = getParentStructure();
-    while (p != null) {
-      Section parentSection = p.getShapeAsSection();
-      for (int i = parentSection.getRank() - 1; i >= 0; i--) { // reverse
-        Range r = parentSection.getRange(i);
-        result.insertRange(0, firstOnly ? new Range(0, 0) : r);
-      }
-      p = p.getParentStructure();
-    }
-
-    return result;
-  } */
-
-  /* private Array readMemberOfStructureFlatten(Section section) throws InvalidRangeException, IOException {
-    // get through first parents element
-    Section sectionAll = makeSectionAddParents(section, true);
-    Array data = _readMemberData(sectionAll, true); // flatten
-
-    // remove parent dimensions.
-    int n = data.getRank() - getRank();
-    for (int i = 0; i < n; i++)
-      if (data.getShape()[0] == 1) data = data.reduce(0);
-    return data;
-  }
-
-  /* structure-member Variable;  section has a Range for each array in the parent
-  // stuctures(s) and for the Variable.
-  protected Array _readMemberData(Section section, boolean flatten) throws IOException, InvalidRangeException {
-    return ncfile.readMemberData(this, section, flatten);
-  } */
-
-  ////////////////////////////////
-
-  /**
-   * Calculate if this is a classic coordinate variable: has same name as its first dimension.
-   * If type char, must be 2D, else must be 1D.
-   * @return true if a coordinate variable.
-   */
-  public boolean isCoordinateVariable() {
-    if ((dataType == DataType.STRUCTURE) || isMemberOfStructure()) // Structures and StructureMembers cant be coordinate variables
-      return false;
-
-    int n = getRank();
-    if (n == 1 && dimensions.size() == 1) {
-      Dimension firstd = dimensions.get(0);
-      if (shortName.equals(firstd.getName())) { //  : short names match
-        return true;
-      }
-    }
-    if (n == 2 && dimensions.size() == 2) {    // two dimensional
-      Dimension firstd = dimensions.get(0);
-      if (shortName.equals(firstd.getName()) &&  // short names match
-          (getDataType() == DataType.CHAR)) {         // must be char valued (really a String)
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  public Object clone()  throws CloneNotSupportedException
-  {
-      Variable clone = (Variable)super.clone();
-
-      // Do we need to clone these?
-      // protected Cache cache = new Cache();
-      // protected int sizeToCache = -1; // bytes
-
-      clone.setParentGroup(group);
-      clone.setParentStructure(parent);
-      clone.setProxyReader(clone);
-      return clone;
-  }
-
-
-  ///////////////////////////////////////////////////////////////////////
-  // deprecated
-  /**
-   * @deprecated use isVariableLength()
-   * @return isVariableLength()
-   */
-  public boolean isUnknownLength() {
-    return isVariableLength;
-  }
-}
+/*
+ * Copyright 1998-2009 University Corporation for Atmospheric Research/Unidata
+ *
+ * Portions of this software were developed by the Unidata Program at the
+ * University Corporation for Atmospheric Research.
+ *
+ * Access and use of this software shall impose the following obligations
+ * and understandings on the user. The user is granted the right, without
+ * any fee or cost, to use, copy, modify, alter, enhance and distribute
+ * this software, and any derivative works thereof, and its supporting
+ * documentation for any purpose whatsoever, provided that this entire
+ * notice appears in all copies of the software, derivative works and
+ * supporting documentation.  Further, UCAR requests that the user credit
+ * UCAR/Unidata in any publications that result from the use of this
+ * software or in any product that includes this software. The names UCAR
+ * and/or Unidata, however, may not be used in any advertising or publicity
+ * to endorse or promote any products or commercial entity unless specific
+ * written permission is obtained from UCAR/Unidata. The user also
+ * understands that UCAR/Unidata is not obligated to provide the user with
+ * any support, consulting, training or assistance of any kind with regard
+ * to the use, operation and performance of this software nor to provide
+ * the user with any updates, revisions, new versions or "bug fixes."
+ *
+ * THIS SOFTWARE IS PROVIDED BY UCAR/UNIDATA "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL UCAR/UNIDATA BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+package ucar.nc2;
+
+import ucar.ma2.*;
+import ucar.nc2.iosp.IospHelper;
+import ucar.nc2.util.CancelTask;
+
+import java.util.*;
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+/**
+ * A Variable is a logical container for data. It has a dataType, a set of Dimensions that define its array shape,
+ * and optionally a set of Attributes.
+ * <p/>
+ * The data is a multidimensional array of primitive types, Strings, or Structures.
+ * Data access is done through the read() methods, which return a memory resident Array.
+ * <p> Immutable if setImmutable() was called.
+ * @author caron
+ * @see ucar.ma2.Array
+ * @see ucar.ma2.DataType
+ */
+
+public class Variable implements VariableIF, ProxyReader {
+  static public final int defaultSizeToCache = 4000; // bytes  cache any variable whose size() < defaultSizeToCache
+  static public final int defaultCoordsSizeToCache = 40 * 1000; // bytes cache coordinate variable whose size() < defaultSizeToCache
+
+  static protected boolean debugCaching = false;
+  static private org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Variable.class);
+
+  protected NetcdfFile ncfile; // physical container for this Variable; where the I/O happens. may be null if Variable is self contained.
+  protected Group group; // logical container for this Variable. may not be null.
+  protected String shortName; // may not be blank; must not be escaped
+  protected int[] shape;
+  protected Section shapeAsSection;  // derived from the shape, immutable; used for every read, deferred creation
+
+  protected DataType dataType;
+  protected int elementSize;
+  protected List<Dimension> dimensions = new ArrayList<Dimension>(5);
+  protected List<Attribute> attributes = new ArrayList<Attribute>();
+
+  protected boolean isVariableLength = false;
+  protected boolean isMetadata = false;
+  private boolean immutable = false; // cache can change
+
+  protected Cache cache = new Cache();
+  protected int sizeToCache = -1; // bytes
+
+  protected Structure parent = null; // for variables inside a Structure, aka "structure members"
+  protected ProxyReader proxyReader = this;
+
+  /**
+   * Get the variable name.
+   * @return full unescaped name
+   * @deprecated use getFullName or getShortName
+   */
+  public String getName() {
+    return getFullName();
+  }
+
+  /**
+   * Get the full, unescaped name of this Variable, starting from rootGroup.
+   * The name is unique within the entire NetcdfFile.
+   * @return  full, unescaped name
+   */
+  public String getFullName() {
+    return NetcdfFile.makeFullName(this);
+  }
+
+  /**
+   * Get the full, escaped name of this Variable. Use for NetcdfFile.findVariable().
+   * @return  full, escaped name
+   * @see "http://www.unidata.ucar.edu/software/netcdf-java/CDM/Identifiers.html"
+   */
+  public String getFullNameEscaped() {
+    return NetcdfFile.makeFullNameEscaped(this);
+  }
+
+  /**
+   * Get the short name of this Variable. The name is unique within its parent group.
+   */
+  public String getShortName() {
+    return shortName;
+  }
+
+  /**
+   * Get the data type of the Variable.
+   */
+  public DataType getDataType() {
+    return dataType;
+  }
+
+  /**
+   * Get the shape: length of Variable in each dimension.
+   *
+   * @return int array whose length is the rank of this Variable
+   *         and whose values equal the length of that Dimension.
+   */
+  public int[] getShape() {
+    int[] result = new int[shape.length];  // optimization over clone()
+    System.arraycopy(shape, 0, result, 0, shape.length);
+    return result;
+  }
+
+  /**
+   * Get the size of the ith dimension
+   *
+   * @param index which dimension
+   * @return size of the ith dimension
+   */
+  public int getShape(int index) {
+    return shape[index];
+  }
+
+  /**
+   * Get the total number of elements in the Variable.
+   * If this is an unlimited Variable, will use the current number of elements.
+   * If this is a Sequence, will return 1.
+   * If variable length, will skip vlen dimensions
+   *
+   * @return total number of elements in the Variable.
+   */
+  public long getSize() {
+    long size = 1;
+    for (int i = 0; i < shape.length; i++) {
+      if (shape[i] >= 0)
+        size *= shape[i];
+    }
+    return size;
+  }
+
+  /**
+   * Get the number of bytes for one element of this Variable.
+   * For Variables of primitive type, this is equal to getDataType().getSize().
+   * Variables of String type dont know their size, so what they return is undefined.
+   * Variables of Structure type return the total number of bytes for all the members of
+   * one Structure, plus possibly some extra padding, depending on the underlying format.
+   * Variables of Sequence type return the number of bytes of one element.
+   *
+   * @return total number of bytes for the Variable
+   */
+  public int getElementSize() {
+    return elementSize;
+  }
+
+  /**
+   * Get the number of dimensions of the Variable.
+   * @return the rank
+   */
+  public int getRank() {
+    return shape.length;
+  }
+
+  /**
+   * Get the containing Group.
+   * @return the containing Group.
+   */
+  public Group getParentGroup() {
+    return group;
+  }
+
+  /**
+   * Is this variable metadata?. True if its values need to be included explicitly in NcML output.
+   * @return true if Variable values need to be included in NcML
+   */
+  public boolean isMetadata() {
+    return isMetadata;
+  }
+
+  /**
+   * Whether this is a scalar Variable (rank == 0).
+   * @return true if Variable has rank 0
+   */
+  public boolean isScalar() {
+    return getRank() == 0;
+  }
+
+  /**
+   * Does this variable have a variable length dimension?
+   * If so, it has as one of its dimensions Dimension.VLEN.
+   * @return true if Variable has a variable length dimension?
+   */
+  public boolean isVariableLength() {
+    return isVariableLength;
+  }
+
+  /**
+   * Is this Variable unsigned?. Only meaningful for byte, short, int, long types.
+   * Looks for attribute "_Unsigned", case insensitive
+   * @return true if Variable is unsigned
+   */
+  public boolean isUnsigned() {
+    Attribute att = findAttributeIgnoreCase("_Unsigned");
+    return (att != null) && att.getStringValue().equalsIgnoreCase("true");
+  }
+
+  /**
+   * Can this variable's size grow?.
+   * This is equivalent to saying at least one of its dimensions is unlimited.
+   *
+   * @return boolean true iff this variable can grow
+   */
+  public boolean isUnlimited() {
+    for (Dimension d : dimensions) {
+      if (d.isUnlimited()) return true;
+    }
+    return false;
+  }
+
+  /**
+   * Get the list of dimensions used by this variable.
+   * The most slowly varying (leftmost for Java and C programmers) dimension is first.
+   * For scalar variables, the list is empty.
+   *
+   * @return List<Dimension>, immutable
+   */
+  public java.util.List<Dimension> getDimensions() {
+    return dimensions;
+  }
+
+  /**
+   * Get the ith dimension.
+   *
+   * @param i index of the dimension.
+   * @return requested Dimension, or null if i is out of bounds.
+   */
+  public Dimension getDimension(int i) {
+    if ((i < 0) || (i >= getRank())) return null;
+    return dimensions.get(i);
+  }
+
+  /**
+   * Get the list of Dimension names, space delineated.
+   * @return Dimension names, space delineated
+   */
+  /* public String getDimensionsStringOld() {
+    StringBuilder buff = new StringBuilder();
+    for (int i = 0; i < dimensions.size(); i++) {
+      Dimension dim = dimensions.get(i);
+      if (i > 0) buff.append(" ");
+      buff.append(dim.getName());
+    }
+    return buff.toString();
+  }  */
+
+  public String getDimensionsString() {
+    Formatter buf = new Formatter();
+    for (int i = 0; i < dimensions.size(); i++) {
+      Dimension myd = dimensions.get(i);
+      String dimName = myd.getName();
+
+      if (i != 0) buf.format(" ");
+
+      if (myd.isVariableLength()) {
+        buf.format("*");
+      } else if (myd.isShared()) {
+        buf.format("%s", dimName);
+      } else {
+        //if (dimName != null)          // LOOK losing anon dim name
+        //  buf.format("%s=", dimName);
+        buf.format("%d", myd.getLength());
+      }
+    }
+    return buf.toString();
+  }
+  /**
+   * Find the index of the named Dimension in this Variable.
+   *
+   * @param name the name of the dimension
+   * @return the index of the named Dimension, or -1 if not found.
+   */
+  public int findDimensionIndex(String name) {
+    for (int i = 0; i < dimensions.size(); i++) {
+      Dimension d = dimensions.get(i);
+      if (name.equals(d.getName()))
+        return i;
+    }
+    return -1;
+  }
+
+  /**
+   * Returns the set of attributes for this variable.
+   *
+   * @return List<Attribute>, not a copy, but may be immutable
+   */
+  public java.util.List<Attribute> getAttributes() {
+    return attributes;
+  }
+
+  /**
+   * Find an Attribute by name.
+   *
+   * @param name the name of the attribute
+   * @return the attribute, or null if not found
+   */
+  public Attribute findAttribute(String name) {
+    for (Attribute a : attributes) {
+      if (name.equals(a.getName()))
+        return a;
+    }
+    return null;
+  }
+
+  /**
+   * Find an Attribute by name, ignoring the case.
+   *
+   * @param name the name of the attribute
+   * @return the attribute, or null if not found
+   */
+  public Attribute findAttributeIgnoreCase(String name) {
+    for (Attribute a : attributes) {
+      if (name.equalsIgnoreCase(a.getName()))
+        return a;
+    }
+    return null;
+  }
+
+  /**
+   * Get the description of the Variable.
+   * Default is to use "long_name" attribute value. If not exist, look for "description", "title", or
+   * "standard_name" attribute value (in that order).
+   *
+   * @return description, or null if not found.
+   */
+  public String getDescription() {
+    String desc = null;
+    Attribute att = findAttributeIgnoreCase("long_name");
+    if ((att != null) && att.isString())
+      desc = att.getStringValue();
+
+    if (desc == null) {
+      att = findAttributeIgnoreCase("description");
+      if ((att != null) && att.isString())
+        desc = att.getStringValue();
+    }
+
+    if (desc == null) {
+      att = findAttributeIgnoreCase("title");
+      if ((att != null) && att.isString())
+        desc = att.getStringValue();
+    }
+
+    if (desc == null) {
+      att = findAttributeIgnoreCase("standard_name");
+      if ((att != null) && att.isString())
+        desc = att.getStringValue();
+    }
+
+    return desc;
+  }
+
+  /**
+   * Get the Unit String for the Variable.
+   * Looks for the "units" attribute value
+   *
+   * @return unit string, or null if not found.
+   */
+  public String getUnitsString() {
+    String units = null;
+    Attribute att = findAttributeIgnoreCase("units");
+    if ((att != null) && att.isString()) {
+      units = att.getStringValue();
+      if (units != null) units = units.trim();
+    }
+    return units;
+  }
+
+  /**
+   * Get shape as an List of Range objects.
+   * The List is immutable.
+   * @return List of Ranges, one for each Dimension.
+   */
+  public List<Range> getRanges() {
+    return getShapeAsSection().getRanges();
+  }
+
+  /**
+   * Get shape as a Section object.
+   * @return Section containing List<Range>, one for each Dimension.
+   */
+  public Section getShapeAsSection() {
+    if (shapeAsSection == null) {
+      try {
+        List<Range> list = new ArrayList<Range>();
+        for (Dimension d : dimensions) {
+          int len = d.getLength();
+          if (len > 0)
+            list.add(new Range(d.getName(), 0, len - 1));
+          else if (len == 0)
+            list.add( Range.EMPTY); // LOOK empty not named
+          else
+            list.add( Range.VLEN); // LOOK vlen not named
+        }
+        shapeAsSection = new Section(list).makeImmutable();
+        
+      } catch (InvalidRangeException e) {
+        log.error("Bad shape in variable " + getFullName(), e);
+        throw new IllegalStateException(e.getMessage());
+      }
+    }
+    return shapeAsSection;
+  }
+
+  public ProxyReader getProxyReader() {
+    return proxyReader;
+  }
+
+  public void setProxyReader(ProxyReader proxyReader) {
+    this.proxyReader = proxyReader;
+  }
+
+
+  /** Get the proxy reader, or null.
+   * @return return the proxy reader, if any
+   *
+  public ProxyReader getProxyReader() {
+    return this.postReader;
+  } */
+
+  /**
+   * Create a new Variable that is a logical subsection of this Variable.
+   * No data is read until a read method is called on it.
+   *
+   * @param ranges List of type ucar.ma2.Range, with size equal to getRank().
+   *               Each Range corresponds to a Dimension, and specifies the section of data to read in that Dimension.
+   *               A Range object may be null, which means use the entire dimension.
+   * @return a new Variable which is a logical section of this Variable.
+   * @throws InvalidRangeException
+   */
+  public Variable section(List<Range> ranges) throws InvalidRangeException {
+    return section(new Section(ranges, shape).makeImmutable());
+  }
+
+  /**
+   * Create a new Variable that is a logical subsection of this Variable.
+   * No data is read until a read method is called on it.
+   *
+   * @param subsection Section of this variable.
+   *                   Each Range in the section corresponds to a Dimension, and specifies the section of data to read in that Dimension.
+   *                   A Range object may be null, which means use the entire dimension.
+   * @return a new Variable which is a logical section of this Variable.
+   * @throws InvalidRangeException if section not compatible with shape
+   */
+  public Variable section(Section subsection) throws InvalidRangeException {
+
+    subsection = Section.fill(subsection, shape);
+
+    // create a copy of this variable with a proxy reader
+    Variable sectionV = copy(); // subclasses must override
+    sectionV.setProxyReader( new SectionReader(this, subsection));
+    sectionV.shape = subsection.getShape();
+    sectionV.createNewCache(); // dont share the cache
+    sectionV.setCaching(false); // dont cache
+    
+    // replace dimensions if needed !! LOOK not shared
+    sectionV.dimensions = new ArrayList<Dimension>();
+    for (int i = 0; i < getRank(); i++) {
+      Dimension oldD = getDimension(i);
+      Dimension newD = (oldD.getLength() == sectionV.shape[i]) ? oldD : new Dimension(oldD.getName(), sectionV.shape[i], false);
+      newD.setUnlimited(oldD.isUnlimited());
+      sectionV.dimensions.add(newD);
+    }
+    sectionV.resetShape();
+    return sectionV;
+  }
+
+
+  /**
+   * Create a new Variable that is a logical slice of this Variable, by
+   * fixing the specified dimension at the specified index value. This reduces rank by 1.
+   * No data is read until a read method is called on it.
+   *
+   * @param dim   which dimension to fix
+   * @param value at what index value
+   * @return a new Variable which is a logical slice of this Variable.
+   * @throws InvalidRangeException if dimension or value is illegal
+   */
+  public Variable slice(int dim, int value) throws InvalidRangeException {
+    if ((dim < 0) || (dim >= shape.length))
+      throw new InvalidRangeException("Slice dim invalid= " + dim);
+
+    // ok to make slice of record dimension with length 0
+    boolean recordSliceOk = false;
+    if ((dim == 0) && (value == 0)) {
+      Dimension d = getDimension(0);
+      recordSliceOk = d.isUnlimited();
+    }
+
+    // otherwise check slice in range
+    if (!recordSliceOk) {
+      if ((value < 0) || (value >= shape[dim]))
+        throw new InvalidRangeException("Slice value invalid= " + value + " for dimension " + dim);
+    }
+
+    // create a copy of this variable with a proxy reader
+    Variable sliceV = copy(); // subclasses must override
+    Section slice = new Section( getShapeAsSection());
+    slice.replaceRange(dim, new Range(value, value)).makeImmutable();
+    sliceV.setProxyReader( new SliceReader(this, dim, slice));
+    sliceV.createNewCache(); // dont share the cache
+    sliceV.setCaching(false); // dont cache
+
+    // remove that dimension - reduce rank
+    sliceV.dimensions.remove(dim);
+    sliceV.resetShape();
+    return sliceV;
+  }
+
+  protected Variable copy() {
+    return new Variable(this);
+  }
+
+  //////////////////////////////////////////////////////////////////////////////
+
+  /**
+   * Lookup the enum string for this value.
+   * Can only be called on enum types, where dataType.isEnum() is true.
+   * @param val the integer value of this enum
+   * @return the String value
+   */
+  public String lookupEnumString(int val) {
+    if (!dataType.isEnum())
+      throw new UnsupportedOperationException("Can only call Variable.lookupEnumVal() on enum types");
+    return enumTypedef.lookupEnumString(val);
+  }
+  private EnumTypedef enumTypedef;
+
+  /**
+   * Public by accident.
+   * @param enumTypedef set the EnumTypedef, only use if getDataType.isEnum()
+   */
+  public void setEnumTypedef(EnumTypedef enumTypedef) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    if (!dataType.isEnum())
+      throw new UnsupportedOperationException("Can only call Variable.setEnumTypedef() on enum types");
+    this.enumTypedef = enumTypedef;
+  }
+
+  public EnumTypedef getEnumTypedef() { return enumTypedef; }
+
+  //////////////////////////////////////////////////////////////////////////////
+  // IO
+  // implementation notes to subclassers
+  // all other calls use them, so override only these:
+  //   _read()
+  //   _read(Section section)
+  //   _readNestedData(Section section, boolean flatten)
+
+  /**
+   * Read a section of the data for this Variable and return a memory resident Array.
+   * The Array has the same element type as the Variable, and the requested shape.
+   * Note that this does not do rank reduction, so the returned Array has the same rank
+   * as the Variable. Use Array.reduce() for rank reduction.
+   * <p/>
+   * <code>assert(origin[ii] + shape[ii]*stride[ii] <= Variable.shape[ii]); </code>
+   * <p/>
+   *
+   * @param origin int array specifying the starting index. If null, assume all zeroes.
+   * @param shape  int array specifying the extents in each dimension.
+   *               This becomes the shape of the returned Array.
+   * @return the requested data in a memory-resident Array
+   */
+  public Array read(int[] origin, int[] shape) throws IOException, InvalidRangeException {
+    if ((origin == null) && (shape == null))
+      return read();
+
+    if (origin == null)
+      return read(new Section(shape));
+
+    if (shape == null) // LOOK not very useful, origin must be 0 to be valid
+      return read(new Section(origin, shape));
+
+    return read(new Section(origin, shape));
+  }
+
+  /**
+   * Return an ArrayLong structure with the same shape as the shape arguement
+   * where each entry is the offset in the byte-stream where the corresponding
+   * data element begins
+   * @param origin int array specifying the starting index. If null, assume all zeroes.
+   * @param shape  int array specifying the extents in each dimension.
+   *               This becomes the shape of the returned Array.
+   * @return a memory-resdient array of longs with offsets or -1 if the offset
+   *                for the corresponding cell can't be determined
+   */
+  public ArrayLong getLocalityInformation(int[] origin, int[] shape) throws IOException, InvalidRangeException {
+    return ncfile.getLocalityInformation( this, new Section(origin, shape));
+  }
+
+  public boolean supportsLocalityInformation() throws IOException {
+    return ncfile.supportsLocalityInformation();
+  }
+
+  /**
+   * Return an ArrayLong structure with the same shape as the shape arguement
+   * where each entry is the offset in the byte-stream where the corresponding
+   * data element begins.
+   *
+   * @param section list of Range specifying the section of data to read.
+   *                Must be null or same rank as variable.
+   *                If list is null, assume all data.
+   *                Each Range corresponds to a Dimension. If the Range object is null, it means use the entire dimension.
+   * @return a memory-resdient array of longs with offsets or -1 if the offset
+   *                for the corresponding cell can't be determined
+   */
+  public ArrayLong getLocalityInformation(Section section) throws IOException, InvalidRangeException {
+    return ncfile.getLocalityInformation(this, section);
+  }
+
+  /**
+   * Read data section specified by a "section selector", and return a memory resident Array. Uses
+   * Fortran 90 array section syntax.
+   *
+   * @param sectionSpec specification string, eg "1:2,10,:,1:100:10". May optionally have ().
+   * @return the requested data in a memory-resident Array
+   * @see ucar.ma2.Section for sectionSpec syntax
+   */
+  public Array read(String sectionSpec) throws IOException, InvalidRangeException {
+    return read(new Section(sectionSpec));
+  }
+
+  /**
+   * Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
+   *
+   * @param ranges list of Range specifying the section of data to read.
+   * @return the requested data in a memory-resident Array
+   * @see #read(Section)
+   * @throws IOException if error
+   * @throws InvalidRangeException if ranges is invalid
+   */
+  public Array read(List<Range> ranges) throws IOException, InvalidRangeException {
+    if (null == ranges)
+      return _read();
+
+    return read(new Section(ranges));
+  }
+
+  /**
+   * Read a section of the data for this Variable from the netcdf file and return a memory resident Array.
+   * The Array has the same element type as the Variable, and the requested shape.
+   * Note that this does not do rank reduction, so the returned Array has the same rank
+   * as the Variable. Use Array.reduce() for rank reduction.
+   * <p/>
+   * If the Variable is a member of an array of Structures, this returns only the variable's data
+   * in the first Structure, so that the Array shape is the same as the Variable.
+   * To read the data in all structures, use readAllStructures().
+   * <p/>
+   * Note this only allows you to specify a subset of this variable.
+   * If the variable is nested in a array of structures and you want to subset that, use
+   * NetcdfFile.read(String sectionSpec, boolean flatten);
+   *
+   * @param section list of Range specifying the section of data to read.
+   *                Must be null or same rank as variable.
+   *                If list is null, assume all data.
+   *                Each Range corresponds to a Dimension. If the Range object is null, it means use the entire dimension.
+   * @return the requested data in a memory-resident Array
+   * @throws IOException if error
+   * @throws InvalidRangeException if section is invalid
+   */
+  public Array read(ucar.ma2.Section section) throws java.io.IOException, ucar.ma2.InvalidRangeException {
+    return (section == null) ? _read() : _read(Section.fill(section, shape));
+  }
+
+  /**
+   * Read all the data for this Variable and return a memory resident Array.
+   * The Array has the same element type and shape as the Variable.
+   * <p/>
+   * If the Variable is a member of an array of Structures, this returns only the variable's data
+   * in the first Structure, so that the Array shape is the same as the Variable.
+   * To read the data in all structures, use readAllStructures().
+   *
+   * @return the requested data in a memory-resident Array.
+   */
+  public Array read() throws IOException {
+    return _read();
+  }
+
+  /**
+   * *********************************************************************
+   */
+  // scalar reading
+
+  /**
+   * Get the value as a byte for a scalar Variable. May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
+   * @throws ForbiddenConversionException  if data type not convertible to byte
+   */
+  public byte readScalarByte() throws IOException {
+    Array data = getScalarData();
+    return data.getByte(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a short for a scalar Variable.  May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable  or one-dimensional of length 1.
+   * @throws ForbiddenConversionException  if data type not convertible to short
+   */
+  public short readScalarShort() throws IOException {
+    Array data = getScalarData();
+    return data.getShort(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a int for a scalar Variable. May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
+   * @throws ForbiddenConversionException  if data type not convertible to int
+   */
+  public int readScalarInt() throws IOException {
+    Array data = getScalarData();
+    return data.getInt(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a long for a scalar Variable.  May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable
+   * @throws ForbiddenConversionException  if data type not convertible to long
+   */
+  public long readScalarLong() throws IOException {
+    Array data = getScalarData();
+    return data.getLong(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a float for a scalar Variable.  May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
+   * @throws ForbiddenConversionException  if data type not convertible to float
+   */
+  public float readScalarFloat() throws IOException {
+    Array data = getScalarData();
+    return data.getFloat(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a double for a scalar Variable.  May also be one-dimensional of length 1.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar Variable or one-dimensional of length 1.
+   * @throws ForbiddenConversionException  if data type not convertible to double
+   */
+  public double readScalarDouble() throws IOException {
+    Array data = getScalarData();
+    return data.getDouble(Index.scalarIndexImmutable);
+  }
+
+  /**
+   * Get the value as a String for a scalar Variable.  May also be one-dimensional of length 1.
+   * May also be one-dimensional of type CHAR, which wil be turned into a scalar String.
+   *
+   * @throws IOException                   if theres an IO Error
+   * @throws UnsupportedOperationException if not a scalar or one-dimensional.
+   * @throws ClassCastException            if data type not DataType.STRING or DataType.CHAR.
+   */
+  public String readScalarString() throws IOException {
+    Array data = getScalarData();
+    if (dataType == DataType.STRING)
+      return (String) data.getObject(Index.scalarIndexImmutable);
+    else if (dataType == DataType.CHAR) {
+      ArrayChar dataC = (ArrayChar) data;
+      return dataC.getString();
+    } else
+      throw new IllegalArgumentException("readScalarString not STRING or CHAR " + getFullName());
+  }
+
+  protected Array getScalarData() throws IOException {
+    Array scalarData = (cache != null && cache.data != null) ? cache.data : read();
+    scalarData = scalarData.reduce();
+
+    if ((scalarData.getRank() == 0) || ((scalarData.getRank() == 1) && dataType == DataType.CHAR))
+      return scalarData;
+    throw new java.lang.UnsupportedOperationException("not a scalar variable =" + this);
+  }
+
+  ///////////////
+  // internal reads: all other calls go through these.
+  // subclasses must override, so that NetcdfDataset wrapping will work.
+
+  // non-structure-member Variables.
+
+  protected Array _read() throws IOException {
+    // caching overrides the proxyReader
+    // check if already cached
+    if (cache != null && cache.data != null) {
+      if (debugCaching) System.out.println("got data from cache " + getFullName());
+      return cache.data.copy();
+    }
+
+    Array data = proxyReader.reallyRead(this, null);
+
+    // optionally cache it
+    if (isCaching()) {
+      setCachedData(data);
+      if (debugCaching) System.out.println("cache " + getFullName());
+      return cache.data.copy(); // dont let users get their nasty hands on cached data
+    } else {
+      return data;
+    }
+  }
+
+ /**
+   * public by accident, do not call directly.
+   * @return Array
+   * @throws IOException on error
+   */
+  @Override
+  public Array reallyRead(Variable client, CancelTask cancelTask) throws IOException {
+   if (isMemberOfStructure()) { // LOOK should be UnsupportedOperationException ??
+     List<String> memList = new ArrayList<String>();
+     memList.add(this.getShortName());
+     Structure s = parent.select(memList);
+     ArrayStructure as = (ArrayStructure) s.read();
+     return as.extractMemberArray( as.findMember( shortName));
+   }
+
+    try {
+      return ncfile.readData(this, getShapeAsSection());
+    } catch (InvalidRangeException e) {
+      e.printStackTrace();
+      throw new IOException(e.getMessage()); // cant happen haha
+    }
+  }
+
+  // section of non-structure-member Variable
+  // assume filled, validated Section
+  protected Array _read(Section section) throws IOException, InvalidRangeException {
+    // check if its really a full read
+    if ((null == section) || section.computeSize() == getSize())
+      return _read();
+
+    // full read was cached
+    if (isCaching()) {
+      if (cache.data == null) {
+        setCachedData(  _read()); // read and cache entire array
+        if (debugCaching) System.out.println("cache " + getFullName());
+      }
+      if (debugCaching) System.out.println("got data from cache " + getFullName());
+      return cache.data.sectionNoReduce(section.getRanges()).copy(); // subset it, return copy
+    }
+
+    return proxyReader.reallyRead(this, section, null);
+  }
+
+   /**
+   * public by accident, do not call directly.
+   * @return Array
+   * @throws IOException on error
+   */
+  @Override
+  public Array reallyRead(Variable client, Section section, CancelTask cancelTask) throws IOException, InvalidRangeException {
+    if (isMemberOfStructure()) {
+      throw new UnsupportedOperationException("Cannot directly read section of Member Variable="+getFullName());
+    }
+    // read just this section
+    return ncfile.readData(this, section);
+  }
+
+  /* structure-member Variable;  section has a Range for each array in the parent
+  // stuctures(s) and for the Variable.
+  private Array _readMemberData(List<Range> section, boolean flatten) throws IOException, InvalidRangeException {
+    /*Variable useVar = (ioVar != null) ? ioVar : this;
+    NetcdfFile useFile = (ncfileIO != null) ? ncfileIO : ncfile;
+    return useFile.readMemberData(useVar, section, flatten);
+  } */
+
+  public long readToByteChannel(Section section, WritableByteChannel wbc) throws IOException, InvalidRangeException {
+    if ((ncfile == null) || hasCachedData())
+      return IospHelper.copyToByteChannel( read(section), wbc);
+    
+    return ncfile.readToByteChannel(this, section, wbc);
+  }
+
+  /*******************************************/
+  /* nicely formatted string representation */
+
+  /**
+   * Get the display name plus the dimensions, eg 'float name(dim1, dim2)'
+   * @return display name plus the dimensions
+   */
+  public String getNameAndDimensions() {
+    Formatter buf = new Formatter();
+    getNameAndDimensions(buf, true, false);
+    return buf.toString();
+  }
+
+  /**
+   * Get the display name plus the dimensions, eg 'float name(dim1, dim2)'
+   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
+   * @return display name plus the dimensions
+   */
+  public String getNameAndDimensions(boolean strict) {
+    Formatter buf = new Formatter();
+    getNameAndDimensions(buf, false, strict);
+    return buf.toString();
+  }
+
+  /**
+   * Get the display name plus the dimensions, eg 'name(dim1, dim2)'
+   * @param buf add info to this StringBuilder
+   */
+  public void getNameAndDimensions(StringBuilder buf) {
+    getNameAndDimensions(buf, true, false);
+  }
+
+  /**
+   * Get the display name plus the dimensions, eg 'name(dim1, dim2)'
+   * @param buf add info to this StringBuffer
+   * @deprecated use getNameAndDimensions(StringBuilder buf)
+   */
+  public void getNameAndDimensions(StringBuffer buf) {
+    Formatter proxy = new Formatter();
+    getNameAndDimensions(proxy, true, false);
+    buf.append(proxy.toString());
+  }
+
+  /**
+   * Add display name plus the dimensions to the StringBuffer
+   * @param buf add info to this
+   * @param useFullName use full name else short name. strict = true implies short name
+   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
+   */
+  public void getNameAndDimensions(StringBuilder buf, boolean useFullName, boolean strict) {
+    Formatter proxy = new Formatter();
+    getNameAndDimensions(proxy, useFullName, strict);
+    buf.append(proxy.toString());
+  }
+
+
+  /**
+   * Add display name plus the dimensions to the StringBuffer
+   * @param buf add info to this
+   * @param useFullName use full name else short name. strict = true implies short name
+   * @param strict strictly comply with ncgen syntax, with name escaping. otherwise, get extra info, no escaping
+   */
+  public void getNameAndDimensions(Formatter buf, boolean useFullName, boolean strict) {
+    useFullName = useFullName && !strict;
+    String name = useFullName ? getFullName() : getShortName();
+    if (strict) name = NetcdfFile.escapeNameCDL( getShortName());
+    buf.format("%s", name);
+
+    if (getRank() > 0) buf.format("(");
+    for (int i = 0; i < dimensions.size(); i++) {
+      Dimension myd = dimensions.get(i);
+      String dimName = myd.getName();
+      if ((dimName != null) && strict)
+        dimName = NetcdfFile.escapeNameCDL(dimName);
+
+      if (i != 0) buf.format(", ");
+
+      if (myd.isVariableLength()) {
+        buf.format("*");
+      } else if (myd.isShared()) {
+        if (!strict)
+          buf.format("%s=%d",dimName,myd.getLength());
+        else
+          buf.format("%s",dimName);
+      } else {
+        if (dimName != null) {
+          buf.format("%s=", dimName);
+        }
+        buf.format("%d", myd.getLength());
+      }
+    }
+
+    if (getRank() > 0) buf.format(")");
+  }
+
+  /**
+   * CDL representation of Variable, not strict.
+   */
+  public String toString() {
+    return writeCDL("   ", false, false);
+  }
+
+  /**
+   * CDL representation of a Variable.
+   *
+   * @param indent      start each line with this much space
+   * @param useFullName use full name, else use short name
+   * @param strict      strictly comply with ncgen syntax
+   * @return CDL representation of the Variable.
+   */
+  public String writeCDL(String indent, boolean useFullName, boolean strict) {
+    Formatter buf = new Formatter();
+    writeCDL(buf, indent, useFullName, strict);
+    return buf.toString();
+  }
+
+  protected void writeCDL(Formatter buf, String indent, boolean useFullName, boolean strict) {
+    buf.format(indent);
+    if (dataType.isEnum()) {
+      if (enumTypedef == null)
+        buf.format("enum UNKNOWN");
+      else
+        buf.format("enum %s", NetcdfFile.escapeNameCDL(enumTypedef.getName()));
+    } else
+      buf.format(dataType.toString());
+
+    //if (isVariableLength) buf.append("(*)"); // LOOK
+    buf.format(" ");
+    getNameAndDimensions(buf, useFullName, strict);
+    buf.format(";");
+    if (!strict) buf.format(extraInfo());
+    buf.format("\n");
+
+    for (Attribute att : getAttributes()) {
+      buf.format("%s  ", indent);
+      if (strict) buf.format( NetcdfFile.escapeNameCDL(getShortName()));
+      buf.format(":%s;", att.toString(strict));
+      if (!strict && (att.getDataType() != DataType.STRING))
+        buf.format(" // %s", att.getDataType());
+      buf.format("\n");
+    }
+  }
+
+  /**
+   * String representation of Variable and its attributes.
+   */
+  public String toStringDebug() {
+    return ncfile.toStringDebug(this);
+  }
+
+  private static boolean showSize = false;
+
+  protected String extraInfo() {
+    return showSize ? " // " + getElementSize() + " " + getSize() : "";
+  }
+
+  /**
+   * Instances which have same content are equal.
+   */
+  public boolean equals(Object oo) {
+    if (this == oo) return true;
+    if (!(oo instanceof Variable)) return false;
+    Variable o = (Variable) oo;
+
+    if (!getShortName().equals(o.getShortName())) return false;
+    if (isScalar() != o.isScalar()) return false;
+    if (getDataType() != o.getDataType()) return false;
+    if (!getParentGroup().equals(o.getParentGroup())) return false;
+    if ((getParentStructure() != null) && !getParentStructure().equals(o.getParentStructure())) return false;
+    if (isVariableLength() != o.isVariableLength()) return false;
+    if (dimensions.size() != o.getDimensions().size()) return false;
+    for (int i=0; i<dimensions.size(); i++)
+      if (!getDimension(i).equals(o.getDimension(i))) return false;
+
+    return true;
+  }
+
+  /**
+   * Override Object.hashCode() to implement equals.
+   */
+  public int hashCode() {
+    if (hashCode == 0) {
+      int result = 17;
+      result = 37 * result + getShortName().hashCode();
+      if (isScalar()) result++;
+      result = 37 * result + getDataType().hashCode();
+      result = 37 * result + getParentGroup().hashCode();
+      if (parent != null)
+        result = 37 * result + parent.hashCode();
+      if (isVariableLength) result++;
+      result = 37 * result + dimensions.hashCode();
+      hashCode = result;
+    }
+    return hashCode;
+  }
+
+  protected int hashCode = 0;
+
+  /**
+   * Sort by name
+   */
+  public int compareTo(VariableSimpleIF o) {
+    return getShortName().compareTo(o.getShortName());
+  }
+
+  /////////////////////////////////////////////////////////////////////////////
+
+  protected Variable() {
+  }
+
+  /**
+   * Create a Variable. Also must call setDataType() and setDimensions()
+   *
+   * @param ncfile    the containing NetcdfFile.
+   * @param group     the containing group; if null, use rootGroup
+   * @param parent    parent Structure, may be null
+   * @param shortName variable shortName, must be unique within the Group
+   */
+  public Variable(NetcdfFile ncfile, Group group, Structure parent, String shortName) {
+    this.ncfile = ncfile;
+    this.group = (group == null) ? ncfile.getRootGroup() : group;
+    this.parent = parent;
+    this.shortName = shortName;
+  }
+
+  /**
+   * Create a Variable. Also must call setDataType() and setDimensions()
+   *
+   * @param ncfile    the containing NetcdfFile.
+   * @param group     the containing group; if null, use rootGroup
+   * @param parent    parent Structure, may be null
+   * @param shortName variable shortName, must be unique within the Group
+   * @param dtype     the Variable's DataType
+   * @param dims      space delimited list of dimension names. may be null or "" for scalars.
+   */
+  public Variable(NetcdfFile ncfile, Group group, Structure parent, String shortName, DataType dtype, String dims) {
+    this.ncfile = ncfile;
+    this.group = (group == null) ? ncfile.getRootGroup() : group;
+    this.parent = parent;
+    this.shortName = shortName;
+    setDataType( dtype);
+    setDimensions( dims);
+  }
+
+  /**
+   * Copy constructor.
+   * The returned Variable is mutable.
+   * It shares the cache object and the iosp Object, attributes and dimensions with the original.
+   * Does not share the proxyReader.
+   * Use for section, slice, "logical views" of original variable.
+   *
+   * @param from copy from this Variable.
+   */
+  public Variable(Variable from) {
+    this.attributes = new ArrayList<Attribute>(from.attributes); // attributes are immutable
+    this.cache = from.cache; // caller should do createNewCache() if dont want to share
+    this.dataType = from.getDataType();
+    this.dimensions = new ArrayList<Dimension>(from.dimensions); // dimensions are shared
+    this.elementSize = from.getElementSize();
+    this.enumTypedef = from.enumTypedef;
+    this.group = from.group;
+    this.isMetadata = from.isMetadata;
+    this.isVariableLength = from.isVariableLength;
+    this.ncfile = from.ncfile;
+    this.parent = from.parent;
+    this.shape = from.getShape();
+    this.shortName = from.shortName;
+    this.sizeToCache = from.sizeToCache;
+    this.spiObject = from.spiObject;
+  }
+
+  ///////////////////////////////////////////////////
+  // the following make this mutable
+
+  /**
+   * Set the data type
+   *
+   * @param dataType set to this value
+   */
+  public void setDataType(DataType dataType) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.dataType = dataType;
+    this.elementSize = getDataType().getSize();
+  }
+
+  /**
+   * Set the short name, converting to valid CDM object name if needed.
+   *
+   * @param shortName set to this value
+   * @return valid CDM object name
+   */
+  public String setName(String shortName) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.shortName = NetcdfFile.makeValidCdmObjectName(shortName);
+    return this.shortName;
+  }
+
+  /**
+   * Set the parent group.
+   *
+   * @param group set to this value
+   */
+  public void setParentGroup(Group group) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.group = group;
+  }
+
+  /**
+   * Set the element size. Usually elementSize is determined by the dataType,
+   * use this only for exceptional cases.
+   *
+   * @param elementSize set to this value
+   */
+  public void setElementSize(int elementSize) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.elementSize = elementSize;
+  }
+
+  /**
+   * Add new or replace old if has same name
+   *
+   * @param att add this Attribute
+   * @return the added attribute
+   */
+  public Attribute addAttribute(Attribute att) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    for (int i = 0; i < attributes.size(); i++) {
+      Attribute a = attributes.get(i);
+      if (att.getName().equals(a.getName())) {
+        attributes.set(i, att); // replace
+        return att;
+      }
+    }
+    attributes.add(att);
+    return att;
+  }
+
+  /**
+   * Remove an Attribute : uses the attribute hashCode to find it.
+   *
+   * @param a remove this attribute
+   * @return true if was found and removed
+   */
+  public boolean remove(Attribute a) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    return a != null && attributes.remove(a);
+  }
+
+  /**
+   * Remove an Attribute by name.
+   *
+   * @param attName if exists, remove this attribute
+   * @return true if was found and removed
+   */
+  public boolean removeAttribute(String attName) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    Attribute att = findAttribute(attName);
+    return att != null && attributes.remove(att);
+  }
+
+  /**
+   * Remove an Attribute by name, ignoring case
+   *
+   * @param attName if exists, remove this attribute
+   * @return true if was found and removed
+   */
+  public boolean removeAttributeIgnoreCase(String attName) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    Attribute att = findAttributeIgnoreCase(attName);
+    return att != null && attributes.remove(att);
+  }
+
+  /**
+   * Set the shape with a list of Dimensions. The Dimensions may be shared or not.
+   * Dimensions are in order, slowest varying first. Send a null for a scalar.
+   * Technically you can use Dimensions from any group; pragmatically you should only use
+   * Dimensions contained in the Variable's parent groups.
+   *
+   * @param dims list of type ucar.nc2.Dimension
+   */
+  public void setDimensions(List<Dimension> dims) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.dimensions = (dims == null) ? new ArrayList<Dimension>() : new ArrayList<Dimension>(dims);
+    resetShape();
+  }
+
+  /**
+   * Use when dimensions have changed, to recalculate the shape.
+   */
+  public void resetShape() {
+    // if (immutable) throw new IllegalStateException("Cant modify");  LOOK allow this for unlimited dimension updating
+    this.shape = new int[dimensions.size()];
+    for (int i = 0; i < dimensions.size(); i++) {
+      Dimension dim = dimensions.get(i);
+      shape[i] = dim.getLength();
+      //shape[i] = Math.max(dim.getLength(), 0); // LOOK
+      // if (dim.isUnlimited() && (i != 0)) // LOOK only true for Netcdf-3
+      //   throw new IllegalArgumentException("Unlimited dimension must be outermost");
+      if (dim.isVariableLength()) {
+        //if (dimensions.size() != 1)
+        //  throw new IllegalArgumentException("Unknown dimension can only be used in 1 dim array");
+        //else
+          isVariableLength = true;
+      }
+    }
+    this.shapeAsSection = null; // recalc next time its asked for
+  }
+
+  /**
+   * Set the dimensions using the dimensions names. The dimension is searched for recursively in the parent groups.
+   *
+   * @param dimString : whitespace seperated list of dimension names, or '*' for Dimension.UNKNOWN. null or empty String is a scalar.
+   */
+  public void setDimensions(String dimString) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    List<Dimension> newDimensions = new ArrayList<Dimension>();
+
+    if ((dimString == null) || (dimString.length() == 0)) { // scalar
+      this.dimensions = newDimensions;
+      resetShape();
+      return;
+    }
+
+    StringTokenizer stoke = new StringTokenizer(dimString);
+    while (stoke.hasMoreTokens()) {
+      String dimName = stoke.nextToken();
+      Dimension d = dimName.equals("*") ? Dimension.VLEN : group.findDimension(dimName);
+      if (d == null) {
+        // if numeric - then its anonymous dimension
+        try {
+          int len = Integer.parseInt(dimName);
+          d = new Dimension("", len, false, false, false);
+        } catch (Exception e)  {
+          throw new IllegalArgumentException("Variable " + getFullName() + " setDimensions = " + dimString +
+              " FAILED, dim doesnt exist=" + dimName+ " file = "+ncfile.getLocation());
+        }
+      }
+      newDimensions.add(d);
+    }
+
+    this.dimensions = newDimensions;
+    resetShape();
+  }
+
+  /**
+   * Reset the dimension array. Anonymous dimensions are left alone.
+   * Shared dimensions are searched for recursively in the parent groups.
+   */
+  public void resetDimensions() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    ArrayList<Dimension> newDimensions = new ArrayList<Dimension>();
+
+    for (Dimension dim : dimensions) {
+      if (dim.isShared()) {
+        Dimension newD = group.findDimension(dim.getName());
+        if (newD == null)
+          throw new IllegalArgumentException("Variable " + getFullName() + " resetDimensions  FAILED, dim doesnt exist in parent group=" + dim);
+        newDimensions.add(newD);
+      } else {
+        newDimensions.add( dim);
+      }
+    }
+    this.dimensions = newDimensions;
+    resetShape();
+  }
+
+  /**
+   * Set the dimensions using all anonymous (unshared) dimensions
+   *
+   * @param shape defines the dimension lengths. must be > 0, or -1 for VLEN
+   * @throws ucar.ma2.InvalidRangeException if any shape < 1
+   */
+  public void setDimensionsAnonymous(int[] shape) throws InvalidRangeException {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.dimensions = new ArrayList<Dimension>();
+    for (int i = 0; i < shape.length; i++) {
+      if ((shape[i] < 1) &&  (shape[i] != -1)) throw new InvalidRangeException("shape[" + i + "]=" + shape[i] + " must be > 0");
+      Dimension anon;
+      if (shape[i] == -1) {
+        anon = Dimension.VLEN;
+        isVariableLength = true;
+      } else {
+        anon = new Dimension(null, shape[i], false, false, false);
+      }
+
+      dimensions.add(anon);
+    }
+    resetShape();
+  }
+
+  /**
+   * Set this Variable to be a scalar
+   */
+  public void setIsScalar() {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.dimensions = new ArrayList<Dimension>();
+    resetShape();
+  }
+
+  /**
+   * Replace a dimension with an equivalent one.
+   * @param dim must have the same name, length as old one
+   *
+  public void replaceDimension( Dimension dim) {
+  int idx = findDimensionIndex( dim.getName());
+  if (idx >= 0)
+  dimensions.set( idx, dim);
+  resetShape();
+  } */
+
+  /**
+   * Replace a dimension with an equivalent one.
+   *
+   * @param idx index into dimension array
+   * @param dim to set
+   */
+  public void setDimension(int idx, Dimension dim) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    dimensions.set(idx, dim);
+    resetShape();
+  }
+
+  /**
+   * Make this immutable.
+   * @return this
+   */
+  public Variable setImmutable() {
+    immutable = true;
+    dimensions = Collections.unmodifiableList(dimensions);
+    attributes = Collections.unmodifiableList(attributes);
+    return this;
+  }
+
+  /**
+   * Is this Variable immutable
+   * @return if immutable
+   */
+  public boolean isImmutable() { return immutable; }
+
+
+  // for IOServiceProvider
+  protected Object spiObject;
+
+  /**
+   * Should not be public.
+   * @return the IOSP object
+   */
+  public Object getSPobject() {
+    return spiObject;
+  }
+
+  /**
+   * Should not be public.
+   * @param spiObject the IOSP object
+   */
+  public void setSPobject(Object spiObject) {
+    this.spiObject = spiObject;
+  }
+
+  ////////////////////////////////////////////////////////////////////////////////////
+  // caching
+
+  /**
+   * If total data size is less than SizeToCache in bytes, then cache.
+   *
+   * @return size at which caching happens
+   */
+  public int getSizeToCache() {
+    if (sizeToCache >= 0) return sizeToCache; // it was set
+    return isCoordinateVariable() ? defaultCoordsSizeToCache : defaultSizeToCache;
+  }
+
+  /**
+   * Set the sizeToCache. If not set, use defaults
+   *
+   * @param sizeToCache size at which caching happens. < 0 means use defaults
+   */
+  public void setSizeToCache(int sizeToCache) {
+    this.sizeToCache = sizeToCache;
+  }
+
+  /**
+   * Set whether to cache or not. Implies that the entire array will be stored, once read.
+   * Normally this is set automatically based on size of data.
+   *
+   * @param caching set if caching.
+   */
+  public void setCaching(boolean caching) {
+    this.cache.isCaching = caching;
+    this.cache.cachingSet = true;
+  }
+
+  /**
+   * Will this Variable be cached when read.
+   * Set externally, or calculated based on total size < sizeToCache.
+   *
+   * @return true is caching
+   */
+  public boolean isCaching() {
+    if (!this.cache.cachingSet) {
+      cache.isCaching = !isVariableLength && (getSize() * getElementSize() < getSizeToCache());
+      this.cache.cachingSet = true;
+    }
+    return cache.isCaching;
+  }
+
+  /**
+   * Invalidate the data cache
+   */
+  public void invalidateCache() {
+    cache.data = null;
+  }
+
+  public void setCachedData(Array cacheData) {
+    setCachedData(cacheData, false);
+  }
+
+  //public Array getCachedData() {
+  //  return (cache == null) ? null : cache.data;
+  //}
+  /**
+   * Set the data cache
+   *
+   * @param cacheData  cache this Array
+   * @param isMetadata : synthesized data, set true if must be saved in NcML output (ie data not actually in the file).
+   */
+  public void setCachedData(Array cacheData, boolean isMetadata) {
+    if ((cacheData != null) && (cacheData.getElementType() != getDataType().getPrimitiveClassType()))
+      throw new IllegalArgumentException("setCachedData type="+cacheData.getElementType()+" incompatible with variable type="+getDataType());
+
+    //if (cacheData.getSize() > 10 * 1000 * 1000)
+    //   System.out.println("HEY");   
+
+    this.cache.data = cacheData;
+    this.isMetadata = isMetadata;
+    this.cache.cachingSet = true;
+    this.cache.isCaching = true;
+  }
+
+  /**
+   * Create a new data cache, use this when you dont want to share the cache.
+   */
+  public void createNewCache() {
+    this.cache = new Cache();
+  }
+
+  /**
+   * Has data been read and cached.
+   * Use only on a Variable, not a subclass.
+   * @return true if data is read and cached
+   */
+  public boolean hasCachedData() {
+    return (cache != null) && (null != cache.data);
+  }
+
+  // this indirection allows us to share the cache among the variable's sections and copies
+  static protected class Cache {
+    public Array data;
+    public boolean isCaching = false;
+    public boolean cachingSet = false;
+
+    public Cache() {
+    }
+  }
+
+  ///////////////////////////////////////////////////////////////////////
+  // setting variable data values
+
+  /**
+   * Generate the list of values from a starting value and an increment.
+   * Will reshape to variable if needed.
+   *
+   * @param npts  number of values, must = v.getSize()
+   * @param start starting value
+   * @param incr  increment
+   */
+  public void setValues(int npts, double start, double incr) {
+    if (npts != getSize())
+      throw new IllegalArgumentException("bad npts = " + npts + " should be " + getSize());
+    Array data = Array.makeArray(getDataType(), npts, start, incr);
+    if (getRank() != 1)
+      data = data.reshape(getShape());
+    setCachedData(data, true);
+  }
+
+  /**
+   * Set the data values from a list of Strings.
+   *
+   * @param values list of Strings
+   * @throws IllegalArgumentException if values array not correct size, or values wont parse to the correct type
+   */
+  public void setValues(List<String> values) throws IllegalArgumentException {
+    Array data = Array.makeArray(getDataType(), values);
+
+    if (data.getSize() != getSize())
+      throw new IllegalArgumentException("Incorrect number of values specified for the Variable " + getFullName() +
+              " needed= " + getSize() + " given=" + data.getSize());
+
+    if (getRank() != 1) // dont have to reshape for rank 1
+      data = data.reshape(getShape());
+
+    setCachedData(data, true);
+  }
+
+  ////////////////////////////////////////////////////////////////////////
+  // StructureMember - could be a subclass, but that has problems
+
+  /**
+   * Is this variable a member of a Structure?.
+   */
+  public boolean isMemberOfStructure() {
+    return parent != null;
+  }
+
+  /**
+   * Get the parent Variable if this is a member of a Structure, or null if its not.
+   */
+  public Structure getParentStructure() {
+    return parent;
+  }
+
+  /**
+   * Set the parent structure.
+   *
+   * @param parent set to this value
+   */
+  public void setParentStructure(Structure parent) {
+    if (immutable) throw new IllegalStateException("Cant modify");
+    this.parent = parent;
+  }
+
+  /**
+   * Get list of Dimensions, including parents if any.
+   *
+   * @return array of Dimension, rank of v plus all parents.
+   */
+  public List<Dimension> getDimensionsAll() {
+    List<Dimension> dimsAll = new ArrayList<Dimension>();
+    addDimensionsAll(dimsAll, this);
+    return dimsAll;
+  }
+
+  private void addDimensionsAll(List<Dimension> result, Variable v) {
+    if (v.isMemberOfStructure())
+      addDimensionsAll(result, v.getParentStructure());
+
+    for (int i=0; i<v.getRank(); i++)
+      result.add( v.getDimension(i));
+  }
+
+  public int[] getShapeAll() {
+    if (parent == null) return getShape();
+    List<Dimension> dimAll = getDimensionsAll();
+    int[] shapeAll = new int[dimAll.size()];
+    for (int i=0; i<dimAll.size(); i++)
+      shapeAll[i] = dimAll.get(i).getLength();
+    return shapeAll;
+  }
+
+
+  /*
+   * Read data in all structures for this Variable, using a string sectionSpec to specify the section.
+   * See readAllStructures(Section section, boolean flatten) method for details.
+   *
+   * @param sectionSpec specification string, eg "1:2,10,:,1:100:10"
+   * @param flatten     if true, remove enclosing StructureData.
+   * @return the requested data which has the shape of the request.
+   * @see #readAllStructures
+   * @deprecated
+   *
+  public Array readAllStructuresSpec(String sectionSpec, boolean flatten) throws IOException, InvalidRangeException {
+    return readAllStructures(new Section(sectionSpec), flatten);
+  }
+
+  /*
+   * Read data from all structures for this Variable.
+   * This is used for member variables whose parent Structure(s) is not a scalar.
+   * You must specify a Range for each dimension in the enclosing parent Structure(s).
+   * The returned Array will have the same shape as the requested section.
+   * <p/>
+   * <p>If flatten is false, return nested Arrays of StructureData that correspond to the nested Structures.
+   * The innermost Array(s) will match the rank and type of the Variable, but they will be inside Arrays of
+   * StructureData.
+   * <p/>
+   * <p>If flatten is true, remove the Arrays of StructureData that wrap the data, and return an Array of the
+   * same type as the Variable. The shape of the returned Array will be an accumulation of all the shapes of the
+   * Structures containing the variable.
+   *
+   * @param sectionAll an array of Range objects, one for each Dimension of the enclosing Structures, as well as
+   *                   for the Variable itself. If the list is null, use the full shape for everything.
+   *                   If an individual Range is null, use the full shape for that dimension.
+   * @param flatten    if true, remove enclosing StructureData. Otherwise, each parent Structure will create a
+   *                   StructureData container for the returned data array.
+   * @return the requested data which has the shape of the request.
+   * @deprecated
+   *
+  public Array readAllStructures(ucar.ma2.Section sectionAll, boolean flatten) throws java.io.IOException, ucar.ma2.InvalidRangeException {
+    Section resolved; // resolve all nulls
+    if (sectionAll == null)
+      resolved = makeSectionAddParents(null, false); // everything
+    else {
+      ArrayList<Range> resultAll = new ArrayList<Range>();
+      makeSectionWithParents(resultAll, sectionAll.getRanges(), this);
+      resolved = new Section(resultAll);
+    }
+
+    return _readMemberData(resolved, flatten);
+  }
+
+  // recursively create the section (list of Range) array
+  private List<Range> makeSectionWithParents(List<Range> result, List<Range> orgSection, Variable v) throws InvalidRangeException {
+    List<Range> section = orgSection;
+
+    // do parent stuctures(s) first
+    if (v.isMemberOfStructure())
+      section = makeSectionWithParents(result, orgSection, v.getParentStructure());
+
+    // process just this variable's subList
+    List<Range> myList = section.subList(0, v.getRank());
+    Section mySection = new Section(myList, v.getShape());
+    result.addAll(mySection.getRanges());
+
+    // return section with this variable's sublist removed
+    return section.subList(v.getRank(), section.size());
+  } */
+
+  /*
+   * Composes this variable's ranges with another list of ranges, adding parent ranges; resolves nulls.
+   *
+   * @param section   Section of this Variable, same rank as v, may have nulls or be null.
+   * @param firstOnly if true, get first parent, else get all parrents.
+   * @return Section, rank of v plus parents, no nulls
+   * @throws InvalidRangeException if bad
+   *
+  private Section makeSectionAddParents(Section section, boolean firstOnly) throws InvalidRangeException {
+    Section result;
+    if (section == null)
+      result = new Section(getRanges());
+    else
+      result = new Section(section.getRanges(), getShape());
+
+    // add parents
+    Structure p = getParentStructure();
+    while (p != null) {
+      Section parentSection = p.getShapeAsSection();
+      for (int i = parentSection.getRank() - 1; i >= 0; i--) { // reverse
+        Range r = parentSection.getRange(i);
+        result.insertRange(0, firstOnly ? new Range(0, 0) : r);
+      }
+      p = p.getParentStructure();
+    }
+
+    return result;
+  } */
+
+  /* private Array readMemberOfStructureFlatten(Section section) throws InvalidRangeException, IOException {
+    // get through first parents element
+    Section sectionAll = makeSectionAddParents(section, true);
+    Array data = _readMemberData(sectionAll, true); // flatten
+
+    // remove parent dimensions.
+    int n = data.getRank() - getRank();
+    for (int i = 0; i < n; i++)
+      if (data.getShape()[0] == 1) data = data.reduce(0);
+    return data;
+  }
+
+  /* structure-member Variable;  section has a Range for each array in the parent
+  // stuctures(s) and for the Variable.
+  protected Array _readMemberData(Section section, boolean flatten) throws IOException, InvalidRangeException {
+    return ncfile.readMemberData(this, section, flatten);
+  } */
+
+  ////////////////////////////////
+
+  /**
+   * Calculate if this is a classic coordinate variable: has same name as its first dimension.
+   * If type char, must be 2D, else must be 1D.
+   * @return true if a coordinate variable.
+   */
+  public boolean isCoordinateVariable() {
+    if ((dataType == DataType.STRUCTURE) || isMemberOfStructure()) // Structures and StructureMembers cant be coordinate variables
+      return false;
+
+    int n = getRank();
+    if (n == 1 && dimensions.size() == 1) {
+      Dimension firstd = dimensions.get(0);
+      if (shortName.equals(firstd.getName())) { //  : short names match
+        return true;
+      }
+    }
+    if (n == 2 && dimensions.size() == 2) {    // two dimensional
+      Dimension firstd = dimensions.get(0);
+      if (shortName.equals(firstd.getName()) &&  // short names match
+          (getDataType() == DataType.CHAR)) {         // must be char valued (really a String)
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  public Object clone()  throws CloneNotSupportedException
+  {
+      Variable clone = (Variable)super.clone();
+
+      // Do we need to clone these?
+      // protected Cache cache = new Cache();
+      // protected int sizeToCache = -1; // bytes
+
+      clone.setParentGroup(group);
+      clone.setParentStructure(parent);
+      clone.setProxyReader(clone);
+      return clone;
+  }
+
+
+  ///////////////////////////////////////////////////////////////////////
+  // deprecated
+  /**
+   * @deprecated use isVariableLength()
+   * @return isVariableLength()
+   */
+  public boolean isUnknownLength() {
+    return isVariableLength;
+  }
+}
Only in ../fake_netcdf/cdm: target
