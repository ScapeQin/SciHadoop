diff -r ../orig_netcdf/cdm//src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java cdm//src/main/java/ucar/nc2/iosp/AbstractIOServiceProvider.java
102a103,112
>   public boolean supportsLocalityInformation() throws IOException {
>     throw new IOException("This IOSP does not support getLocalityInformation()");
>   }
> 
>   @Override
>   public ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section) throws IOException, InvalidRangeException {
>     throw new IOException("This IOSP does not support getLocalityInformation()");
>   }
> 
>   @Override
diff -r ../orig_netcdf/cdm//src/main/java/ucar/nc2/iosp/IOServiceProvider.java cdm//src/main/java/ucar/nc2/iosp/IOServiceProvider.java
126a127,152
>   /**
>    * Calculate the offset in the underlying byte-stream for each value
>    * indicated by the section and variable objects
>    *
>    * @param v2 a top-level Variable
>    * @param section the section of data to read.
>    *   There must be a Range for each Dimension in the variable, in order.
>    *   Note: no nulls allowed. IOSP may not modify.
>    * @return an ArrayLong the same shape as section where each entry is the 
>    *         offset of the corresponding data element
>    * @throws java.io.IOException if read error or if this IOSP doesn't 
>    *                             support getLocalityInformation()
>    * @throws ucar.ma2.InvalidRangeException if invalid section
>    */
>   public ucar.ma2.ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section) 
>          throws IOException, InvalidRangeException;
> 
>   /**
>    * Determine if this IOServiceProvider supports the getLocalityInformation() function
>    *
>    * @return a boolean indicating if getLocalityInformation is supported by
>    *         this IOServiceProvider
>    */
>   public boolean supportsLocalityInformation() throws IOException;
> 
> 
diff -r ../orig_netcdf/cdm//src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java cdm//src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
412a413,480
>   /**
>    * query to see if this IOSP supports the getLocalityInformation() function
>    *
>    * @return a boolean indicating that this IOSP supports the getLocalityInformation() call
>    */
>   public boolean supportsLocalityInformation() { 
>     return true;
>   }
> 
>   /**
>    * Returns an ArrayLong with each entry corresponding to the offset in the filestream
>    * of the same data cell in the section arguement to the function
>    *
>    * @param v2 the variable to get the data from
>    * @param section the record range to read
>    * @return an ArrayLong object that's the shape as the section arguement
>    * @throws InvalidRangeException on error
>    * @throws IOException on error
>    */
>   public ArrayLong getLocalityInformation(ucar.nc2.Variable v2, Section section)
>          throws InvalidRangeException, IOException {
> 
>     // An array to hold the offsets that will be returned
>     ArrayLong array = new ArrayLong(section.getShape());
> 
>     // Index into the results array
>     Index aIndex = array.getIndex();
> 
>     // dataSize is used to increment the offsets within a given
>     // chunk appropriately
>     DataType type = v2.getDataType();
>     int dataSize = type.getSize();
> 
>     Layout layout = getLayout(v2, section);
> 
>     // iterate over all the chunks in the calculated Layout
>     while( layout.hasNext() ){
>       Layout.Chunk chunk = layout.next();
> 
>       // iterate over the elements in this chunk
>       for( int i = 0; i < chunk.getNelems(); i++){
>         // write the offset into the results array, then iterate the index
>         array.setLong(aIndex, chunk.getSrcPos() + (i * dataSize));
>         aIndex.incr();
>       }
>     }
> 
>     return array;
>   }
> 
>   /**
>    * Returns a Layout object for use by an N3iosp object
>    *
>    * @param v2 the variable to get the layout information for
>    * @param section the record range to read
>    * @return a Layout corresponding to the Section requested
>    * @throws IOException on error
>    */
>   private Layout getLayout(Variable v2, Section section) throws InvalidRangeException {
>     N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
> 
>     Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) 
>       : new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
> 
>     return layout;
>   }
> 
>   /////////////////////////////////////////////////////////////////////////////
422,424c490
< 
<     Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
<       new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
---
>     Layout layout = getLayout(v2, section);
568,570c634
< 
<     Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
<       new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
---
>     Layout layout = getLayout(v2, section);
666d729
<     N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
678,679c741
<       Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
<         new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
---
>       Layout layout = getLayout(v2, section);
diff -r ../orig_netcdf/cdm//src/main/java/ucar/nc2/NetcdfFile.java cdm//src/main/java/ucar/nc2/NetcdfFile.java
425a426,429
>   public static NetcdfFile open(ucar.unidata.io.RandomAccessFile raf, String location) throws IOException {
>     return open(raf, location, null, null);
>   }
> 
1096a1101,1113
>    * Return true if this file supports querying for locality information.
>    * @return if the file can return locality information
>    * @throws IOException if there is not an IOServiceProvider set
>    */
>   public boolean supportsLocalityInformation() throws IOException {
>     if (spi == null) {
>       throw new IOException("spi is null");
>     }
> 
>     return spi.supportsLocalityInformation();
>   }
> 
>   /**
1834a1852,1862
>   }
> 
>   public ArrayLong getLocalityInformation(ucar.nc2.Variable v, Section ranges) 
>          throws IOException, InvalidRangeException {
>     if (spi == null) {
>       throw new IOException("spi is null");
>     } else if (!spi.supportsLocalityInformation()) { 
>       throw new IOException("IOSP " + spi.getFileTypeId() + " does not support getLocalityInformation()");
>     }
> 
>     return spi.getLocalityInformation(v, ranges);
diff -r ../orig_netcdf/cdm//src/main/java/ucar/nc2/Variable.java cdm//src/main/java/ucar/nc2/Variable.java
607a608,641
>    * Return an ArrayLong structure with the same shape as the shape arguement
>    * where each entry is the offset in the byte-stream where the corresponding
>    * data element begins
>    * @param origin int array specifying the starting index. If null, assume all zeroes.
>    * @param shape  int array specifying the extents in each dimension.
>    *               This becomes the shape of the returned Array.
>    * @return a memory-resdient array of longs with offsets or -1 if the offset
>    *                for the corresponding cell can't be determined
>    */
>   public ArrayLong getLocalityInformation(int[] origin, int[] shape) throws IOException, InvalidRangeException {
>     return ncfile.getLocalityInformation( this, new Section(origin, shape));
>   }
> 
>   public boolean supportsLocalityInformation() throws IOException {
>     return ncfile.supportsLocalityInformation();
>   }
> 
>   /**
>    * Return an ArrayLong structure with the same shape as the shape arguement
>    * where each entry is the offset in the byte-stream where the corresponding
>    * data element begins.
>    *
>    * @param section list of Range specifying the section of data to read.
>    *                Must be null or same rank as variable.
>    *                If list is null, assume all data.
>    *                Each Range corresponds to a Dimension. If the Range object is null, it means use the entire dimension.
>    * @return a memory-resdient array of longs with offsets or -1 if the offset
>    *                for the corresponding cell can't be determined
>    */
>   public ArrayLong getLocalityInformation(Section section) throws IOException, InvalidRangeException {
>     return ncfile.getLocalityInformation(this, section);
>   }
> 
>   /**
